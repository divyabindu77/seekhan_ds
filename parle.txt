[
    {
        "input": "What is the primary goal of data abstraction in programming?\n, 
	A. To hide unnecessary details\nB. To make the code more complex\nC. To increase the performance\nD. To make the code less readable",
        "output": "A. To hide unnecessary details"
        },
        {
        "input": "Which of the following is an example of data abstraction?\n, 
	A. Using classes to encapsulate data\nB. Using global variables\nC. Using hardcoded values\nD. Using complex algorithms",
        "output": "A. Using classes to encapsulate data"
        },
        {
        "input": "Which keyword in object-oriented programming is used to implement data abstraction?\n,
        A. abstract\nB. private\nC. public\nD. static",
        "output": "A. abstract"
        },
        {
        "input": "In the context of object-oriented programming, what is a class considered to be?\n,
        A. A blueprint for objects\nB. A method for data manipulation\nC. A data structure\nD. A database",
        "output": "A. A blueprint for objects"
        },
        {
        "instruction": "Which concept allows you to use a method without needing to know the details of its implementation?",
        "input": "A. Data abstraction\nB. Inheritance\nC. Polymorphism\nD. Encapsulation",
        "output": "A. Data abstraction"
        },
        {
        "instruction": "Which of the following is NOT a characteristic of data abstraction?",
        "input": "A. Hiding internal details\nB. Exposing only relevant information\nC. Providing full access to implementation\nD. Allowing code reuse",
        "output": "C. Providing full access to implementation"
        },
        {
        "instruction": "What type of abstraction is provided by the method signature in object-oriented programming?",
        "input": "A. Data abstraction\nB. Functional abstraction\nC. Control abstraction\nD. Process abstraction",
        "output": "B. Functional abstraction"
        },
        {
        "instruction": "Which of the following would be a real-life example of data abstraction?",
        "input": "A. A vending machine that provides only options for product selection\nB. A manual factory assembly line\nC. A complex mathematical equation\nD. A detailed user manual",
        "output": "A. A vending machine that provides only options for product selection"
        },
        {
        "instruction": "What does data abstraction help achieve in software development?",
        "input": "A. Simplification of code management\nB. Increased program complexity\nC. Reduced code efficiency\nD. Direct access to hardware",
        "output": "A. Simplification of code management"
        },
        {
        "instruction": "In object-oriented programming, which type of access control helps in implementing data abstraction?",
        "input": "A. Private\nB. Protected\nC. Public\nD. Default",
        "output": "A. Private"
        },
        {
        "instruction": "In Java, which of the following is a feature used to hide the implementation details of a class?",
        "input": "A. Abstraction\nB. Inheritance\nC. Polymorphism\nD. Encapsulation",
        "output": "A. Abstraction"
        },
        {
        "instruction": "Data abstraction allows you to focus on the ________________ rather than the implementation details.",
        "input": "A. Logic\nB. Design\nC. Implementation\nD. Performance",
        "output": "A. Logic"
        },
        {
        "instruction": "Which of these best describes the concept of abstraction in software engineering?",
        "input": "A. Hiding the implementation details and showing only the functionality\nB. Hiding the code and showing the hardware\nC. Hiding the logic and showing the data\nD. Hiding the system and showing the algorithm",
        "output": "A. Hiding the implementation details and showing only the functionality"
        },
        {
        "instruction": "Which of the following is an example of a class that implements abstraction?",
        "input": "A. A car class with methods like start, stop, and accelerate\nB. A class that directly manipulates memory\nC. A class that implements complex algorithms\nD. A class with all public methods",
        "output": "A. A car class with methods like start, stop, and accelerate"
        },
        {
        "instruction": "What does the 'abstract' keyword in Java denote when used before a class?",
        "input": "A. The class cannot be instantiated\nB. The class cannot have constructors\nC. The class must have only private methods\nD. The class is part of a package",
        "output": "A. The class cannot be instantiated"
        },
        {
        "instruction": "What is the benefit of data abstraction in large software systems?",
        "input": "A. It simplifies the system by hiding complexity\nB. It makes the system slower\nC. It allows direct hardware access\nD. It increases the need for documentation",
        "output": "A. It simplifies the system by hiding complexity"
        },
        {
        "instruction": "What does it mean when an object has an 'abstract' class as a parent?",
        "input": "A. The object can inherit methods but cannot instantiate the abstract class\nB. The object cannot inherit methods from the abstract class\nC. The object must implement all methods of the abstract class\nD. The object can modify the methods of the abstract class",
        "output": "A. The object can inherit methods but cannot instantiate the abstract class"
        },
        {
        "instruction": "In which scenario would data abstraction be useful in a software project?",
        "input": "A. When you want to hide complex logic from the user\nB. When you need full access to the data structures\nC. When you need to expose all implementation details\nD. When performance is not important",
        "output": "A. When you want to hide complex logic from the user"
        },
        {
        "instruction": "What is one of the main goals of data abstraction in object-oriented programming?",
        "input": "A. To separate the interface from the implementation\nB. To allow direct hardware access\nC. To make the code more complicated\nD. To create complex algorithms",
        "output": "A. To separate the interface from the implementation"
        },
        {
        "instruction": "Which of the following correctly describes the abstraction process in object-oriented programming?",
        "input": "A. Hiding implementation details and exposing only relevant functionalities\nB. Exposing all the implementation details\nC. Hiding all data from the program\nD. Showing only class names",
        "output": "A. Hiding implementation details and exposing only relevant functionalities"
        },
        {
        "instruction": "What is the difference between abstraction and encapsulation in object-oriented programming?",
        "input": "A. Abstraction hides complexity, while encapsulation hides data\nB. Abstraction hides data, while encapsulation hides complexity\nC. Both abstraction and encapsulation hide implementation details\nD. There is no difference between abstraction and encapsulation",
        "output": "A. Abstraction hides complexity, while encapsulation hides data"
        },
        {
            "instruction": "Which of the following is an advantage of data abstraction?",
            "input": "A. Makes the code more difficult to manage\nB. Hides unnecessary details from the user\nC. Requires more memory usage\nD. Makes the code less readable",
            "output": "B. Hides unnecessary details from the user"
            },
            {
            "instruction": "Which concept in programming allows data and methods to be hidden from other parts of the code?",
            "input": "A. Encapsulation\nB. Data abstraction\nC. Polymorphism\nD. Inheritance",
            "output": "B. Data abstraction"
            },
            {
            "instruction": "In which scenario would you use abstraction in object-oriented programming?",
            "input": "A. To protect sensitive data\nB. To make sure every method is accessible\nC. To hide complex logic and expose only necessary details\nD. To allow full access to data members",
            "output": "C. To hide complex logic and expose only necessary details"
            },
            {
            "instruction": "Which of the following represents a high level of abstraction in programming?",
            "input": "A. Writing assembly code\nB. Using object-oriented programming concepts\nC. Writing low-level system code\nD. Writing database queries",
            "output": "B. Using object-oriented programming concepts"
            },
            {
            "instruction": "In object-oriented programming, what does the use of data abstraction promote?",
            "input": "A. Increased code complexity\nB. Hiding unnecessary details and focusing on essential functionality\nC. Making code difficult to maintain\nD. Providing direct access to data members",
            "output": "B. Hiding unnecessary details and focusing on essential functionality"
            },
            {
            "instruction": "What is one of the main uses of an abstract class in Java?",
            "input": "A. To provide complete implementation\nB. To define a contract for subclasses to follow\nC. To prevent inheritance\nD. To allow a class to be instantiated",
            "output": "B. To define a contract for subclasses to follow"
            },
            {
            "instruction": "Which of the following is a true statement about abstraction?",
            "input": "A. Abstraction exposes the internal workings of a class\nB. Abstraction hides the complexity of a system\nC. Abstraction makes data more complex\nD. Abstraction is only used in low-level programming",
            "output": "B. Abstraction hides the complexity of a system"
            },
            {
            "instruction": "Which of the following is an example of achieving abstraction in Java?",
            "input": "A. Using private variables and public getter methods\nB. Using an interface to define a contract\nC. Using a class without any methods\nD. Using a static method",
            "output": "B. Using an interface to define a contract"
            },
            {
            "instruction": "What does the abstract class in Java provide to its subclasses?",
            "input": "A. Full implementation\nB. Inherited fields and methods\nC. No inheritance of methods\nD. Complete data encapsulation",
            "output": "B. Inherited fields and methods"
            },
            {
            "instruction": "Which of the following is true about methods in an abstract class?",
            "input": "A. They must have a complete implementation\nB. They cannot be overridden by subclasses\nC. They can be abstract or non-abstract\nD. They must be private",
            "output": "C. They can be abstract or non-abstract"
            },
            {
            "instruction": "What is the key purpose of abstraction in programming?",
            "input": "A. To provide full access to all data\nB. To hide implementation details and expose only essential information\nC. To make the program slower\nD. To require manual memory management",
            "output": "B. To hide implementation details and expose only essential information"
            },
            {
            "instruction": "Which programming principle hides the complexity of a system by only exposing necessary functionalities?",
            "input": "A. Abstraction\nB. Inheritance\nC. Polymorphism\nD. Encapsulation",
            "output": "A. Abstraction"
            },
            {
            "instruction": "Which statement is NOT true about data abstraction?",
            "input": "A. It helps in reducing the complexity of code\nB. It allows exposing unnecessary details\nC. It focuses on high-level concepts rather than low-level implementation\nD. It simplifies software development and maintenance",
            "output": "B. It allows exposing unnecessary details"
            },
            {
            "instruction": "How does data abstraction help in software development?",
            "input": "A. By simplifying the software design and maintenance\nB. By increasing the number of classes\nC. By making the code harder to understand\nD. By requiring more manual memory management",
            "output": "A. By simplifying the software design and maintenance"
            },
            {
            "instruction": "Which of the following is a feature of an abstract class in Java?",
            "input": "A. It can be instantiated directly\nB. It can have both abstract and non-abstract methods\nC. It cannot have constructors\nD. It does not allow method overriding",
            "output": "B. It can have both abstract and non-abstract methods"
            },
            {
            "instruction": "Which of the following is the best example of encapsulation in Java?",
            "input": "A. Hiding the internal details of a class while exposing functionality\nB. Creating abstract classes\nC. Using inheritance to extend a class\nD. Using polymorphism to modify behavior",
            "output": "A. Hiding the internal details of a class while exposing functionality"
            },
            {
            "instruction": "Which of the following allows for both data abstraction and encapsulation in Java?",
            "input": "A. Using private access modifiers for variables and providing getter/setter methods\nB. Using a public interface to expose all methods\nC. Allowing all variables to be public\nD. Writing code without classes",
            "output": "A. Using private access modifiers for variables and providing getter/setter methods"
            },
            {
            "instruction": "Which of the following statements describes the use of interfaces in Java?",
            "input": "A. Interfaces cannot be used for abstraction\nB. Interfaces define methods that must be implemented by any class\nC. Interfaces can be instantiated like regular classes\nD. Interfaces are used only for data storage",
            "output": "B. Interfaces define methods that must be implemented by any class"
            },
            {
            "instruction": "What is the role of data abstraction in software engineering?",
            "input": "A. To increase the system's complexity\nB. To hide implementation details from the user and expose only necessary functionality\nC. To directly control hardware\nD. To expose all system details to the user",
            "output": "B. To hide implementation details from the user and expose only necessary functionality"
            },
            {
            "instruction": "What is the relationship between abstraction and encapsulation?",
            "input": "A. Both are used to expose unnecessary details\nB. Abstraction hides implementation details while encapsulation hides data\nC. Abstraction and encapsulation mean the same thing\nD. Abstraction exposes all details while encapsulation hides them",
            "output": "B. Abstraction hides implementation details while encapsulation hides data"
            },
            {
            "instruction": "What is the purpose of an abstract method in an abstract class in Java?",
            "input": "A. To provide a method with a full implementation\nB. To allow the method to be overridden in subclasses\nC. To prevent inheritance\nD. To provide a default implementation",
            "output": "B. To allow the method to be overridden in subclasses"
            },
            {
            "instruction": "Which of the following is true about the use of abstraction in object-oriented programming?",
            "input": "A. It allows the creation of objects without defining any class\nB. It ensures that all details are exposed to the user\nC. It helps in managing complex systems by exposing only necessary parts\nD. It does not allow multiple inheritance",
            "output": "C. It helps in managing complex systems by exposing only necessary parts"
            },
            {
            "instruction": "What does an abstract class provide in object-oriented programming?",
            "input": "A. A way to create objects directly\nB. A template for other classes to follow\nC. A way to prevent method overriding\nD. A method to hide all the data",
            "output": "B. A template for other classes to follow"
            },
            {
            "instruction": "In the context of data abstraction, which of the following is considered a 'black box'?",
            "input": "A. A class that hides its internal implementation and exposes only necessary functionality\nB. A method with full implementation\nC. A system with open data\nD. A class that does not use any methods",
            "output": "A. A class that hides its internal implementation and exposes only necessary functionality"
            },
            {
            "instruction": "Which of the following is NOT a benefit of data abstraction?",
            "input": "A. Easier software maintenance\nB. More secure data handling\nC. Faster execution speed\nD. Reduced system complexity",
            "output": "C. Faster execution speed"
            },
            {
            "instruction": "Which statement about an abstract class is correct?",
            "input": "A. It can be instantiated directly\nB. It must contain only abstract methods\nC. It can contain both abstract and concrete methods\nD. It can only inherit from one class",
            "output": "C. It can contain both abstract and concrete methods"
            },
            {
            "instruction": "Which concept in object-oriented programming is associated with hiding unnecessary details from the user?",
            "input": "A. Polymorphism\nB. Inheritance\nC. Abstraction\nD. Encapsulation",
            "output": "C. Abstraction"
            },
            {
            "instruction": "What type of class cannot be instantiated directly?",
            "input": "A. Concrete class\nB. Abstract class\nC. Static class\nD. Final class",
            "output": "B. Abstract class"
            },
            {
            "instruction": "In a class that uses data abstraction, which of the following would be hidden from the user?",
            "input": "A. The public methods\nB. The internal implementation of the methods\nC. The constructors\nD. The class variables",
            "output": "B. The internal implementation of the methods"
            },
            {
            "instruction": "Which of the following allows a programmer to create a class where certain methods must be implemented by subclasses?",
            "input": "A. Encapsulation\nB. Inheritance\nC. Abstraction\nD. Polymorphism",
            "output": "C. Abstraction"
            },
            {
            "instruction": "Which of the following is an example of an abstract method in Java?",
            "input": "A. A method that is fully implemented\nB. A method that cannot be overridden\nC. A method that has no body and must be implemented in a subclass\nD. A method that does not return any value",
            "output": "C. A method that has no body and must be implemented in a subclass"
            },
            {
            "instruction": "In the context of object-oriented programming, what does encapsulation hide?",
            "input": "A. The abstract methods\nB. The implementation details\nC. The inheritance chain\nD. The constructor methods",
            "output": "B. The implementation details"
            },
            {
            "instruction": "What would happen if a subclass does not provide an implementation for an abstract method from its parent class?",
            "input": "A. Compilation will succeed with a warning\nB. The subclass will be abstract too\nC. The program will run without errors\nD. The parent class will provide the implementation",
            "output": "B. The subclass will be abstract too"
            },
            {
            "instruction": "Which of the following allows a class to be partially implemented but still require other classes to complete it?",
            "input": "A. Inheritance\nB. Abstraction\nC. Polymorphism\nD. Encapsulation",
            "output": "B. Abstraction"
            },
            {
            "instruction": "What is the relationship between abstraction and inheritance in object-oriented programming?",
            "input": "A. Inheritance allows hiding details, while abstraction exposes them\nB. Abstraction hides details, and inheritance allows classes to inherit those details\nC. Abstraction and inheritance are unrelated concepts\nD. Inheritance hides details, while abstraction exposes them",
            "output": "B. Abstraction hides details, and inheritance allows classes to inherit those details"
            },
            {
            "instruction": "Which of the following is an example of abstraction in a real-world scenario?",
            "input": "A. Using a car without knowing how the engine works\nB. Writing detailed code without focusing on the outcome\nC. Exposing the internal design of an API to the user\nD. Always needing to manually control the processes of a system",
            "output": "A. Using a car without knowing how the engine works"
            },
            {
            "instruction": "What does the term 'data hiding' refer to in the context of object-oriented programming?",
            "input": "A. Making data public so that it is visible everywhere\nB. Restricting access to the internal details of an object\nC. Making data available to other objects without restrictions\nD. Storing data in a hidden file format",
            "output": "B. Restricting access to the internal details of an object"
            },
            {
            "instruction": "What does it mean when a class is said to be 'abstract' in object-oriented programming?",
            "input": "A. It cannot inherit from another class\nB. It can only have concrete methods\nC. It cannot be instantiated but can provide a template for subclasses\nD. It cannot contain methods",
            "output": "C. It cannot be instantiated but can provide a template for subclasses"
            },
            {
            "instruction": "Which of the following is true about data abstraction?",
            "input": "A. It exposes the implementation details to the user\nB. It focuses on what an object does, not how it does it\nC. It makes the code harder to maintain\nD. It prevents inheritance from working correctly",
            "output": "B. It focuses on what an object does, not how it does it"
            },
            {
            "instruction": "Which of the following features of object-oriented programming helps in simplifying complex systems by hiding unnecessary details?",
            "input": "A. Polymorphism\nB. Inheritance\nC. Abstraction\nD. Encapsulation",
            "output": "C. Abstraction"
            },
            {
            "instruction": "What is an example of a scenario where data abstraction is used?",
            "input": "A. Designing a user interface with hidden implementation details\nB. Displaying the raw data from the database directly to the user\nC. Providing a full class implementation to every user\nD. Exposing the memory address of variables to the user",
            "output": "A. Designing a user interface with hidden implementation details"
            },
            {
            "instruction": "What is the primary goal of data abstraction in object-oriented programming?",
            "input": "A. To hide implementation details and only expose essential features\nB. To make classes more complicated\nC. To restrict method overriding\nD. To implement all classes as abstract",
            "output": "A. To hide implementation details and only expose essential features"
            },
            {
            "instruction": "Which of the following is NOT a characteristic of an abstract class?",
            "input": "A. It can have both abstract and concrete methods\nB. It cannot be instantiated\nC. It must contain only abstract methods\nD. It can be subclassed by other classes",
            "output": "C. It must contain only abstract methods"
            },
            {
            "instruction": "In Java, which keyword is used to declare an abstract class?",
            "input": "A. class\nB. abstract\nC. final\nD. static",
            "output": "B. abstract"
            },
            {
            "instruction": "Which of the following is true about data abstraction?",
            "input": "A. It hides the complexity of the implementation\nB. It only applies to methods, not variables\nC. It is not used in real-world applications\nD. It exposes all details of the object to the user",
            "output": "A. It hides the complexity of the implementation"
            },
            {
            "instruction": "In the context of data abstraction, which of the following is an example of a 'public interface'?",
            "input": "A. A class that provides all internal details of its methods\nB. A class that hides its implementation and exposes only necessary methods\nC. A class that prevents inheritance\nD. A class that does not have any methods",
            "output": "B. A class that hides its implementation and exposes only necessary methods"
            },
            {
            "instruction": "Which of the following is a correct example of how abstraction improves software design?",
            "input": "A. By making all details visible to the user\nB. By allowing users to interact with objects without knowing their implementation\nC. By preventing inheritance between classes\nD. By forcing all methods to be abstract",
            "output": "B. By allowing users to interact with objects without knowing their implementation"
            },
            {
            "instruction": "Which of the following is a key benefit of using data abstraction?",
            "input": "A. Easier to modify the internal implementation of an object without affecting other parts of the system\nB. More complex code that is harder to understand\nC. Increased dependencies between objects\nD. Prevents method overriding in subclasses",
            "output": "A. Easier to modify the internal implementation of an object without affecting other parts of the system"
            },
            {
            "instruction": "What does an abstract method in Java indicate?",
            "input": "A. It has a full implementation\nB. It cannot be overridden\nC. It has no body and must be implemented by subclasses\nD. It can only be declared in an interface",
            "output": "C. It has no body and must be implemented by subclasses"
            },
            {
            "instruction": "What is an interface in object-oriented programming?",
            "input": "A. A way to hide the internal workings of a class\nB. A class with no implementation\nC. A set of methods that a class must implement\nD. A class that can be instantiated directly",
            "output": "C. A set of methods that a class must implement"
            },
            {
            "instruction": "Which of the following allows a class to expose only the necessary functionality to the user while hiding implementation details?",
            "input": "A. Polymorphism\nB. Inheritance\nC. Abstraction\nD. Encapsulation",
            "output": "C. Abstraction"
            },
            {
            "instruction": "Which of the following is an example of abstraction in programming?",
            "input": "A. Providing the full source code of a class to the user\nB. Using a simple interface to interact with a complex system\nC. Exposing all class variables to the user\nD. Directly modifying the internal state of an object",
            "output": "B. Using a simple interface to interact with a complex system"
            },
            {
            "instruction": "Which of the following is true about abstract classes and interfaces in Java?",
            "input": "A. Both can contain abstract methods\nB. Abstract classes can be instantiated\nC. Interfaces can have concrete methods\nD. Abstract classes and interfaces are not used in Java",
            "output": "A. Both can contain abstract methods"
            },
            {
            "instruction": "In an object-oriented system, what is the purpose of hiding implementation details from the user?",
            "input": "A. To improve security by limiting access to sensitive data\nB. To provide better debugging information\nC. To make the code more complex\nD. To allow users to directly manipulate class variables",
            "output": "A. To improve security by limiting access to sensitive data"
            },
            {
            "instruction": "Which concept in object-oriented programming focuses on providing a simplified view of an object while hiding complex details?",
            "input": "A. Abstraction\nB. Inheritance\nC. Polymorphism\nD. Encapsulation",
            "output": "A. Abstraction"
            },
            {
            "instruction": "Which of the following best describes an abstract class in object-oriented programming?",
            "input": "A. A class that cannot be subclassed\nB. A class that must provide an implementation for all its methods\nC. A class that cannot be instantiated and may contain abstract methods\nD. A class with no methods",
            "output": "C. A class that cannot be instantiated and may contain abstract methods"
            },
            {
            "instruction": "Which of the following is true about the relationship between abstraction and encapsulation?",
            "input": "A. Abstraction hides complexity while encapsulation hides data\nB. Abstraction and encapsulation are the same thing\nC. Abstraction is only about classes, while encapsulation is about methods\nD. Encapsulation hides complexity, while abstraction exposes data",
            "output": "A. Abstraction hides complexity while encapsulation hides data"
            },
            {
                "instruction": "Which of the following features of object-oriented programming helps in simplifying complex systems by hiding unnecessary details?",
                "input": "A. Polymorphism\nB. Inheritance\nC. Abstraction\nD. Encapsulation",
                "output": "C. Abstraction"
                },
                {
                "instruction": "What is an example of a scenario where data abstraction is used?",
                "input": "A. Designing a user interface with hidden implementation details\nB. Displaying the raw data from the database directly to the user\nC. Providing a full class implementation to every user\nD. Exposing the memory address of variables to the user",
                "output": "A. Designing a user interface with hidden implementation details"
                },
                {
                "instruction": "What is the primary goal of data abstraction in object-oriented programming?",
                "input": "A. To hide implementation details and only expose essential features\nB. To make classes more complicated\nC. To restrict method overriding\nD. To implement all classes as abstract",
                "output": "A. To hide implementation details and only expose essential features"
                },
                {
                "instruction": "Which of the following is NOT a characteristic of an abstract class?",
                "input": "A. It can have both abstract and concrete methods\nB. It cannot be instantiated\nC. It must contain only abstract methods\nD. It can be subclassed by other classes",
                "output": "C. It must contain only abstract methods"
                },
                {
                "instruction": "In Java, which keyword is used to declare an abstract class?",
                "input": "A. class\nB. abstract\nC. final\nD. static",
                "output": "B. abstract"
                },
                {
                "instruction": "Which of the following is true about data abstraction?",
                "input": "A. It hides the complexity of the implementation\nB. It only applies to methods, not variables\nC. It is not used in real-world applications\nD. It exposes all details of the object to the user",
                "output": "A. It hides the complexity of the implementation"
                },
                {
                "instruction": "In the context of data abstraction, which of the following is an example of a 'public interface'?",
                "input": "A. A class that provides all internal details of its methods\nB. A class that hides its implementation and exposes only necessary methods\nC. A class that prevents inheritance\nD. A class that does not have any methods",
                "output": "B. A class that hides its implementation and exposes only necessary methods"
                },
                {
                "instruction": "Which of the following is a correct example of how abstraction improves software design?",
                "input": "A. By making all details visible to the user\nB. By allowing users to interact with objects without knowing their implementation\nC. By preventing inheritance between classes\nD. By forcing all methods to be abstract",
                "output": "B. By allowing users to interact with objects without knowing their implementation"
                },
                {
                "instruction": "Which of the following is a key benefit of using data abstraction?",
                "input": "A. Easier to modify the internal implementation of an object without affecting other parts of the system\nB. More complex code that is harder to understand\nC. Increased dependencies between objects\nD. Prevents method overriding in subclasses",
                "output": "A. Easier to modify the internal implementation of an object without affecting other parts of the system"
                },
                {
                "instruction": "What does an abstract method in Java indicate?",
                "input": "A. It has a full implementation\nB. It cannot be overridden\nC. It has no body and must be implemented by subclasses\nD. It can only be declared in an interface",
                "output": "C. It has no body and must be implemented by subclasses"
                },
                {
                "instruction": "What is an interface in object-oriented programming?",
                "input": "A. A way to hide the internal workings of a class\nB. A class with no implementation\nC. A set of methods that a class must implement\nD. A class that can be instantiated directly",
                "output": "C. A set of methods that a class must implement"
                },
                {
                "instruction": "Which of the following allows a class to expose only the necessary functionality to the user while hiding implementation details?",
                "input": "A. Polymorphism\nB. Inheritance\nC. Abstraction\nD. Encapsulation",
                "output": "C. Abstraction"
                },
                {
                "instruction": "Which of the following is an example of abstraction in programming?",
                "input": "A. Providing the full source code of a class to the user\nB. Using a simple interface to interact with a complex system\nC. Exposing all class variables to the user\nD. Directly modifying the internal state of an object",
                "output": "B. Using a simple interface to interact with a complex system"
                },
                {
                "instruction": "Which of the following is true about abstract classes and interfaces in Java?",
                "input": "A. Both can contain abstract methods\nB. Abstract classes can be instantiated\nC. Interfaces can have concrete methods\nD. Abstract classes and interfaces are not used in Java",
                "output": "A. Both can contain abstract methods"
                },
                {
                "instruction": "In an object-oriented system, what is the purpose of hiding implementation details from the user?",
                "input": "A. To improve security by limiting access to sensitive data\nB. To provide better debugging information\nC. To make the code more complex\nD. To allow users to directly manipulate class variables",
                "output": "A. To improve security by limiting access to sensitive data"
                },
                {
                "instruction": "Which concept in object-oriented programming focuses on providing a simplified view of an object while hiding complex details?",
                "input": "A. Abstraction\nB. Inheritance\nC. Polymorphism\nD. Encapsulation",
                "output": "A. Abstraction"
                },
                {
                "instruction": "Which of the following best describes an abstract class in object-oriented programming?",
                "input": "A. A class that cannot be subclassed\nB. A class that must provide an implementation for all its methods\nC. A class that cannot be instantiated and may contain abstract methods\nD. A class with no methods",
                "output": "C. A class that cannot be instantiated and may contain abstract methods"
                },
                {
                "instruction": "Which of the following is true about the relationship between abstraction and encapsulation?",
                "input": "A. Abstraction hides complexity while encapsulation hides data\nB. Abstraction and encapsulation are the same thing\nC. Abstraction is only about classes, while encapsulation is about methods\nD. Encapsulation hides complexity, while abstraction exposes data",
                "output": "A. Abstraction hides complexity while encapsulation hides data"
                },
                {
                    "instruction": "What is the benefit of using abstraction in object-oriented programming?",
                    "input": "A. It makes the code more complex and harder to understand\nB. It allows for simpler code that hides the internal implementation\nC. It forces all methods to be public\nD. It makes classes less reusable",
                    "output": "B. It allows for simpler code that hides the internal implementation"
                    },
                    {
                    "instruction": "Which of the following is a feature of abstraction in object-oriented programming?",
                    "input": "A. Hides only method implementations\nB. Exposes unnecessary details to the user\nC. Focuses on exposing only the essential features\nD. Hides the internal state of objects from the user",
                    "output": "C. Focuses on exposing only the essential features"
                    },
                    {
                    "instruction": "What is the relationship between an abstract class and its subclasses?",
                    "input": "A. Subclasses cannot implement abstract methods\nB. Subclasses must provide implementations for abstract methods\nC. Abstract classes cannot be inherited\nD. Subclasses must be abstract as well",
                    "output": "B. Subclasses must provide implementations for abstract methods"
                    },
                    {
                    "instruction": "In object-oriented design, what does abstraction allow developers to do?",
                    "input": "A. Expose internal implementation details to the user\nB. Focus on high-level functionality while hiding lower-level implementation\nC. Prevent class inheritance\nD. Increase code complexity",
                    "output": "B. Focus on high-level functionality while hiding lower-level implementation"
                    },
                    {
                    "instruction": "Which concept in object-oriented programming provides a way to represent only essential features without exposing unnecessary details?",
                    "input": "A. Inheritance\nB. Abstraction\nC. Polymorphism\nD. Encapsulation",
                    "output": "B. Abstraction"
                    },
                    {
                    "instruction": "What is the role of an abstract method in a class?",
                    "input": "A. It provides a default implementation\nB. It must be implemented by a subclass\nC. It can only be used in an interface\nD. It cannot be overridden by subclasses",
                    "output": "B. It must be implemented by a subclass"
                    },
                    {
                    "instruction": "Which of the following best describes the purpose of a public interface in the context of data abstraction?",
                    "input": "A. To hide the complexity of implementation from the user\nB. To provide a detailed description of how the internal system works\nC. To prevent inheritance\nD. To expose all data and functionality to the user",
                    "output": "A. To hide the complexity of implementation from the user"
                    },
                    {
                    "instruction": "Which of the following is a characteristic of a well-designed abstract class?",
                    "input": "A. It contains only abstract methods\nB. It can be instantiated directly\nC. It provides a blueprint for subclasses\nD. It contains no methods at all",
                    "output": "C. It provides a blueprint for subclasses"
                    },
                    {
                    "instruction": "Which of the following is an example of an abstraction in real-world applications?",
                    "input": "A. A user interacting with a mobile app without knowing how the backend works\nB. A developer writing all the code for an application from scratch\nC. Exposing the entire database schema to the user\nD. Making all application code public",
                    "output": "A. A user interacting with a mobile app without knowing how the backend works"
                    },
                    {
                    "instruction": "How does abstraction impact the maintainability of a system?",
                    "input": "A. It makes maintenance harder by exposing unnecessary details\nB. It simplifies maintenance by allowing changes to implementation without affecting the user\nC. It prevents any modifications to the system\nD. It reduces the system's flexibility",
                    "output": "B. It simplifies maintenance by allowing changes to implementation without affecting the user"
                    },
                    {
                    "instruction": "What is the key advantage of abstracting away complex logic from the user?",
                    "input": "A. It makes the program run slower\nB. It allows users to focus on the relevant functionality\nC. It restricts the use of classes and objects\nD. It decreases code readability",
                    "output": "B. It allows users to focus on the relevant functionality"
                    },
                    {
                    "instruction": "What happens when a subclass does not implement an abstract method from a superclass?",
                    "input": "A. It results in a compilation error\nB. The program continues without errors\nC. The subclass is automatically abstract\nD. The superclass is automatically concrete",
                    "output": "A. It results in a compilation error"
                    },
                    {
                    "instruction": "Which of the following is true about an abstract class in Java?",
                    "input": "A. It can be instantiated\nB. It can only contain abstract methods\nC. It can contain both abstract and concrete methods\nD. It cannot be subclassed",
                    "output": "C. It can contain both abstract and concrete methods"
                    },
                    {
                    "instruction": "In the context of abstraction, which of the following would be an appropriate use case?",
                    "input": "A. Exposing all internal workings of a class to the user\nB. Allowing the user to interact with a system without understanding its underlying complexities\nC. Forcing every class to have public methods\nD. Making all variables in a class public",
                    "output": "B. Allowing the user to interact with a system without understanding its underlying complexities"
                    },
                    {
                    "instruction": "Which of the following describes the process of abstraction in software design?",
                    "input": "A. Exposing all implementation details and internal states to the user\nB. Hiding complex logic behind simple interfaces\nC. Preventing inheritance between classes\nD. Making all methods private",
                    "output": "B. Hiding complex logic behind simple interfaces"
                    },
                    {
                    "instruction": "What does an interface represent in object-oriented programming?",
                    "input": "A. A blueprint of methods that must be implemented by a class\nB. A class with no implementation\nC. A method with no body\nD. A way to implement data hiding",
                    "output": "A. A blueprint of methods that must be implemented by a class"
                    },
                    {
                    "instruction": "Which of the following is an example of using abstraction to simplify a user's experience?",
                    "input": "A. Providing a direct link to the database for the user\nB. Offering a simple API that interacts with a complex backend system\nC. Exposing detailed error logs to the user\nD. Requiring the user to write code to interact with the system",
                    "output": "B. Offering a simple API that interacts with a complex backend system"
                    },
                    {
                        "instruction": "What is the role of abstraction in hiding implementation details?",
                        "input": "A. It allows users to see the full implementation\nB. It makes the program more complex\nC. It hides unnecessary details and exposes only the required functionality\nD. It decreases code reusability",
                        "output": "C. It hides unnecessary details and exposes only the required functionality"
                        },
                        {
                        "instruction": "Which of the following is true about abstraction in object-oriented programming?",
                        "input": "A. It exposes all details of a class to the user\nB. It helps to reduce the complexity of the system\nC. It forces every method to be public\nD. It requires all classes to have the same implementation",
                        "output": "B. It helps to reduce the complexity of the system"
                        },
                        {
                        "instruction": "How does abstraction improve the flexibility of a system?",
                        "input": "A. By exposing all internal states to the user\nB. By allowing changes to the internal implementation without affecting the user interface\nC. By making the code more complex\nD. By making the system slower",
                        "output": "B. By allowing changes to the internal implementation without affecting the user interface"
                        },
                        {
                        "instruction": "Which of the following is an example of an abstract method in Java?",
                        "input": "A. A method with no return type\nB. A method that has no body and is meant to be implemented by subclasses\nC. A method that cannot be overridden\nD. A method that can be directly called without an object",
                        "output": "B. A method that has no body and is meant to be implemented by subclasses"
                        },
                        {
                        "instruction": "In which scenario would abstraction be most useful?",
                        "input": "A. When a program needs to expose all the details of its classes to the user\nB. When a program needs to hide unnecessary details and focus on essential features\nC. When a program needs to make all methods public\nD. When a program needs to prevent inheritance",
                        "output": "B. When a program needs to hide unnecessary details and focus on essential features"
                        },
                        {
                        "instruction": "What happens when you try to instantiate an abstract class in Java?",
                        "input": "A. It compiles successfully\nB. It results in a runtime error\nC. It causes a compilation error\nD. It creates an instance of the subclass",
                        "output": "C. It causes a compilation error"
                        },
                        {
                        "instruction": "Which of the following is a valid example of abstraction in object-oriented programming?",
                        "input": "A. Using concrete classes with specific details exposed to the user\nB. Hiding the complex implementation details of a class while exposing a simple interface\nC. Allowing users to access all internal methods directly\nD. Making all data members of a class public",
                        "output": "B. Hiding the complex implementation details of a class while exposing a simple interface"
                        },
                        {
                        "instruction": "Which of the following statements is true about an abstract class?",
                        "input": "A. It can be instantiated directly\nB. It must have only abstract methods\nC. It can contain both abstract and non-abstract methods\nD. It cannot be subclassed",
                        "output": "C. It can contain both abstract and non-abstract methods"
                        },
                        {
                        "instruction": "What is one of the main advantages of using abstraction in software development?",
                        "input": "A. It makes the software more complex and harder to understand\nB. It allows the system to handle large amounts of data more efficiently\nC. It simplifies the interaction with complex systems by focusing on high-level functionality\nD. It prevents object-oriented concepts from being used",
                        "output": "C. It simplifies the interaction with complex systems by focusing on high-level functionality"
                        },
                        {
                        "instruction": "How does abstraction help in reducing code duplication?",
                        "input": "A. By allowing methods to be implemented in every class\nB. By defining common functionality in abstract classes or interfaces, which can be shared across subclasses\nC. By forcing every method to be unique in each class\nD. By making the class non-reusable",
                        "output": "B. By defining common functionality in abstract classes or interfaces, which can be shared across subclasses"
                        },
                        {
                        "instruction": "Which of the following is a key characteristic of data abstraction?",
                        "input": "A. Making all data and methods public\nB. Hiding unnecessary implementation details from the user\nC. Allowing users to modify the internal code of the system\nD. Requiring every class to inherit from a superclass",
                        "output": "B. Hiding unnecessary implementation details from the user"
                        },
                        {
                        "instruction": "Why is abstraction important in software development?",
                        "input": "A. It allows developers to focus on the design rather than implementation details\nB. It prevents any changes to the codebase\nC. It makes the system more complex\nD. It removes the need for object-oriented programming",
                        "output": "A. It allows developers to focus on the design rather than implementation details"
                        },
                        {
                        "instruction": "Which of the following is an example of an abstraction barrier?",
                        "input": "A. Exposing the full database schema to the user\nB. Providing a high-level interface to interact with a complex system\nC. Giving the user direct access to the codebase\nD. Making all variables public",
                        "output": "B. Providing a high-level interface to interact with a complex system"
                        },
                        {
                        "instruction": "How can abstraction help in reducing the complexity of a software system?",
                        "input": "A. By exposing all implementation details to the user\nB. By hiding unnecessary details and focusing on the essential features\nC. By requiring users to understand the codebase\nD. By making every method public",
                        "output": "B. By hiding unnecessary details and focusing on the essential features"
                        },
                        {
                        "instruction": "What is the purpose of the `abstract` keyword in Java?",
                        "input": "A. To define concrete methods\nB. To declare a class that cannot be instantiated\nC. To indicate that a method must be implemented by subclasses\nD. To indicate that a class is final",
                        "output": "C. To indicate that a method must be implemented by subclasses"
                        },
                        {
                        "instruction": "What happens when an abstract class contains an abstract method but a subclass does not implement that method?",
                        "input": "A. The subclass is automatically abstract\nB. The program will compile successfully\nC. A compilation error will occur\nD. The abstract method is ignored",
                        "output": "C. A compilation error will occur"
                        },
                        {
                        "instruction": "Which of the following best describes the goal of abstraction in software design?",
                        "input": "A. To provide users with access to all system details\nB. To hide unnecessary details and provide a clear, simplified interface\nC. To increase the complexity of the codebase\nD. To make the software harder to understand",
                        "output": "B. To hide unnecessary details and provide a clear, simplified interface"
                        },
                        {
                        "instruction": "What does the term 'abstraction layer' refer to in software systems?",
                        "input": "A. A layer that exposes all internal details to the user\nB. A level in the system that hides complex details and focuses on the essential functionality\nC. A specific method used to implement data structures\nD. A part of the system that cannot be modified",
                        "output": "B. A level in the system that hides complex details and focuses on the essential functionality"
                        },
                        {
                            "instruction": "What is the main benefit of using abstraction in object-oriented programming?",
                            "input": "A. To reduce the use of classes\nB. To make the system more complex\nC. To simplify complex systems and focus on relevant details\nD. To allow direct access to all methods and attributes",
                            "output": "C. To simplify complex systems and focus on relevant details"
                            },
                            {
                            "instruction": "Which of the following is a key characteristic of an abstract class?",
                            "input": "A. It must have only abstract methods\nB. It cannot be subclassed\nC. It cannot contain any methods\nD. It may contain both abstract and concrete methods",
                            "output": "D. It may contain both abstract and concrete methods"
                            },
                            {
                            "instruction": "What is the purpose of an interface in Java with respect to abstraction?",
                            "input": "A. To define the internal details of a class\nB. To provide a blueprint for classes without implementation details\nC. To store the state of an object\nD. To hide the entire class implementation",
                            "output": "B. To provide a blueprint for classes without implementation details"
                            },
                            {
                            "instruction": "Which of the following is an abstraction mechanism in Java?",
                            "input": "A. Using only private fields in a class\nB. Using abstract methods and interfaces\nC. Using concrete methods only\nD. Using final classes",
                            "output": "B. Using abstract methods and interfaces"
                            },
                            {
                            "instruction": "Which of the following is an example of data abstraction in a real-world system?",
                            "input": "A. A car's engine is fully visible to the driver\nB. The driver interacts with the cars control system without needing to understand the engine's internal working\nC. A person manually operates the engine parts of a car\nD. The cars engine is not essential to the operation of the vehicle",
                            "output": "B. The driver interacts with the cars control system without needing to understand the engine's internal working"
                            },
                            {
                            "instruction": "What is the result of using data abstraction in large-scale software development?",
                            "input": "A. The software becomes more difficult to modify\nB. It reduces the system's performance\nC. It makes the system easier to maintain and extend\nD. It requires all data to be public",
                            "output": "C. It makes the system easier to maintain and extend"
                            },
                            {
                            "instruction": "What is the relationship between abstraction and encapsulation in object-oriented programming?",
                            "input": "A. Abstraction hides the internal workings, while encapsulation hides the internal data\nB. Abstraction and encapsulation are completely unrelated\nC. Encapsulation hides the internal workings, while abstraction hides the internal data\nD. Encapsulation exposes all the implementation details, while abstraction hides them",
                            "output": "A. Abstraction hides the internal workings, while encapsulation hides the internal data"
                            },
                            {
                            "instruction": "What type of class cannot be instantiated directly in Java?",
                            "input": "A. Concrete class\nB. Abstract class\nC. Final class\nD. Static class",
                            "output": "B. Abstract class"
                            },
                            {
                            "instruction": "Which of the following statements is true regarding abstract classes and interfaces in Java?",
                            "input": "A. Abstract classes can have both abstract and concrete methods, while interfaces can only have abstract methods\nB. Abstract classes and interfaces are functionally identical\nC. Both abstract classes and interfaces can have only abstract methods\nD. Abstract classes cannot be subclassed, while interfaces can",
                            "output": "A. Abstract classes can have both abstract and concrete methods, while interfaces can only have abstract methods"
                            },
                            {
                            "instruction": "What does an abstract class in Java require in its subclasses?",
                            "input": "A. To implement all its abstract methods\nB. To define all variables\nC. To provide a concrete implementation of its methods\nD. To declare it as abstract",
                            "output": "A. To implement all its abstract methods"
                            },
                            {
                            "instruction": "What is the effect of abstraction in reducing the coupling between system components?",
                            "input": "A. It makes the components more dependent on each other\nB. It increases the interaction between components\nC. It decreases the dependency between components\nD. It prevents any component from interacting with others",
                            "output": "C. It decreases the dependency between components"
                            },
                            {
                            "instruction": "Which of the following best describes an abstract method in an abstract class?",
                            "input": "A. A method with a body that is common to all subclasses\nB. A method with no implementation that must be implemented by subclasses\nC. A method that is private and cannot be accessed by subclasses\nD. A method that can be called without instantiating the class",
                            "output": "B. A method with no implementation that must be implemented by subclasses"
                            },
                            {
                            "instruction": "Which of the following is a characteristic of abstraction in a software system?",
                            "input": "A. The user must understand the internal working of the system\nB. The system hides its complexity and provides a simple interface\nC. The system provides direct access to all its components\nD. The system is less modular",
                            "output": "B. The system hides its complexity and provides a simple interface"
                            },
                            {
                            "instruction": "Which concept in object-oriented programming allows the user to interact with objects at a high level without needing to understand the internal details?",
                            "input": "A. Polymorphism\nB. Inheritance\nC. Abstraction\nD. Encapsulation",
                            "output": "C. Abstraction"
                            },
                            {
                            "instruction": "How does abstraction affect the design of software components?",
                            "input": "A. It forces every component to be identical\nB. It reduces the ability to modify components\nC. It allows software components to evolve independently\nD. It makes the system more complex",
                            "output": "C. It allows software components to evolve independently"
                            },
                            {
                            "instruction": "Which of the following best describes a user interface (UI) that uses abstraction?",
                            "input": "A. The user needs to understand all backend code to interact with the system\nB. The user can interact with the system without worrying about the details of its implementation\nC. The user must provide input in a specific code format\nD. The user needs access to all the methods and variables of the program",
                            "output": "B. The user can interact with the system without worrying about the details of its implementation"
                            },
                            {
                            "instruction": "Which of the following is a benefit of using abstraction in complex software systems?",
                            "input": "A. It makes the system harder to understand\nB. It hides complexity and exposes only necessary parts\nC. It reduces modularity\nD. It increases the dependencies between components",
                            "output": "B. It hides complexity and exposes only necessary parts"
                            },
                            {
                            "instruction": "Which of the following is true about abstraction in the context of software engineering?",
                            "input": "A. Abstraction makes it harder to work with complex systems\nB. Abstraction simplifies complex systems by focusing on relevant functionality\nC. Abstraction removes the need for classes\nD. Abstraction requires developers to work with detailed implementations",
                            "output": "B. Abstraction simplifies complex systems by focusing on relevant functionality"
                            },
                            {
                                "instruction": "What does abstraction allow developers to do in object-oriented programming?",
                                "input": "A. Create systems without any classes\nB. Focus on relevant features and hide irrelevant details\nC. Remove the need for inheritance\nD. Reduce the use of interfaces",
                                "output": "B. Focus on relevant features and hide irrelevant details"
                                },
                                {
                                "instruction": "Which keyword is used to define an abstract class in Java?",
                                "input": "A. interface\nB. abstract\nC. static\nD. final",
                                "output": "B. abstract"
                                },
                                {
                                "instruction": "What is the effect of data abstraction on a software system's maintainability?",
                                "input": "A. It makes the system harder to modify\nB. It simplifies the system by hiding implementation details\nC. It leads to more complex code\nD. It reduces code modularity",
                                "output": "B. It simplifies the system by hiding implementation details"
                                },
                                {
                                "instruction": "Which of the following is true about abstract methods in Java?",
                                "input": "A. Abstract methods must be defined in the abstract class\nB. Abstract methods cannot be overridden\nC. Abstract methods must have a body\nD. Abstract methods do not exist in abstract classes",
                                "output": "A. Abstract methods must be defined in the abstract class"
                                },
                                {
                                "instruction": "How does abstraction help in reducing the complexity of a software system?",
                                "input": "A. By hiding unnecessary details and exposing only essential functionalities\nB. By revealing all the implementation details\nC. By adding more functionality to the system\nD. By increasing the interaction between components",
                                "output": "A. By hiding unnecessary details and exposing only essential functionalities"
                                },
                                {
                                "instruction": "Which of the following best represents abstraction in programming?",
                                "input": "A. Using private methods and variables\nB. Hiding the internal workings of a system and providing a simple interface\nC. Using only public methods\nD. Using inheritance to extend functionality",
                                "output": "B. Hiding the internal workings of a system and providing a simple interface"
                                },
                                {
                                "instruction": "Which of the following is an abstraction principle in object-oriented programming?",
                                "input": "A. Overloading methods to handle different data types\nB. Hiding unnecessary details and only showing relevant information\nC. Using global variables in the system\nD. Accessing all methods and data directly",
                                "output": "B. Hiding unnecessary details and only showing relevant information"
                                },
                                {
                                "instruction": "What role does abstraction play in designing reusable components?",
                                "input": "A. It makes the components difficult to reuse\nB. It hides the implementation details, allowing for easier reuse\nC. It eliminates the need for modularity\nD. It forces the use of a specific implementation",
                                "output": "B. It hides the implementation details, allowing for easier reuse"
                                },
                                {
                                "instruction": "In which of the following cases would abstraction be most useful?",
                                "input": "A. When all internal details of a class need to be visible to the user\nB. When the class should only expose relevant functionality while hiding the complex details\nC. When no classes should be used in the system\nD. When there is no need for a class to interact with other classes",
                                "output": "B. When the class should only expose relevant functionality while hiding the complex details"
                                },
                                {
                                "instruction": "How does abstraction contribute to the modularity of software systems?",
                                "input": "A. By making all components of the system dependent on each other\nB. By simplifying the interaction between components and hiding unnecessary details\nC. By making the components tightly coupled\nD. By removing the need for classes",
                                "output": "B. By simplifying the interaction between components and hiding unnecessary details"
                                },
                                {
                                "instruction": "What is the primary purpose of data abstraction in object-oriented programming?",
                                "input": "A. To provide detailed access to all data members\nB. To protect sensitive data from unauthorized access\nC. To expose only necessary details and hide implementation complexity\nD. To make the program more difficult to understand",
                                "output": "C. To expose only necessary details and hide implementation complexity"
                                },
                                {
                                "instruction": "What does an interface in Java define in terms of abstraction?",
                                "input": "A. The implementation details of methods\nB. The internal workings of a class\nC. A contract that must be fulfilled by the implementing class\nD. The private variables of a class",
                                "output": "C. A contract that must be fulfilled by the implementing class"
                                },
                                {
                                "instruction": "What is a potential disadvantage of overusing abstraction in programming?",
                                "input": "A. It leads to fewer reusable components\nB. It can make the system harder to understand if taken too far\nC. It decreases modularity\nD. It makes code more prone to errors",
                                "output": "B. It can make the system harder to understand if taken too far"
                                },
                                {
                                "instruction": "What is an example of abstraction in the context of a car?",
                                "input": "A. The driver must understand the entire engine mechanism\nB. The car dashboard displays essential information like speed and fuel, without showing engine details\nC. The driver manually controls the engine's components\nD. The cars engine is fully exposed to the driver",
                                "output": "B. The car dashboard displays essential information like speed and fuel, without showing engine details"
                                },
                                {
                                "instruction": "Which of the following best describes the relationship between abstraction and implementation?",
                                "input": "A. Abstraction focuses on hiding implementation details, while implementation provides the actual behavior\nB. Abstraction and implementation are the same\nC. Abstraction exposes all implementation details\nD. Abstraction provides the implementation",
                                "output": "A. Abstraction focuses on hiding implementation details, while implementation provides the actual behavior"
                                },
                                {
                                "instruction": "What is the main difference between an abstract class and an interface in Java?",
                                "input": "A. An abstract class can have methods with implementations, while an interface cannot\nB. Both abstract classes and interfaces can have only abstract methods\nC. An abstract class cannot be extended, while an interface can be\nD. An abstract class does not have any constructors, while an interface does",
                                "output": "A. An abstract class can have methods with implementations, while an interface cannot"
                                },
                                {
                                "instruction": "Which of the following concepts allows users to interact with a system without knowing its internal details?",
                                "input": "A. Polymorphism\nB. Abstraction\nC. Inheritance\nD. Encapsulation",
                                "output": "B. Abstraction"
                                },
                                {
                                "instruction": "How does abstraction affect the complexity of system components?",
                                "input": "A. It increases the complexity by exposing unnecessary details\nB. It reduces the complexity by focusing on essential features\nC. It eliminates the need for system components\nD. It forces all system components to have the same functionality",
                                "output": "B. It reduces the complexity by focusing on essential features"
                                },
                                {
                                "instruction": "Which of the following is an example of an abstract class in Java?",
                                "input": "A. A class with no methods\nB. A class that only contains static methods\nC. A class that contains both abstract and concrete methods\nD. A class that cannot be subclassed",
                                "output": "C. A class that contains both abstract and concrete methods"
                                },
                                {
                                    "instruction": "What is the purpose of using interfaces in data abstraction?",
                                    "input": "A. To allow classes to have multiple inheritances\nB. To expose the internal details of classes\nC. To define a contract that implementing classes must fulfill\nD. To make methods private and inaccessible",
                                    "output": "C. To define a contract that implementing classes must fulfill"
                                    },
                                    {
                                    "instruction": "Which of the following is true about abstract classes in Java?",
                                    "input": "A. Abstract classes cannot have any method implementations\nB. Abstract classes cannot be instantiated directly\nC. Abstract classes must be final\nD. Abstract classes cannot be extended",
                                    "output": "B. Abstract classes cannot be instantiated directly"
                                    },
                                    {
                                    "instruction": "Which of the following is an example of data abstraction in real life?",
                                    "input": "A. Knowing how a computer's CPU works when using a laptop\nB. Using a remote control to operate a TV without knowing the internal workings\nC. Understanding how a car engine operates when driving\nD. Reading the full source code of an application",
                                    "output": "B. Using a remote control to operate a TV without knowing the internal workings"
                                    },
                                    {
                                    "instruction": "How does abstraction impact code readability?",
                                    "input": "A. It makes the code more complex\nB. It simplifies the code by hiding unnecessary implementation details\nC. It has no effect on code readability\nD. It makes the code harder to maintain",
                                    "output": "B. It simplifies the code by hiding unnecessary implementation details"
                                    },
                                    {
                                    "instruction": "What is the role of the 'abstract' keyword in Java?",
                                    "input": "A. It marks a class as fully implemented\nB. It allows a class to be instantiated directly\nC. It marks a class or method as incomplete, needing subclass implementation\nD. It defines the body of a method",
                                    "output": "C. It marks a class or method as incomplete, needing subclass implementation"
                                    },
                                    {
                                    "instruction": "Which of the following is a benefit of using abstraction in software design?",
                                    "input": "A. It increases the coupling between different parts of a program\nB. It reduces complexity by hiding unnecessary details\nC. It makes all components visible and accessible\nD. It eliminates the need for interfaces",
                                    "output": "B. It reduces complexity by hiding unnecessary details"
                                    },
                                    {
                                    "instruction": "What type of methods can an abstract class contain?",
                                    "input": "A. Only abstract methods\nB. Only concrete methods\nC. Both abstract and concrete methods\nD. Only static methods",
                                    "output": "C. Both abstract and concrete methods"
                                    },
                                    {
                                    "instruction": "What is the key difference between abstraction and encapsulation?",
                                    "input": "A. Abstraction focuses on hiding the complexity, while encapsulation focuses on data hiding\nB. Abstraction hides the data, while encapsulation reveals it\nC. Abstraction uses private access, while encapsulation uses public access\nD. Abstraction is only related to objects, while encapsulation is not",
                                    "output": "A. Abstraction focuses on hiding the complexity, while encapsulation focuses on data hiding"
                                    },
                                    {
                                    "instruction": "What happens if a subclass does not implement all the abstract methods from an abstract class in Java?",
                                    "input": "A. The subclass will be able to be instantiated\nB. The subclass will become an abstract class itself\nC. The code will compile, but throw an exception during runtime\nD. The program will work, but the subclass will not have all required behavior",
                                    "output": "B. The subclass will become an abstract class itself"
                                    },
                                    {
                                    "instruction": "How is data abstraction implemented in object-oriented programming?",
                                    "input": "A. By creating abstract methods and hiding implementation details in base classes\nB. By directly accessing all methods and data members in a class\nC. By using global variables for data access\nD. By defining all methods as private",
                                    "output": "A. By creating abstract methods and hiding implementation details in base classes"
                                    },
                                    {
                                    "instruction": "Which of the following is an abstraction technique that hides implementation details in programming?",
                                    "input": "A. Using private methods and fields\nB. Using inheritance to expose all class behaviors\nC. Using abstract methods to allow multiple implementations\nD. Using default methods in interfaces",
                                    "output": "C. Using abstract methods to allow multiple implementations"
                                    },
                                    {
                                    "instruction": "Which feature of abstraction allows developers to focus on high-level logic?",
                                    "input": "A. Hiding all data members\nB. Hiding unnecessary implementation details and showing only the relevant aspects\nC. Using complex algorithms\nD. Exposing all internal methods",
                                    "output": "B. Hiding unnecessary implementation details and showing only the relevant aspects"
                                    },
                                    {
                                    "instruction": "In object-oriented programming, what role does an abstract class play in data abstraction?",
                                    "input": "A. It defines a common interface that all subclasses must implement\nB. It can be instantiated to create objects\nC. It is a fully implemented class that hides no details\nD. It prevents inheritance from other classes",
                                    "output": "A. It defines a common interface that all subclasses must implement"
                                    },
                                    {
                                    "instruction": "Which of the following is an advantage of using abstraction in software systems?",
                                    "input": "A. It makes software harder to understand and maintain\nB. It hides implementation details and focuses on high-level functionality\nC. It encourages low-level programming\nD. It eliminates the need for interfaces",
                                    "output": "B. It hides implementation details and focuses on high-level functionality"
                                    },
                                    {
                                    "instruction": "When using abstraction in programming, what should be the main focus when designing systems?",
                                    "input": "A. Minimizing the number of abstract classes\nB. Hiding all implementation details and exposing only relevant functionality\nC. Making all methods abstract\nD. Using as many classes as possible",
                                    "output": "B. Hiding all implementation details and exposing only relevant functionality"
                                    },
                                    {
                                    "instruction": "In Java, if a class has at least one abstract method, what must the class be declared as?",
                                    "input": "A. Public class\nB. Abstract class\nC. Static class\nD. Final class",
                                    "output": "B. Abstract class"
                                    },
                                    {
                                    "instruction": "What is the main reason why programmers use abstraction in object-oriented design?",
                                    "input": "A. To allow objects to interact with each other without knowing the details of their implementation\nB. To increase the size of the code\nC. To make all methods public\nD. To reduce the reusability of code",
                                    "output": "A. To allow objects to interact with each other without knowing the details of their implementation"
                                    },
                                    {
                                    "instruction": "Which of the following is NOT an advantage of using abstraction in programming?",
                                    "input": "A. Makes the system easier to maintain\nB. Allows hiding of complex implementation details\nC. Enables code to be reused in different contexts\nD. Forces developers to write redundant code",
                                    "output": "D. Forces developers to write redundant code"
                                    },
                                    {
                                        "instruction": "Which of the following can be used to achieve abstraction in Java?",
                                        "input": "A. Abstract classes\nB. Concrete classes\nC. Static methods\nD. Final methods",
                                        "output": "A. Abstract classes"
                                        },
                                        {
                                        "instruction": "Which of the following statements is true regarding abstract classes?",
                                        "input": "A. An abstract class cannot contain concrete methods\nB. An abstract class must have at least one abstract method\nC. Abstract classes cannot be extended\nD. Abstract classes can be instantiated directly",
                                        "output": "B. An abstract class must have at least one abstract method"
                                        },
                                        {
                                        "instruction": "Which is an example of data abstraction in a banking system?",
                                        "input": "A. The bank teller's actions\nB. The account holder's ability to deposit money without knowing the bank's internal workings\nC. The customer data being stored in a database\nD. The design of the bank's database schema",
                                        "output": "B. The account holder's ability to deposit money without knowing the bank's internal workings"
                                        },
                                        {
                                        "instruction": "What is the benefit of data abstraction in a software system?",
                                        "input": "A. It hides the complexity of the system, making it easier for the developer to interact with the system\nB. It makes the code more complex\nC. It exposes the internal workings to the developer\nD. It eliminates the need for classes",
                                        "output": "A. It hides the complexity of the system, making it easier for the developer to interact with the system"
                                        },
                                        {
                                        "instruction": "What is the difference between abstraction and encapsulation?",
                                        "input": "A. Abstraction is about hiding data, while encapsulation hides the complexity of functions\nB. Abstraction hides the implementation details, while encapsulation hides the data\nC. Abstraction and encapsulation are the same\nD. Encapsulation exposes implementation details, while abstraction hides them",
                                        "output": "B. Abstraction hides the implementation details, while encapsulation hides the data"
                                        },
                                        {
                                        "instruction": "Which of the following is an abstraction technique used in object-oriented programming?",
                                        "input": "A. Overriding methods\nB. Inheritance\nC. Using abstract classes and interfaces\nD. Polymorphism",
                                        "output": "C. Using abstract classes and interfaces"
                                        },
                                        {
                                        "instruction": "What is the effect of abstraction in object-oriented programming?",
                                        "input": "A. It reduces the need for functions\nB. It hides unnecessary implementation details and exposes only relevant aspects\nC. It makes every class public\nD. It reduces the number of classes in the program",
                                        "output": "B. It hides unnecessary implementation details and exposes only relevant aspects"
                                        },
                                        {
                                        "instruction": "Why is abstraction important in large software projects?",
                                        "input": "A. It allows teams to work on different parts of the system independently\nB. It makes all components visible and accessible to all developers\nC. It requires more time for debugging\nD. It forces developers to understand the full system at once",
                                        "output": "A. It allows teams to work on different parts of the system independently"
                                        },
                                        {
                                        "instruction": "Which of the following is an abstraction technique that hides complexity?",
                                        "input": "A. Inheritance\nB. Polymorphism\nC. Use of abstract methods\nD. Overloading methods",
                                        "output": "C. Use of abstract methods"
                                        },
                                        {
                                        "instruction": "What is the role of an interface in data abstraction?",
                                        "input": "A. It allows classes to be instantiated directly\nB. It provides a blueprint for classes to implement\nC. It hides all data members\nD. It defines the internal implementation of methods",
                                        "output": "B. It provides a blueprint for classes to implement"
                                        },
                                        {
                                        "instruction": "What does an abstract class typically contain?",
                                        "input": "A. Only abstract methods\nB. Only concrete methods\nC. A mix of abstract and concrete methods\nD. Only static methods",
                                        "output": "C. A mix of abstract and concrete methods"
                                        },
                                        {
                                        "instruction": "What happens if a subclass does not provide implementations for all abstract methods in Java?",
                                        "input": "A. The code will compile, but the subclass will not behave as expected\nB. The program will work, but the subclass will not have all required functionality\nC. The subclass will automatically implement the methods\nD. The subclass must also be declared as abstract",
                                        "output": "D. The subclass must also be declared as abstract"
                                        },
                                        {
                                        "instruction": "What is a benefit of using interfaces for abstraction in programming?",
                                        "input": "A. It allows methods to be implemented in the interface itself\nB. It defines a common contract that multiple classes can follow\nC. It allows classes to be instantiated directly\nD. It reduces the need for classes",
                                        "output": "B. It defines a common contract that multiple classes can follow"
                                        },
                                        {
                                        "instruction": "Which of the following is an abstraction in a banking system?",
                                        "input": "A. The banks internal processing system\nB. The user interface for withdrawing funds\nC. The algorithm for calculating interest rates\nD. The process of storing data in the database",
                                        "output": "B. The user interface for withdrawing funds"
                                        },
                                        {
                                        "instruction": "In Java, what is the purpose of an abstract method?",
                                        "input": "A. To define the implementation of a method\nB. To allow a method to be called directly\nC. To provide a method signature without implementation\nD. To make methods private",
                                        "output": "C. To provide a method signature without implementation"
                                        },
                                        {
                                        "instruction": "Which statement about abstraction in object-oriented programming is correct?",
                                        "input": "A. Abstraction is about hiding the implementation details and showing only essential features\nB. Abstraction is about hiding data members\nC. Abstraction exposes all internal workings of the class\nD. Abstraction eliminates the need for methods",
                                        "output": "A. Abstraction is about hiding the implementation details and showing only essential features"
                                        },
                                        {
                                        "instruction": "What is the primary goal of data abstraction?",
                                        "input": "A. To reduce the number of classes\nB. To hide unnecessary implementation details from the user\nC. To make the code more difficult to understand\nD. To expose all methods and properties of a class",
                                        "output": "B. To hide unnecessary implementation details from the user"
                                        },
                                        {
                                        "instruction": "What does it mean if a method is marked as 'abstract' in a class?",
                                        "input": "A. The method has no implementation and must be defined in subclasses\nB. The method cannot be overridden\nC. The method is private and cannot be accessed outside the class\nD. The method has a default implementation",
                                        "output": "A. The method has no implementation and must be defined in subclasses"
                                        },
                                        {
                                            "instruction": "What is the purpose of abstraction in object-oriented programming?",
                                            "input": "A. To hide implementation details and show only the necessary functionality\nB. To reduce the number of classes in a program\nC. To make classes reusable\nD. To eliminate the need for methods",
                                            "output": "A. To hide implementation details and show only the necessary functionality"
                                            },
                                            {
                                            "instruction": "Which concept is used to define the abstract behavior of objects in a class?",
                                            "input": "A. Interfaces\nB. Concrete classes\nC. Method overloading\nD. Data encapsulation",
                                            "output": "A. Interfaces"
                                            },
                                            {
                                            "instruction": "Which of the following is an example of a data abstraction technique?",
                                            "input": "A. Writing detailed class definitions\nB. Providing public methods to access private fields\nC. Using inheritance to extend functionality\nD. Reducing the number of methods in a class",
                                            "output": "B. Providing public methods to access private fields"
                                            },
                                            {
                                            "instruction": "What does the term 'abstraction' refer to in object-oriented programming?",
                                            "input": "A. A class that cannot be instantiated\nB. A class that hides details and only exposes essential features\nC. A class that is always public\nD. A class that provides concrete implementations only",
                                            "output": "B. A class that hides details and only exposes essential features"
                                            },
                                            {
                                            "instruction": "What is one of the key benefits of abstraction in software design?",
                                            "input": "A. It makes the system more complex\nB. It simplifies the system by hiding unnecessary details\nC. It exposes the internal implementation of the system\nD. It eliminates the need for programming languages",
                                            "output": "B. It simplifies the system by hiding unnecessary details"
                                            },
                                            {
                                            "instruction": "Which of the following is a way to implement abstraction in Java?",
                                            "input": "A. By using abstract classes and methods\nB. By using only private methods\nC. By using inheritance alone\nD. By making all methods static",
                                            "output": "A. By using abstract classes and methods"
                                            },
                                            {
                                            "instruction": "What is the effect of abstraction on class design?",
                                            "input": "A. It requires developers to expose all class methods\nB. It allows developers to focus only on relevant details and ignore unnecessary complexity\nC. It makes the class definition more difficult to understand\nD. It eliminates the need for inheritance",
                                            "output": "B. It allows developers to focus only on relevant details and ignore unnecessary complexity"
                                            },
                                            {
                                            "instruction": "What is the role of an abstract class in data abstraction?",
                                            "input": "A. It allows direct instantiation of objects\nB. It provides a template for subclasses to implement specific behaviors\nC. It can only have static methods\nD. It does not allow any form of inheritance",
                                            "output": "B. It provides a template for subclasses to implement specific behaviors"
                                            },
                                            {
                                            "instruction": "What does an abstract class in Java contain?",
                                            "input": "A. Only abstract methods\nB. Only concrete methods\nC. A combination of abstract and concrete methods\nD. Only static methods and variables",
                                            "output": "C. A combination of abstract and concrete methods"
                                            },
                                            {
                                            "instruction": "What is the outcome if a class extends an abstract class and does not implement all of its abstract methods?",
                                            "input": "A. The program will run without any errors\nB. The class will automatically inherit the implementations of the abstract methods\nC. The class must be declared as abstract\nD. The class will be forced to implement the methods immediately",
                                            "output": "C. The class must be declared as abstract"
                                            },
                                            {
                                            "instruction": "Which of the following is NOT true about abstraction in Java?",
                                            "input": "A. Abstract classes cannot be instantiated\nB. Abstract methods must have a body\nC. Abstraction allows hiding unnecessary details\nD. Interfaces are used to achieve abstraction",
                                            "output": "B. Abstract methods must have a body"
                                            },
                                            {
                                            "instruction": "What is the relationship between abstraction and encapsulation?",
                                            "input": "A. They are the same concept\nB. Abstraction hides complexity, while encapsulation hides data\nC. Abstraction hides data, while encapsulation hides complexity\nD. Encapsulation is a form of abstraction",
                                            "output": "B. Abstraction hides complexity, while encapsulation hides data"
                                            },
                                            {
                                            "instruction": "Which concept is most closely related to abstraction in object-oriented programming?",
                                            "input": "A. Data hiding\nB. Multiple inheritance\nC. Method overloading\nD. Function pointers",
                                            "output": "A. Data hiding"
                                            },
                                            {
                                            "instruction": "Which of the following is an example of abstraction in a mobile application?",
                                            "input": "A. The app's ability to fetch data from the server without showing the underlying network protocols\nB. The app's source code being open to the public\nC. The ability to modify the app's source code at runtime\nD. The app's user interface displaying all the internal workings of the app",
                                            "output": "A. The app's ability to fetch data from the server without showing the underlying network protocols"
                                            },
                                            {
                                            "instruction": "What is the purpose of using abstract methods in Java?",
                                            "input": "A. To force subclasses to implement specific methods\nB. To allow methods to be defined with a body\nC. To allow methods to be private\nD. To eliminate the need for method overriding",
                                            "output": "A. To force subclasses to implement specific methods"
                                            },
                                            {
                                            "instruction": "What does it mean when an interface is used in data abstraction?",
                                            "input": "A. It defines the internal implementation of methods\nB. It forces a class to implement specific methods without providing implementation\nC. It allows direct instantiation of methods\nD. It eliminates the need for inheritance",
                                            "output": "B. It forces a class to implement specific methods without providing implementation"
                                            },
                                            {
                                            "instruction": "Which of the following is an abstraction technique that hides data while allowing functionality?",
                                            "input": "A. Public methods accessing private fields\nB. Making all methods static\nC. Writing all code in a single class\nD. Using global variables",
                                            "output": "A. Public methods accessing private fields"
                                            },
                                            {
                                            "instruction": "What does abstraction in object-oriented programming enable developers to do?",
                                            "input": "A. Write more complex code\nB. Focus on high-level functionality and avoid low-level details\nC. Eliminate the need for methods\nD. Directly manipulate data structures",
                                            "output": "B. Focus on high-level functionality and avoid low-level details"
                                            },
                                            {
                                                "instruction": "What is the primary benefit of using data abstraction in object-oriented programming?",
                                                "input": "A. It simplifies code by hiding unnecessary details\nB. It increases the complexity of the system\nC. It eliminates the need for methods\nD. It exposes all internal details of the program",
                                                "output": "A. It simplifies code by hiding unnecessary details"
                                                },
                                                {
                                                "instruction": "Which of the following keywords is used to declare an abstract class in Java?",
                                                "input": "A. abstract\nB. interface\nC. final\nD. static",
                                                "output": "A. abstract"
                                                },
                                                {
                                                "instruction": "Which of the following statements is true about abstract classes?",
                                                "input": "A. They can only contain abstract methods\nB. They cannot be instantiated\nC. They must contain at least one abstract method\nD. They can only contain static methods",
                                                "output": "B. They cannot be instantiated"
                                                },
                                                {
                                                "instruction": "Which concept in object-oriented programming is most closely associated with data abstraction?",
                                                "input": "A. Inheritance\nB. Encapsulation\nC. Polymorphism\nD. Overloading",
                                                "output": "B. Encapsulation"
                                                },
                                                {
                                                "instruction": "Which of the following is an abstraction technique used in object-oriented programming?",
                                                "input": "A. Inheritance\nB. Interfaces\nC. Method overloading\nD. Data encapsulation",
                                                "output": "B. Interfaces"
                                                },
                                                {
                                                "instruction": "What happens if a class does not implement all abstract methods of an abstract class?",
                                                "input": "A. It is automatically instantiated\nB. The class must be declared abstract\nC. The program will compile successfully\nD. It will throw an exception at runtime",
                                                "output": "B. The class must be declared abstract"
                                                },
                                                {
                                                "instruction": "Which of the following is true about an interface in Java?",
                                                "input": "A. An interface can contain method implementations\nB. An interface can be instantiated\nC. An interface cannot contain any method implementations\nD. An interface is a type of concrete class",
                                                "output": "C. An interface cannot contain any method implementations"
                                                },
                                                {
                                                "instruction": "How does abstraction in object-oriented programming help in code maintenance?",
                                                "input": "A. By making all methods public\nB. By separating the implementation from the interface\nC. By hiding all classes\nD. By reducing the number of classes in the system",
                                                "output": "B. By separating the implementation from the interface"
                                                },
                                                {
                                                "instruction": "What is the main difference between an abstract class and an interface in Java?",
                                                "input": "A. An abstract class can contain only abstract methods, while an interface can contain both abstract and concrete methods\nB. An interface can contain only abstract methods, while an abstract class can contain both abstract and concrete methods\nC. An abstract class cannot be extended, while an interface can be implemented\nD. An interface can be instantiated, while an abstract class cannot",
                                                "output": "B. An interface can contain only abstract methods, while an abstract class can contain both abstract and concrete methods"
                                                },
                                                {
                                                "instruction": "Which of the following is true about an abstract method in Java?",
                                                "input": "A. It does not have a body\nB. It must be static\nC. It cannot be overridden\nD. It must be public",
                                                "output": "A. It does not have a body"
                                                },
                                                {
                                                "instruction": "In Java, how can data abstraction be achieved in a class?",
                                                "input": "A. By using private fields and providing public getter and setter methods\nB. By using public methods only\nC. By making all methods static\nD. By writing all methods inside a single class",
                                                "output": "A. By using private fields and providing public getter and setter methods"
                                                },
                                                {
                                                "instruction": "Which of the following is a benefit of using interfaces in Java?",
                                                "input": "A. They allow multiple inheritance\nB. They allow methods to have a body\nC. They eliminate the need for classes\nD. They can store data fields",
                                                "output": "A. They allow multiple inheritance"
                                                },
                                                {
                                                "instruction": "Which of the following is a characteristic of abstraction in object-oriented programming?",
                                                "input": "A. It exposes only the necessary details to the user\nB. It requires all methods to be public\nC. It provides all the internal implementation details\nD. It prevents the use of inheritance",
                                                "output": "A. It exposes only the necessary details to the user"
                                                },
                                                {
                                                "instruction": "Which of the following techniques helps achieve data abstraction?",
                                                "input": "A. Using private fields and methods\nB. Using constructors\nC. Using static methods\nD. Using final methods",
                                                "output": "A. Using private fields and methods"
                                                },
                                                {
                                                "instruction": "Which of the following is NOT a benefit of abstraction?",
                                                "input": "A. Reduces complexity by hiding unnecessary details\nB. Allows implementation details to change without affecting other parts of the program\nC. Makes it easier to create reusable code\nD. Forces all methods to be static",
                                                "output": "D. Forces all methods to be static"
                                                },
                                                {
                                                "instruction": "Which keyword is used to declare an interface in Java?",
                                                "input": "A. abstract\nB. interface\nC. static\nD. final",
                                                "output": "B. interface"
                                                },
                                                {
                                                "instruction": "What does the term 'information hiding' refer to in the context of data abstraction?",
                                                "input": "A. Hiding implementation details while exposing essential functionality\nB. Hiding all classes from other classes\nC. Hiding data fields from being accessed by other methods\nD. Hiding method signatures from the public API",
                                                "output": "A. Hiding implementation details while exposing essential functionality"
                                                },
                                                {
                                                "instruction": "What is the purpose of using abstract methods in a class?",
                                                "input": "A. To provide a complete implementation\nB. To allow subclasses to implement their own versions\nC. To define the internal workings of the method\nD. To make methods static",
                                                "output": "B. To allow subclasses to implement their own versions"
                                                },
                                                {
                                                "instruction": "What is the primary advantage of using abstraction in a software system?",
                                                "input": "A. It simplifies the system by hiding unnecessary details\nB. It increases the number of classes\nC. It forces the program to handle exceptions\nD. It removes the need for interfaces",
                                                "output": "A. It simplifies the system by hiding unnecessary details"
                                                },
                                                {
                                                "instruction": "Which of the following would be the best use case for abstraction?",
                                                "input": "A. Hiding the implementation details of a bank account while exposing methods like deposit and withdraw\nB. Exposing all internal methods of a class\nC. Implementing only static methods in a class\nD. Writing all methods in one class without any classes",
                                                "output": "A. Hiding the implementation details of a bank account while exposing methods like deposit and withdraw"
                                                },
                                                {
                                                    "instruction": "Which of the following best describes abstraction in object-oriented programming?",
                                                    "input": "A. The process of hiding the internal workings of an object and exposing only the necessary functionalities\nB. The process of combining multiple objects into a single class\nC. The process of initializing objects\nD. The process of implementing all methods in a class",
                                                    "output": "A. The process of hiding the internal workings of an object and exposing only the necessary functionalities"
                                                    },
                                                    {
                                                    "instruction": "Which type of method can be declared in an abstract class?",
                                                    "input": "A. Abstract methods only\nB. Concrete methods only\nC. Both abstract and concrete methods\nD. Private methods only",
                                                    "output": "C. Both abstract and concrete methods"
                                                    },
                                                    {
                                                    "instruction": "Which of the following is true about an abstract class?",
                                                    "input": "A. It cannot have any constructors\nB. It can contain fully implemented methods\nC. It must contain only abstract methods\nD. It cannot inherit from other classes",
                                                    "output": "B. It can contain fully implemented methods"
                                                    },
                                                    {
                                                    "instruction": "What does an interface in Java allow?",
                                                    "input": "A. Multiple inheritance\nB. Private methods\nC. Constructors\nD. Method overloading",
                                                    "output": "A. Multiple inheritance"
                                                    },
                                                    {
                                                    "instruction": "Which of the following is an example of data abstraction?",
                                                    "input": "A. Using getters and setters to access private fields\nB. Using inheritance to create subclasses\nC. Using static methods to share data across objects\nD. Using method overloading to define multiple methods with the same name",
                                                    "output": "A. Using getters and setters to access private fields"
                                                    },
                                                    {
                                                    "instruction": "What must an abstract class contain?",
                                                    "input": "A. At least one abstract method\nB. Only concrete methods\nC. Only private methods\nD. No methods at all",
                                                    "output": "A. At least one abstract method"
                                                    },
                                                    {
                                                    "instruction": "Which of the following best describes the role of abstraction in software design?",
                                                    "input": "A. It allows developers to focus on what an object does, rather than how it does it\nB. It makes objects more complex and harder to manage\nC. It requires all methods to be defined in a single class\nD. It eliminates the need for inheritance",
                                                    "output": "A. It allows developers to focus on what an object does, rather than how it does it"
                                                    },
                                                    {
                                                    "instruction": "In Java, how do abstract classes contribute to data abstraction?",
                                                    "input": "A. By preventing objects from being instantiated\nB. By hiding the implementation of methods from the user\nC. By making all methods static\nD. By providing access to all internal data members",
                                                    "output": "B. By hiding the implementation of methods from the user"
                                                    },
                                                    {
                                                    "instruction": "Which of the following statements is true about an abstract class and an interface?",
                                                    "input": "A. An abstract class can be extended, while an interface can only be implemented\nB. An interface can be instantiated, while an abstract class cannot\nC. An interface cannot contain methods, while an abstract class can\nD. An abstract class cannot contain fields, while an interface can",
                                                    "output": "A. An abstract class can be extended, while an interface can only be implemented"
                                                    },
                                                    {
                                                    "instruction": "Which of the following is true about interfaces in Java?",
                                                    "input": "A. Interfaces can contain method implementations\nB. Interfaces are not allowed to have constructors\nC. Interfaces can only contain concrete methods\nD. Interfaces can contain instance variables",
                                                    "output": "B. Interfaces are not allowed to have constructors"
                                                    },
                                                    {
                                                    "instruction": "What happens when a class implements an interface in Java?",
                                                    "input": "A. The class must define all the methods declared in the interface\nB. The class must be declared abstract\nC. The class automatically inherits all the methods of the interface\nD. The class can only use the methods defined in the interface",
                                                    "output": "A. The class must define all the methods declared in the interface"
                                                    },
                                                    {
                                                    "instruction": "Which of the following is NOT an advantage of abstraction?",
                                                    "input": "A. It increases the complexity of the program\nB. It improves the maintainability of the code\nC. It reduces code duplication\nD. It hides implementation details",
                                                    "output": "A. It increases the complexity of the program"
                                                    },
                                                    {
                                                    "instruction": "What is the role of an abstract method in Java?",
                                                    "input": "A. To provide a blueprint for methods that must be implemented by subclasses\nB. To provide the implementation for the method\nC. To prevent method overloading\nD. To make the method final",
                                                    "output": "A. To provide a blueprint for methods that must be implemented by subclasses"
                                                    },
                                                    {
                                                    "instruction": "Which of the following statements about abstraction is correct?",
                                                    "input": "A. Abstraction allows us to focus on the essential characteristics of an object\nB. Abstraction hides all details of implementation\nC. Abstraction is only applicable to classes and not methods\nD. Abstraction requires that all data members are private",
                                                    "output": "A. Abstraction allows us to focus on the essential characteristics of an object"
                                                    },
                                                    {
                                                    "instruction": "What is the purpose of using getter and setter methods in the context of data abstraction?",
                                                    "input": "A. To expose the internal state of an object to the outside world\nB. To hide the implementation details and provide controlled access to object data\nC. To allow direct access to the private fields\nD. To make data members static",
                                                    "output": "B. To hide the implementation details and provide controlled access to object data"
                                                    },
                                                    {
                                                    "instruction": "Which of the following is the best use case for an abstract class?",
                                                    "input": "A. When you need to define a common interface for different classes\nB. When you want to define methods that can be used without modification\nC. When you need to share code that can be inherited by multiple subclasses\nD. When you need to create a class that cannot be subclassed",
                                                    "output": "C. When you need to share code that can be inherited by multiple subclasses"
                                                    },
                                                    {
                                                    "instruction": "What does the keyword 'abstract' signify when applied to a class?",
                                                    "input": "A. The class cannot be subclassed\nB. The class can only contain static methods\nC. The class cannot be instantiated directly\nD. The class must contain only abstract methods",
                                                    "output": "C. The class cannot be instantiated directly"
                                                    },
                                                    {
                                                    "instruction": "Which of the following statements is true about interfaces and abstraction?",
                                                    "input": "A. Interfaces cannot contain any implementation details\nB. Interfaces can provide default method implementations\nC. Interfaces are only used for method overloading\nD. Interfaces cannot be inherited",
                                                    "output": "B. Interfaces can provide default method implementations"
                                                    },
                                                    {
                                                    "instruction": "Which of the following is a key characteristic of data abstraction in object-oriented programming?",
                                                    "input": "A. Hiding the implementation details from the user\nB. Making all methods static\nC. Exposing all data members of a class\nD. Making every method public",
                                                    "output": "A. Hiding the implementation details from the user"
                                                    },
                                                    {
                                                        "instruction": "Which of the following is true about the use of interfaces in data abstraction?",
                                                        "input": "A. An interface provides a way to achieve multiple inheritance\nB. An interface can have private methods\nC. An interface can only contain concrete methods\nD. An interface must be abstract by default",
                                                        "output": "A. An interface provides a way to achieve multiple inheritance"
                                                        },
                                                        {
                                                        "instruction": "What is the purpose of the abstract keyword in Java?",
                                                        "input": "A. It prevents a class from being instantiated directly\nB. It makes the class final\nC. It defines a concrete method\nD. It provides access to private members",
                                                        "output": "A. It prevents a class from being instantiated directly"
                                                        },
                                                        {
                                                        "instruction": "Which of the following is true about data abstraction?",
                                                        "input": "A. It focuses on the functionality of an object while hiding its internal details\nB. It exposes all the internal details to the user\nC. It requires every class to be abstract\nD. It makes object methods static",
                                                        "output": "A. It focuses on the functionality of an object while hiding its internal details"
                                                        },
                                                        {
                                                        "instruction": "Which of the following is a feature of abstraction?",
                                                        "input": "A. Hiding implementation details\nB. Defining all methods\nC. Making objects mutable\nD. Making every method private",
                                                        "output": "A. Hiding implementation details"
                                                        },
                                                        {
                                                        "instruction": "Which keyword is used to declare an interface in Java?",
                                                        "input": "A. interface\nB. abstract\nC. class\nD. implements",
                                                        "output": "A. interface"
                                                        },
                                                        {
                                                        "instruction": "Which of the following is a characteristic of a class with abstraction?",
                                                        "input": "A. It can have both abstract and concrete methods\nB. It cannot have any constructors\nC. It must be declared final\nD. It can only contain static fields",
                                                        "output": "A. It can have both abstract and concrete methods"
                                                        },
                                                        {
                                                        "instruction": "Which of the following methods can an abstract class contain?",
                                                        "input": "A. Only abstract methods\nB. Only static methods\nC. Both abstract and concrete methods\nD. Only concrete methods",
                                                        "output": "C. Both abstract and concrete methods"
                                                        },
                                                        {
                                                        "instruction": "Which of the following is true about an abstract method?",
                                                        "input": "A. It must be implemented by subclasses\nB. It can have a body\nC. It can be static\nD. It can only be used in interfaces",
                                                        "output": "A. It must be implemented by subclasses"
                                                        },
                                                        {
                                                        "instruction": "Which of the following statements is correct about abstraction in object-oriented programming?",
                                                        "input": "A. It helps simplify code by reducing complexity\nB. It requires the use of only abstract classes\nC. It allows direct access to internal object states\nD. It does not allow the use of interfaces",
                                                        "output": "A. It helps simplify code by reducing complexity"
                                                        },
                                                        {
                                                        "instruction": "What is a key benefit of abstraction in object-oriented programming?",
                                                        "input": "A. It allows objects to be treated as instances of their base class\nB. It increases code duplication\nC. It eliminates inheritance\nD. It forces all methods to be implemented",
                                                        "output": "A. It allows objects to be treated as instances of their base class"
                                                        },
                                                        {
                                                        "instruction": "Which of the following is true about interfaces in Java?",
                                                        "input": "A. An interface defines a contract that implementing classes must follow\nB. An interface can contain concrete methods\nC. An interface can contain constructors\nD. An interface cannot be extended by other interfaces",
                                                        "output": "A. An interface defines a contract that implementing classes must follow"
                                                        },
                                                        {
                                                        "instruction": "Which of the following is NOT a feature of data abstraction?",
                                                        "input": "A. Exposing only relevant details to the user\nB. Hiding implementation complexity\nC. Making all methods abstract\nD. Providing controlled access to internal data",
                                                        "output": "C. Making all methods abstract"
                                                        },
                                                        {
                                                        "instruction": "What is the primary goal of data abstraction?",
                                                        "input": "A. To hide complex implementation details and show only relevant information\nB. To make all methods private\nC. To increase the amount of code required\nD. To prevent inheritance",
                                                        "output": "A. To hide complex implementation details and show only relevant information"
                                                        },
                                                        {
                                                        "instruction": "Which of the following does abstraction help achieve in object-oriented programming?",
                                                        "input": "A. Reducing code duplication and complexity\nB. Enforcing strict data access controls\nC. Making all methods static\nD. Restricting inheritance",
                                                        "output": "A. Reducing code duplication and complexity"
                                                        },
                                                        {
                                                        "instruction": "Which of the following statements is true regarding abstract classes and interfaces?",
                                                        "input": "A. An abstract class can have both abstract and concrete methods\nB. An interface cannot have any methods\nC. An abstract class cannot be inherited\nD. An interface can contain instance variables",
                                                        "output": "A. An abstract class can have both abstract and concrete methods"
                                                        },
                                                        {
                                                        "instruction": "In data abstraction, what is typically hidden from the user?",
                                                        "input": "A. The internal workings and implementation details of an object\nB. The names of the methods\nC. The data members of the class\nD. The access modifiers",
                                                        "output": "A. The internal workings and implementation details of an object"
                                                        },
                                                        {
                                                        "instruction": "Which of the following is a valid reason to use abstraction in object-oriented programming?",
                                                        "input": "A. To reduce the complexity of the program and make the system easier to understand\nB. To force classes to use specific names\nC. To make all methods static\nD. To ensure that all classes are final",
                                                        "output": "A. To reduce the complexity of the program and make the system easier to understand"
                                                        },
                                                        {
                                                        "instruction": "Which of the following is true about interfaces in Java?",
                                                        "input": "A. Interfaces define the structure for classes that implement them\nB. Interfaces can be instantiated directly\nC. Interfaces can have constructors\nD. Interfaces are used to store data",
                                                        "output": "A. Interfaces define the structure for classes that implement them"
                                                        },
                                                        {
                                                        "instruction": "Which of the following is an example of abstraction in Java?",
                                                        "input": "A. A class using private data members and providing public methods to access them\nB. A class using only static methods\nC. A class using only public methods\nD. A class implementing all methods in the interface",
                                                        "output": "A. A class using private data members and providing public methods to access them"
                                                        },
                                                        {
                                                            "instruction": "What is the effect of using the abstract modifier in a class?",
                                                            "input": "A. The class cannot be instantiated\nB. The class can only have private methods\nC. The class can only have abstract methods\nD. The class can only be used in the main method",
                                                            "output": "A. The class cannot be instantiated"
                                                            },
                                                            {
                                                            "instruction": "Which of the following is NOT a characteristic of an abstract class?",
                                                            "input": "A. It can be instantiated directly\nB. It can contain both abstract and concrete methods\nC. It can have constructors\nD. It can be subclassed",
                                                            "output": "A. It can be instantiated directly"
                                                            },
                                                            {
                                                            "instruction": "Which of the following best describes an interface in object-oriented programming?",
                                                            "input": "A. A contract that defines methods without implementation\nB. A class that implements all abstract methods\nC. A class that can only contain static methods\nD. A class with an implementation for all methods",
                                                            "output": "A. A contract that defines methods without implementation"
                                                            },
                                                            {
                                                            "instruction": "What does an abstract class allow developers to do?",
                                                            "input": "A. Define methods with or without implementation\nB. Make classes final\nC. Avoid using inheritance\nD. Avoid using constructors",
                                                            "output": "A. Define methods with or without implementation"
                                                            },
                                                            {
                                                            "instruction": "Which of the following is an advantage of using abstraction?",
                                                            "input": "A. It hides the internal details and allows only relevant functionality to be exposed\nB. It allows the direct manipulation of data\nC. It forces classes to implement all methods\nD. It prevents the use of inheritance",
                                                            "output": "A. It hides the internal details and allows only relevant functionality to be exposed"
                                                            },
                                                            {
                                                            "instruction": "Which of the following is NOT part of abstraction in object-oriented programming?",
                                                            "input": "A. Hiding data\nB. Hiding code implementation\nC. Exposing complex internal details\nD. Providing a simple interface to the user",
                                                            "output": "C. Exposing complex internal details"
                                                            },
                                                            {
                                                            "instruction": "What happens when a class implements an interface in Java?",
                                                            "input": "A. It must provide concrete implementations for all methods declared in the interface\nB. It can inherit methods from another class\nC. It cannot have any fields\nD. It automatically becomes an abstract class",
                                                            "output": "A. It must provide concrete implementations for all methods declared in the interface"
                                                            },
                                                            {
                                                            "instruction": "Which of the following is true about methods in an abstract class?",
                                                            "input": "A. They can be abstract or concrete\nB. They must be concrete\nC. They must be static\nD. They cannot have parameters",
                                                            "output": "A. They can be abstract or concrete"
                                                            },
                                                            {
                                                            "instruction": "Which of the following best explains data abstraction in programming?",
                                                            "input": "A. Data abstraction hides complex details and shows only essential features\nB. Data abstraction exposes all details to the user\nC. Data abstraction is only relevant for static data\nD. Data abstraction allows direct access to data members",
                                                            "output": "A. Data abstraction hides complex details and shows only essential features"
                                                            },
                                                            {
                                                            "instruction": "Which of the following is the main benefit of abstraction in object-oriented programming?",
                                                            "input": "A. It reduces complexity and isolates the impact of changes\nB. It increases code duplication\nC. It forces every class to be abstract\nD. It prevents the use of inheritance",
                                                            "output": "A. It reduces complexity and isolates the impact of changes"
                                                            },
                                                            {
                                                            "instruction": "Which of the following is true about abstract classes in Java?",
                                                            "input": "A. Abstract classes cannot be instantiated\nB. Abstract classes can be instantiated directly\nC. Abstract classes must contain at least one abstract method\nD. Abstract classes can only have private methods",
                                                            "output": "A. Abstract classes cannot be instantiated"
                                                            },
                                                            {
                                                            "instruction": "Which of the following is true about the 'abstract' modifier in Java?",
                                                            "input": "A. It allows a class to have both abstract and concrete methods\nB. It prevents the use of inheritance\nC. It forces a class to have no methods\nD. It makes a class final",
                                                            "output": "A. It allows a class to have both abstract and concrete methods"
                                                            },
                                                            {
                                                            "instruction": "Which of the following is an example of data abstraction in real life?",
                                                            "input": "A. A cars steering wheel hides the complex workings of the engine\nB. The color of a cars exterior is a type of abstraction\nC. The price of a car hides its engine details\nD. A cars engine is an example of data abstraction",
                                                            "output": "A. A cars steering wheel hides the complex workings of the engine"
                                                            },
                                                            {
                                                            "instruction": "Which of the following defines the core concept of abstraction in object-oriented programming?",
                                                            "input": "A. Hiding the implementation details and exposing only necessary functionality\nB. Making all methods public\nC. Making all methods static\nD. Defining only abstract methods",
                                                            "output": "A. Hiding the implementation details and exposing only necessary functionality"
                                                            },
                                                            {
                                                            "instruction": "Which of the following statements is true about interfaces and abstract classes?",
                                                            "input": "A. Interfaces cannot have constructors, while abstract classes can\nB. Abstract classes cannot be extended, while interfaces can\nC. Both interfaces and abstract classes are used to define concrete methods\nD. Abstract classes cannot contain fields, while interfaces can",
                                                            "output": "A. Interfaces cannot have constructors, while abstract classes can"
                                                            },
                                                            {
                                                            "instruction": "Which of the following is a correct characteristic of data abstraction?",
                                                            "input": "A. Hiding complex implementation details from the user\nB. Exposing all internal data to the user\nC. Providing access to direct memory addresses\nD. Making every method public",
                                                            "output": "A. Hiding complex implementation details from the user"
                                                            },
                                                            {
                                                            "instruction": "In Java, what is the relationship between an abstract class and an interface?",
                                                            "input": "A. A class can implement multiple interfaces but can only extend one abstract class\nB. A class can only implement one interface\nC. An abstract class cannot have methods\nD. An interface can be instantiated directly",
                                                            "output": "A. A class can implement multiple interfaces but can only extend one abstract class"
                                                            },
                                                            {
                                                                "instruction": "What does the principle of data abstraction allow you to do in object-oriented programming?",
                                                                "input": "A. Focus on high-level operations while hiding low-level implementation details\nB. Directly access the internal data of an object\nC. Implement all methods in the class\nD. Prevent inheritance of methods from the base class",
                                                                "output": "A. Focus on high-level operations while hiding low-level implementation details"
                                                                },
                                                                {
                                                                "instruction": "What is the purpose of the 'abstract' keyword in Java?",
                                                                "input": "A. To create a class that cannot be instantiated directly\nB. To define methods that do not need to be implemented\nC. To specify that a class is final\nD. To prevent a class from being subclassed",
                                                                "output": "A. To create a class that cannot be instantiated directly"
                                                                },
                                                                {
                                                                "instruction": "Which of the following is an example of data abstraction in a car object?",
                                                                "input": "A. The car provides methods like start() and stop() without exposing the inner workings of the engine\nB. The car's engine is visible and accessible to the driver\nC. The driver must control the individual components of the engine\nD. The car requires the driver to program how the car starts",
                                                                "output": "A. The car provides methods like start() and stop() without exposing the inner workings of the engine"
                                                                },
                                                                {
                                                                "instruction": "Which of the following features is common to both abstract classes and interfaces?",
                                                                "input": "A. They allow inheritance\nB. They cannot have methods\nC. They both need to have concrete methods\nD. They cannot be extended",
                                                                "output": "A. They allow inheritance"
                                                                },
                                                                {
                                                                "instruction": "What happens when a subclass inherits from an abstract class but does not implement all abstract methods?",
                                                                "input": "A. The subclass must also be declared as abstract\nB. The subclass automatically inherits the methods\nC. The subclass will be instantiated without errors\nD. The program will crash during runtime",
                                                                "output": "A. The subclass must also be declared as abstract"
                                                                },
                                                                {
                                                                "instruction": "In an abstract class, what is required when declaring an abstract method?",
                                                                "input": "A. The method should have no body\nB. The method should have a concrete implementation\nC. The method must be static\nD. The method should be private",
                                                                "output": "A. The method should have no body"
                                                                },
                                                                {
                                                                "instruction": "Which of the following describes an interface in Java?",
                                                                "input": "A. It can contain only abstract methods\nB. It can contain concrete methods only\nC. It can contain both abstract and concrete methods\nD. It can contain static methods only",
                                                                "output": "A. It can contain only abstract methods"
                                                                },
                                                                {
                                                                "instruction": "What is the significance of encapsulation when used in conjunction with abstraction?",
                                                                "input": "A. Encapsulation hides the internal details of the object, while abstraction hides the complexity of its interface\nB. Encapsulation hides the internal details, but abstraction exposes all details of an object\nC. Encapsulation and abstraction are the same concept\nD. Encapsulation allows access to all internal details of an object",
                                                                "output": "A. Encapsulation hides the internal details of the object, while abstraction hides the complexity of its interface"
                                                                },
                                                                {
                                                                "instruction": "Which of the following is a true characteristic of abstraction?",
                                                                "input": "A. It allows you to interact with an object at a higher level of functionality\nB. It exposes every method and variable of an object\nC. It makes objects immutable\nD. It prevents inheritance from other classes",
                                                                "output": "A. It allows you to interact with an object at a higher level of functionality"
                                                                },
                                                                {
                                                                "instruction": "What would be the result of trying to instantiate an abstract class directly in Java?",
                                                                "input": "A. A compilation error\nB. A runtime error\nC. The class is instantiated, but its abstract methods cannot be called\nD. The abstract methods are automatically implemented by the compiler",
                                                                "output": "A. A compilation error"
                                                                },
                                                                {
                                                                "instruction": "Which statement correctly defines the term 'abstraction' in software engineering?",
                                                                "input": "A. The process of simplifying complex systems by hiding the unnecessary details and focusing on the essential characteristics\nB. The act of making everything in a program public\nC. The process of inheriting methods and variables\nD. The technique of making a class static",
                                                                "output": "A. The process of simplifying complex systems by hiding the unnecessary details and focusing on the essential characteristics"
                                                                },
                                                                {
                                                                "instruction": "What is the correct approach to hide the internal implementation details of a class in object-oriented programming?",
                                                                "input": "A. Use abstraction to expose only the necessary details\nB. Make every method static\nC. Avoid using inheritance\nD. Use recursion in the class methods",
                                                                "output": "A. Use abstraction to expose only the necessary details"
                                                                },
                                                                {
                                                                "instruction": "In Java, if a class implements an interface, what must it do?",
                                                                "input": "A. Implement all abstract methods defined in the interface\nB. Only declare the methods without implementing them\nC. Define constructors for the interface\nD. Declare the methods as private",
                                                                "output": "A. Implement all abstract methods defined in the interface"
                                                                },
                                                                {
                                                                "instruction": "What is the role of an abstract method in Java?",
                                                                "input": "A. It must be implemented by any subclass of the abstract class\nB. It can have an implementation in the parent class\nC. It defines concrete functionality\nD. It can only be used in static methods",
                                                                "output": "A. It must be implemented by any subclass of the abstract class"
                                                                },
                                                                {
                                                                "instruction": "Which of the following can be declared as abstract in Java?",
                                                                "input": "A. Classes and methods\nB. Only methods\nC. Only fields\nD. Only constructors",
                                                                "output": "A. Classes and methods"
                                                                },
                                                                {
                                                                "instruction": "Which of the following statements about interfaces is true in Java?",
                                                                "input": "A. An interface defines a contract that a class must adhere to\nB. An interface can contain fields\nC. An interface cannot be implemented by classes\nD. An interface is identical to a class",
                                                                "output": "A. An interface defines a contract that a class must adhere to"
                                                                },
                                                                {
                                                                "instruction": "What is an abstract class used for in object-oriented design?",
                                                                "input": "A. To provide a common interface for other classes to inherit\nB. To define methods that cannot be overridden\nC. To allow a class to be instantiated directly\nD. To define only static methods",
                                                                "output": "A. To provide a common interface for other classes to inherit"
                                                                },
                                                                {
                                                                "instruction": "Why is abstraction considered one of the core concepts of object-oriented programming?",
                                                                "input": "A. It allows developers to focus on the functionality of objects while hiding complex implementation details\nB. It eliminates the need for inheritance\nC. It makes objects static\nD. It forces classes to implement every method",
                                                                "output": "A. It allows developers to focus on the functionality of objects while hiding complex implementation details"
                                                                },
                                                                {
                                                                    "instruction": "Which of the following is a correct example of abstraction in Java?",
                                                                    "input": "A. Using a class with abstract methods that are implemented by subclasses\nB. Instantiating an abstract class directly\nC. Making all methods in a class private\nD. Directly accessing the internal data of a class",
                                                                    "output": "A. Using a class with abstract methods that are implemented by subclasses"
                                                                    },
                                                                    {
                                                                    "instruction": "Which of the following is true about abstract classes and interfaces in Java?",
                                                                    "input": "A. An abstract class can have both abstract and concrete methods, whereas an interface can only have abstract methods\nB. An abstract class cannot have constructors\nC. An interface can have instance variables\nD. An abstract class can be instantiated",
                                                                    "output": "A. An abstract class can have both abstract and concrete methods, whereas an interface can only have abstract methods"
                                                                    },
                                                                    {
                                                                    "instruction": "How can data abstraction be achieved in object-oriented programming?",
                                                                    "input": "A. By creating classes with private fields and providing public methods for access\nB. By using only static methods in the class\nC. By inheriting from multiple classes\nD. By making all methods abstract",
                                                                    "output": "A. By creating classes with private fields and providing public methods for access"
                                                                    },
                                                                    {
                                                                    "instruction": "What is the main benefit of using abstraction in software design?",
                                                                    "input": "A. It hides the complexity of the system and exposes only necessary functionality\nB. It allows multiple inheritance\nC. It forces the implementation of all methods\nD. It makes the system more complex",
                                                                    "output": "A. It hides the complexity of the system and exposes only necessary functionality"
                                                                    },
                                                                    {
                                                                    "instruction": "Which of the following is NOT an example of abstraction?",
                                                                    "input": "A. A class that exposes every implementation detail of its methods\nB. A class that provides a simple interface while hiding the implementation details\nC. An interface that defines a contract for the implementing classes\nD. An abstract class with abstract methods to be implemented by subclasses",
                                                                    "output": "A. A class that exposes every implementation detail of its methods"
                                                                    },
                                                                    {
                                                                    "instruction": "In object-oriented programming, what is an example of encapsulation?",
                                                                    "input": "A. Hiding the implementation details of a class and exposing only the necessary methods\nB. Making all methods in a class static\nC. Using recursion in methods\nD. Providing access to all private fields of a class",
                                                                    "output": "A. Hiding the implementation details of a class and exposing only the necessary methods"
                                                                    },
                                                                    {
                                                                    "instruction": "Which of the following is true about an abstract class in Java?",
                                                                    "input": "A. It cannot be instantiated directly\nB. It can have constructors\nC. It can be inherited by another abstract class only\nD. It cannot have any abstract methods",
                                                                    "output": "A. It cannot be instantiated directly"
                                                                    },
                                                                    {
                                                                    "instruction": "How does abstraction help in managing large codebases?",
                                                                    "input": "A. By simplifying the interface and hiding the complex implementation details\nB. By exposing all methods and variables to the user\nC. By preventing the use of inheritance\nD. By increasing the size of the codebase",
                                                                    "output": "A. By simplifying the interface and hiding the complex implementation details"
                                                                    },
                                                                    {
                                                                    "instruction": "What is the primary goal of using data abstraction in object-oriented programming?",
                                                                    "input": "A. To simplify the interaction with objects by hiding the implementation details\nB. To make the codebase more complex\nC. To allow multiple inheritance\nD. To prevent the use of inheritance",
                                                                    "output": "A. To simplify the interaction with objects by hiding the implementation details"
                                                                    },
                                                                    {
                                                                    "instruction": "Which of the following is a key advantage of data abstraction?",
                                                                    "input": "A. It promotes code reuse and modularity by hiding unnecessary details\nB. It reduces the need for inheritance\nC. It allows for direct manipulation of data fields\nD. It makes methods static",
                                                                    "output": "A. It promotes code reuse and modularity by hiding unnecessary details"
                                                                    },
                                                                    {
                                                                    "instruction": "In a class that implements an interface, what must the class provide?",
                                                                    "input": "A. Concrete implementations of all abstract methods declared in the interface\nB. An abstract constructor\nC. Private methods for internal use only\nD. A constructor for the interface",
                                                                    "output": "A. Concrete implementations of all abstract methods declared in the interface"
                                                                    },
                                                                    {
                                                                    "instruction": "Why do we use abstraction in Java?",
                                                                    "input": "A. To reduce the complexity of interacting with objects by focusing on essential features\nB. To expose all data members of a class\nC. To create multiple constructors in a class\nD. To define methods that can only be overridden",
                                                                    "output": "A. To reduce the complexity of interacting with objects by focusing on essential features"
                                                                    },
                                                                    {
                                                                    "instruction": "Which of the following is a characteristic of an interface in Java?",
                                                                    "input": "A. It can only contain abstract methods and constants\nB. It can contain instance variables\nC. It can implement multiple classes\nD. It can have concrete methods only",
                                                                    "output": "A. It can only contain abstract methods and constants"
                                                                    },
                                                                    {
                                                                    "instruction": "What happens when a class implements an interface but does not provide an implementation for all its methods?",
                                                                    "input": "A. The class must be declared abstract\nB. The class will compile without errors\nC. The program will execute normally\nD. The class will automatically inherit the methods from the interface",
                                                                    "output": "A. The class must be declared abstract"
                                                                    },
                                                                    {
                                                                    "instruction": "What is an advantage of using abstract classes in programming?",
                                                                    "input": "A. They allow shared behavior between classes while forcing subclasses to implement specific methods\nB. They allow inheritance but prevent method overriding\nC. They allow for direct manipulation of the fields of a class\nD. They eliminate the need for constructors",
                                                                    "output": "A. They allow shared behavior between classes while forcing subclasses to implement specific methods"
                                                                    },
                                                                    {
                                                                    "instruction": "Which of the following best describes data abstraction?",
                                                                    "input": "A. Hiding unnecessary details and exposing only relevant information to the user\nB. Hiding data members and only exposing methods to the user\nC. Making all fields private and not allowing access to them\nD. Using only static methods in a class",
                                                                    "output": "A. Hiding unnecessary details and exposing only relevant information to the user"
                                                                    },
                                                                    {
                                                                    "instruction": "Which of the following describes the role of abstraction in software development?",
                                                                    "input": "A. It allows developers to work with high-level functionality without worrying about low-level implementation\nB. It exposes all implementation details of a class to the user\nC. It prevents the use of inheritance in object-oriented programming\nD. It ensures that all classes are instantiated directly",
                                                                    "output": "A. It allows developers to work with high-level functionality without worrying about low-level implementation"
                                                                    },
                                                                    {
                                                                        "instruction": "Data abstraction in object-oriented programming is achieved by using ________ to hide implementation details from the user.",
                                                                        "input": "",
                                                                        "output": "classes"
                                                                        },
                                                                        {
                                                                        "instruction": "In Java, a class that cannot be instantiated directly is known as a ________ class.",
                                                                        "input": "",
                                                                        "output": "abstract"
                                                                        },
                                                                        {
                                                                        "instruction": "In Java, an interface can only contain ________ methods and ________.",
                                                                        "input": "",
                                                                        "output": "abstract, constants"
                                                                        },
                                                                        {
                                                                        "instruction": "Abstraction helps in reducing the complexity of a system by exposing only the ________ details.",
                                                                        "input": "",
                                                                        "output": "essential"
                                                                        },
                                                                        {
                                                                        "instruction": "To achieve abstraction, a class can provide a ________ method to hide the internal implementation from the user.",
                                                                        "input": "",
                                                                        "output": "public"
                                                                        },
                                                                        {
                                                                        "instruction": "In Java, the ________ keyword is used to define a class that cannot be instantiated and can contain abstract methods.",
                                                                        "input": "",
                                                                        "output": "abstract"
                                                                        },
                                                                        {
                                                                        "instruction": "The process of hiding the internal workings of an object and only showing the necessary functionality is called ________.",
                                                                        "input": "",
                                                                        "output": "abstraction"
                                                                        },
                                                                        {
                                                                        "instruction": "An abstract class can have both ________ and ________ methods.",
                                                                        "input": "",
                                                                        "output": "abstract, concrete"
                                                                        },
                                                                        {
                                                                        "instruction": "To define a contract for classes to follow, we use ________ in Java.",
                                                                        "input": "",
                                                                        "output": "interfaces"
                                                                        },
                                                                        {
                                                                        "instruction": "The ________ keyword is used in Java to make a method that must be implemented by any subclass of an abstract class.",
                                                                        "input": "",
                                                                        "output": "abstract"
                                                                        },
                                                                        {
                                                                        "instruction": "________ allows a user to interact with the system without needing to understand the complex internal details.",
                                                                        "input": "",
                                                                        "output": "Abstraction"
                                                                        },
                                                                        {
                                                                        "instruction": "A class that implements an interface must provide concrete implementations for all the ________ methods of that interface.",
                                                                        "input": "",
                                                                        "output": "abstract"
                                                                        },
                                                                        {
                                                                        "instruction": "In data abstraction, ________ helps to focus on the what an object can do, rather than how it does it.",
                                                                        "input": "",
                                                                        "output": "interfaces"
                                                                        },
                                                                        {
                                                                        "instruction": "Abstraction in object-oriented programming can be implemented using ________ and ________.",
                                                                        "input": "",
                                                                        "output": "abstract classes, interfaces"
                                                                        },
                                                                        {
                                                                        "instruction": "In Java, if a class does not implement all methods of an interface, the class must be declared ________.",
                                                                        "input": "",
                                                                        "output": "abstract"
                                                                        },
                                                                        {
                                                                        "instruction": "The process of using abstract classes and interfaces in object-oriented programming is an example of ________ in software design.",
                                                                        "input": "",
                                                                        "output": "abstraction"
                                                                        },
                                                                        {
                                                                        "instruction": "A key advantage of using abstraction in programming is that it promotes ________ by separating the interface from the implementation.",
                                                                        "input": "",
                                                                        "output": "modularity"
                                                                        },
                                                                        {
                                                                        "instruction": "In object-oriented programming, ________ is used to hide the internal implementation of an object and expose only the necessary methods.",
                                                                        "input": "",
                                                                        "output": "abstraction"
                                                                        },
                                                                        {
                                                                        "instruction": "An interface can be implemented by any ________ class, as long as it provides concrete methods for all abstract methods of the interface.",
                                                                        "input": "",
                                                                        "output": "concrete"
                                                                        },
                                                                        {
                                                                            "instruction": "In object-oriented programming, ________ helps in organizing data and hiding the details from the outside world.",
                                                                            "input": "",
                                                                            "output": "abstraction"
                                                                            },
                                                                            {
                                                                            "instruction": "An abstract method does not have a ________ in the parent class.",
                                                                            "input": "",
                                                                            "output": "body"
                                                                            },
                                                                            {
                                                                            "instruction": "In Java, the ________ keyword is used to declare a method that does not have an implementation in the parent class but must be implemented by subclasses.",
                                                                            "input": "",
                                                                            "output": "abstract"
                                                                            },
                                                                            {
                                                                            "instruction": "The principle of abstraction in object-oriented programming allows you to focus on the ________ of a problem rather than the details.",
                                                                            "input": "",
                                                                            "output": "high-level"
                                                                            },
                                                                            {
                                                                            "instruction": "In abstraction, the implementation details are hidden using ________ and ________.",
                                                                            "input": "",
                                                                            "output": "abstract classes, interfaces"
                                                                            },
                                                                            {
                                                                            "instruction": "An interface defines a set of ________ methods, and a class that implements the interface must provide the implementations.",
                                                                            "input": "",
                                                                            "output": "abstract"
                                                                            },
                                                                            {
                                                                            "instruction": "Abstraction helps in reducing the ________ of a system by showing only relevant details to the user.",
                                                                            "input": "",
                                                                            "output": "complexity"
                                                                            },
                                                                            {
                                                                            "instruction": "In Java, when a class is abstract, it cannot be ________ directly.",
                                                                            "input": "",
                                                                            "output": "instantiated"
                                                                            },
                                                                            {
                                                                            "instruction": "Abstraction allows you to create ________ to interact with objects without needing to know their internal details.",
                                                                            "input": "",
                                                                            "output": "interfaces"
                                                                            },
                                                                            {
                                                                            "instruction": "A subclass can implement an abstract method from its parent class by providing a ________ implementation.",
                                                                            "input": "",
                                                                            "output": "concrete"
                                                                            },
                                                                            {
                                                                            "instruction": "In an abstract class, all methods can be either ________ or concrete.",
                                                                            "input": "",
                                                                            "output": "abstract"
                                                                            },
                                                                            {
                                                                            "instruction": "An abstract class is a class that cannot be ________ on its own but can be inherited by other classes.",
                                                                            "input": "",
                                                                            "output": "instantiated"
                                                                            },
                                                                            {
                                                                            "instruction": "In abstraction, the user interacts with an object through its ________ while the internal workings remain hidden.",
                                                                            "input": "",
                                                                            "output": "interface"
                                                                            },
                                                                            {
                                                                            "instruction": "The purpose of data abstraction in object-oriented programming is to separate the ________ from the implementation details.",
                                                                            "input": "",
                                                                            "output": "interface"
                                                                            },
                                                                            {
                                                                            "instruction": "The ________ of an abstract class provides the blueprint for subclasses to follow in their implementation.",
                                                                            "input": "",
                                                                            "output": "abstract methods"
                                                                            },
                                                                            {
                                                                            "instruction": "In object-oriented programming, an abstract class is used to create a ________ for a group of related classes.",
                                                                            "input": "",
                                                                            "output": "base class"
                                                                            },
                                                                            {
                                                                            "instruction": "In Java, an interface is a collection of abstract methods and ________.",
                                                                            "input": "",
                                                                            "output": "constants"
                                                                            },
                                                                            {
                                                                            "instruction": "In object-oriented design, abstraction allows you to hide unnecessary details and expose only ________ functionality.",
                                                                            "input": "",
                                                                            "output": "essential"
                                                                            },
                                                                            {
                                                                            "instruction": "In data abstraction, you can define abstract methods that must be implemented by ________ classes.",
                                                                            "input": "",
                                                                            "output": "subclass"
                                                                            },
                                                                            {
                                                                                "instruction": "In Java, the ________ keyword allows a class to define common behavior that can be shared by multiple subclasses.",
                                                                                "input": "",
                                                                                "output": "abstract"
                                                                                },
                                                                                {
                                                                                "instruction": "Abstraction in Java enables developers to create objects that focus on ________ rather than implementation details.",
                                                                                "input": "",
                                                                                "output": "behavior"
                                                                                },
                                                                                {
                                                                                "instruction": "In an interface, all methods are by default ________ and cannot have a body.",
                                                                                "input": "",
                                                                                "output": "abstract"
                                                                                },
                                                                                {
                                                                                "instruction": "To implement abstraction in object-oriented programming, you can create a ________ class that provides a template for other classes.",
                                                                                "input": "",
                                                                                "output": "base"
                                                                                },
                                                                                {
                                                                                "instruction": "The ________ of an object specifies what actions it can perform, while the implementation shows how these actions are carried out.",
                                                                                "input": "",
                                                                                "output": "interface"
                                                                                },
                                                                                {
                                                                                "instruction": "The abstraction principle helps in building software systems that are ________ and easier to maintain.",
                                                                                "input": "",
                                                                                "output": "modular"
                                                                                },
                                                                                {
                                                                                "instruction": "Data abstraction allows you to expose the essential functionality of a system while hiding the ________ details.",
                                                                                "input": "",
                                                                                "output": "complex"
                                                                                },
                                                                                {
                                                                                "instruction": "In Java, an interface cannot have ________ methods, only abstract methods and constants.",
                                                                                "input": "",
                                                                                "output": "concrete"
                                                                                },
                                                                                {
                                                                                "instruction": "An abstract class can contain ________ and abstract methods.",
                                                                                "input": "",
                                                                                "output": "concrete"
                                                                                },
                                                                                {
                                                                                "instruction": "The abstraction principle allows you to simplify complex systems by focusing on the ________ functionality.",
                                                                                "input": "",
                                                                                "output": "essential"
                                                                                },
                                                                                {
                                                                                    "instruction": "True or False: Abstraction in object-oriented programming hides the implementation details and shows only the necessary functionality.",
                                                                                    "input": "",
                                                                                    "output": "True"
                                                                                    },
                                                                                    {
                                                                                    "instruction": "True or False: An abstract class can be instantiated directly in Java.",
                                                                                    "input": "",
                                                                                    "output": "False"
                                                                                    },
                                                                                    {
                                                                                    "instruction": "True or False: In Java, all methods in an interface are implicitly abstract and do not have a body.",
                                                                                    "input": "",
                                                                                    "output": "True"
                                                                                    },
                                                                                    {
                                                                                    "instruction": "True or False: The primary goal of abstraction is to simplify the system by hiding unnecessary details.",
                                                                                    "input": "",
                                                                                    "output": "True"
                                                                                    },
                                                                                    {
                                                                                    "instruction": "True or False: A class can implement multiple interfaces in Java, allowing it to inherit behavior from multiple sources.",
                                                                                    "input": "",
                                                                                    "output": "True"
                                                                                    },
                                                                                    {
                                                                                    "instruction": "True or False: Data abstraction is a technique that allows the implementation details of an object to be exposed to the user.",
                                                                                    "input": "",
                                                                                    "output": "False"
                                                                                    },
                                                                                    {
                                                                                    "instruction": "True or False: An interface can contain both abstract methods and concrete methods with implementations in Java.",
                                                                                    "input": "",
                                                                                    "output": "False"
                                                                                    },
                                                                                    {
                                                                                    "instruction": "True or False: In object-oriented programming, abstraction helps in reducing the complexity of a system by focusing on the essential details.",
                                                                                    "input": "",
                                                                                    "output": "True"
                                                                                    },
                                                                                    {
                                                                                    "instruction": "True or False: Abstract classes in Java can have both abstract and concrete methods.",
                                                                                    "input": "",
                                                                                    "output": "True"
                                                                                    },
                                                                                    {
                                                                                    "instruction": "True or False: Abstraction allows you to interact with objects based on their interface without needing to understand their implementation.",
                                                                                    "input": "",
                                                                                    "output": "True"
                                                                                    },
                                                                                    {
                                                                                    "instruction": "True or False: An abstract class can be instantiated if it has no abstract methods.",
                                                                                    "input": "",
                                                                                    "output": "False"
                                                                                    },
                                                                                    {
                                                                                    "instruction": "True or False: Interfaces in Java can contain instance variables and methods with body implementations.",
                                                                                    "input": "",
                                                                                    "output": "False"
                                                                                    },
                                                                                    {
                                                                                    "instruction": "True or False: In Java, a class that implements an interface must provide implementations for all methods of the interface.",
                                                                                    "input": "",
                                                                                    "output": "True"
                                                                                    },
                                                                                    {
                                                                                    "instruction": "True or False: Abstraction is useful in creating modular code by allowing classes to focus on the 'what' rather than the 'how'.",
                                                                                    "input": "",
                                                                                    "output": "True"
                                                                                    },
                                                                                    {
                                                                                    "instruction": "True or False: The abstraction principle is only applicable in Java programming and does not apply to other programming languages.",
                                                                                    "input": "",
                                                                                    "output": "False"
                                                                                    },
                                                                                    {
                                                                                    "instruction": "True or False: Data abstraction helps in improving code reusability by hiding the implementation details and providing a clear interface.",
                                                                                    "input": "",
                                                                                    "output": "True"
                                                                                    },
                                                                                    {
                                                                                    "instruction": "True or False: An abstract class can be used to define the structure of a class without requiring it to provide any method implementations.",
                                                                                    "input": "",
                                                                                    "output": "False"
                                                                                    },
                                                                                    {
                                                                                    "instruction": "True or False: Abstraction can be achieved using abstract classes, interfaces, or both in object-oriented programming.",
                                                                                    "input": "",
                                                                                    "output": "True"
                                                                                    },
                                                                                    {
                                                                                    "instruction": "True or False: Abstract methods in a class have a body and can contain code implementation.",
                                                                                    "input": "",
                                                                                    "output": "False"
                                                                                    },
                                                                                    {
                                                                                    "instruction": "True or False: Interfaces can be used to achieve abstraction by defining only method signatures without implementations.",
                                                                                    "input": "",
                                                                                    "output": "True"
                                                                                    },
                                                                                    {
                                                                                        "instruction": "True or False: An abstract class in Java can have constructors.",
                                                                                        "input": "",
                                                                                        "output": "True"
                                                                                        },
                                                                                        {
                                                                                        "instruction": "True or False: A subclass that extends an abstract class is required to implement all abstract methods of the parent class.",
                                                                                        "input": "",
                                                                                        "output": "True"
                                                                                        },
                                                                                        {
                                                                                        "instruction": "True or False: In Java, an interface can have both abstract and non-abstract methods.",
                                                                                        "input": "",
                                                                                        "output": "False"
                                                                                        },
                                                                                        {
                                                                                        "instruction": "True or False: Abstraction allows the user to focus on the interface of an object without worrying about its internal workings.",
                                                                                        "input": "",
                                                                                        "output": "True"
                                                                                        },
                                                                                        {
                                                                                        "instruction": "True or False: A class that implements an interface does not need to provide implementations for all of its methods if the interface is not fully defined.",
                                                                                        "input": "",
                                                                                        "output": "False"
                                                                                        },
                                                                                        {
                                                                                        "instruction": "True or False: Abstraction in object-oriented programming can help achieve a higher level of modularity and code reuse.",
                                                                                        "input": "",
                                                                                        "output": "True"
                                                                                        },
                                                                                        {
                                                                                        "instruction": "True or False: Abstraction is a concept used only in high-level programming languages like Java and Python.",
                                                                                        "input": "",
                                                                                        "output": "False"
                                                                                        },
                                                                                        {
                                                                                        "instruction": "True or False: Abstract classes and interfaces can both be used to achieve abstraction in Java.",
                                                                                        "input": "",
                                                                                        "output": "True"
                                                                                        },
                                                                                        {
                                                                                        "instruction": "True or False: In Java, an abstract class can have static methods.",
                                                                                        "input": "",
                                                                                        "output": "True"
                                                                                        },
                                                                                        {
                                                                                        "instruction": "True or False: A class can implement multiple interfaces, but it can only extend one abstract class in Java.",
                                                                                        "input": "",
                                                                                        "output": "True"
                                                                                        },
                                                                                        {
                                                                                        "instruction": "True or False: In Java, you can define a method in an interface with a body if the method is not abstract.",
                                                                                        "input": "",
                                                                                        "output": "True"
                                                                                        },
                                                                                        {
                                                                                        "instruction": "True or False: Abstraction hides only the data but not the methods of a class or interface.",
                                                                                        "input": "",
                                                                                        "output": "False"
                                                                                        },
                                                                                        {
                                                                                        "instruction": "True or False: The primary advantage of abstraction is that it allows the user to interact with objects without needing to understand their implementation details.",
                                                                                        "input": "",
                                                                                        "output": "True"
                                                                                        },
                                                                                        {
                                                                                        "instruction": "True or False: In Java, an abstract class can be used to create multiple instances of its own type.",
                                                                                        "input": "",
                                                                                        "output": "False"
                                                                                        },
                                                                                        {
                                                                                        "instruction": "True or False: Data abstraction makes it easier to understand how a system works by focusing only on the essential parts.",
                                                                                        "input": "",
                                                                                        "output": "True"
                                                                                        },
                                                                                        {
                                                                                        "instruction": "True or False: A method in an abstract class can be both abstract and final.",
                                                                                        "input": "",
                                                                                        "output": "False"
                                                                                        },
                                                                                        {
                                                                                        "instruction": "True or False: Abstraction is a way to reduce complexity by only exposing essential features and hiding the rest.",
                                                                                        "input": "",
                                                                                        "output": "True"
                                                                                        },
                                                                                        {
                                                                                        "instruction": "True or False: Data abstraction can increase the flexibility of a system by allowing users to work with higher-level concepts.",
                                                                                        "input": "",
                                                                                        "output": "True"
                                                                                        },
                                                                                        {
                                                                                        "instruction": "True or False: An abstract class in Java must have at least one abstract method.",
                                                                                        "input": "",
                                                                                        "output": "False"
                                                                                        },
                                                                                        {
                                                                                        "instruction": "True or False: In Java, an abstract class can contain instance variables.",
                                                                                        "input": "",
                                                                                        "output": "True"
                                                                                        },
                                                                                        {
                                                                                            "instruction": "True or False: An interface can be used to define the structure of a class, but it cannot contain any method implementations.",
                                                                                            "input": "",
                                                                                            "output": "True"
                                                                                            },
                                                                                            {
                                                                                            "instruction": "True or False: In Java, a class that implements an interface must provide an implementation for all methods declared in the interface.",
                                                                                            "input": "",
                                                                                            "output": "True"
                                                                                            },
                                                                                            {
                                                                                            "instruction": "True or False: In Java, an abstract class can only have abstract methods and cannot have any concrete methods.",
                                                                                            "input": "",
                                                                                            "output": "False"
                                                                                            },
                                                                                            {
                                                                                            "instruction": "True or False: Data abstraction enables the user to interact with an object without needing to know its internal implementation details.",
                                                                                            "input": "",
                                                                                            "output": "True"
                                                                                            },
                                                                                            {
                                                                                            "instruction": "True or False: Abstraction is the process of making an object less complex by hiding unnecessary details and providing a simplified view.",
                                                                                            "input": "",
                                                                                            "output": "True"
                                                                                            },
                                                                                            {
                                                                                            "instruction": "True or False: The purpose of abstraction in object-oriented programming is to reduce code duplication.",
                                                                                            "input": "",
                                                                                            "output": "False"
                                                                                            },
                                                                                            {
                                                                                            "instruction": "True or False: A class can implement multiple interfaces, but it can only inherit from one abstract class in Java.",
                                                                                            "input": "",
                                                                                            "output": "True"
                                                                                            },
                                                                                            {
                                                                                            "instruction": "True or False: Abstraction is achieved in Java using abstract classes and interfaces.",
                                                                                            "input": "",
                                                                                            "output": "True"
                                                                                            },
                                                                                            {
                                                                                            "instruction": "True or False: Abstract classes in Java can have both static and instance methods.",
                                                                                            "input": "",
                                                                                            "output": "True"
                                                                                            },
                                                                                            {
                                                                                            "instruction": "True or False: An abstract class in Java can have multiple abstract methods, but it is not required to have any.",
                                                                                            "input": "",
                                                                                            "output": "False"
                                                                                            },
                                                                                            {
                                                                                                "instruction": "What is the main purpose of a hash table?",
                                                                                                "input": "A) To store data in a sorted order\nB) To store data with unique keys for efficient lookups\nC) To store data sequentially\nD) To store data in linked lists",
                                                                                                "output": "B"
                                                                                                },
                                                                                                {
                                                                                                "instruction": "What happens when two keys in a hash table have the same hash value?",
                                                                                                "input": "A) The second key overwrites the first one\nB) The keys are stored in a linked list at the same index\nC) The hash table automatically resizes\nD) The table throws an error",
                                                                                                "output": "B"
                                                                                                },
                                                                                                {
                                                                                                "instruction": "Which of the following is a characteristic of a hash table?",
                                                                                                "input": "A) It allows fast access to elements using keys\nB) It allows fast access to elements using indices\nC) It stores data in a sorted order\nD) It does not require hashing functions",
                                                                                                "output": "A"
                                                                                                },
                                                                                                {
                                                                                                "instruction": "What is the time complexity of accessing an element in a hash table in the average case?",
                                                                                                "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n^2)",
                                                                                                "output": "A"
                                                                                                },
                                                                                                {
                                                                                                "instruction": "What is the role of a hash function in a hash table?",
                                                                                                "input": "A) To sort the data\nB) To generate a unique index for each key\nC) To resolve collisions\nD) To store values in a sequential order",
                                                                                                "output": "B"
                                                                                                },
                                                                                                {
                                                                                                "instruction": "Which of the following hash table operations has a time complexity of O(1) in the average case?",
                                                                                                "input": "A) Insertion\nB) Deletion\nC) Searching\nD) All of the above",
                                                                                                "output": "D"
                                                                                                },
                                                                                                {
                                                                                                "instruction": "Which of the following is a method used to resolve hash collisions?",
                                                                                                "input": "A) Chaining\nB) Linear probing\nC) Quadratic probing\nD) All of the above",
                                                                                                "output": "D"
                                                                                                },
                                                                                                {
                                                                                                "instruction": "Which of the following is NOT a valid collision resolution technique for hash tables?",
                                                                                                "input": "A) Chaining\nB) Open addressing\nC) Bucket sort\nD) Linear probing",
                                                                                                "output": "C"
                                                                                                },
                                                                                                {
                                                                                                "instruction": "Which of the following scenarios would most likely cause a hash table to become inefficient?",
                                                                                                "input": "A) A good hash function\nB) Too many hash collisions\nC) Low load factor\nD) A dynamic resizing strategy",
                                                                                                "output": "B"
                                                                                                },
                                                                                                {
                                                                                                "instruction": "What is the primary advantage of using a hash table over an array?",
                                                                                                "input": "A) Faster insertion\nB) Faster searching\nC) Lower memory usage\nD) Sorted data",
                                                                                                "output": "B"
                                                                                                },
                                                                                                {
                                                                                                "instruction": "What is the time complexity of inserting an element into a hash table in the worst case?",
                                                                                                "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n^2)",
                                                                                                "output": "C"
                                                                                                },
                                                                                                {
                                                                                                "instruction": "In a hash table, what is a 'load factor'?",
                                                                                                "input": "A) The number of elements stored in the table\nB) The number of collisions occurring\nC) The ratio of elements to the size of the table\nD) The number of keys in the hash function",
                                                                                                "output": "C"
                                                                                                },
                                                                                                {
                                                                                                "instruction": "Which of the following is an example of a dynamic resizing strategy for hash tables?",
                                                                                                "input": "A) Doubling the size when the load factor exceeds a threshold\nB) Tripling the size when the load factor exceeds a threshold\nC) Shrinking the table when the load factor is too low\nD) Both A and C",
                                                                                                "output": "D"
                                                                                                },
                                                                                                {
                                                                                                "instruction": "What is the time complexity of deleting an element in a hash table in the worst case?",
                                                                                                "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n^2)",
                                                                                                "output": "C"
                                                                                                },
                                                                                                {
                                                                                                "instruction": "Which of the following is a disadvantage of using a hash table?",
                                                                                                "input": "A) It requires a hash function\nB) It is inefficient for storing sorted data\nC) It is always faster than other data structures\nD) It cannot store objects with multiple keys",
                                                                                                "output": "B"
                                                                                                },
                                                                                                {
                                                                                                "instruction": "What is 'open addressing' in the context of hash tables?",
                                                                                                "input": "A) A technique for chaining colliding elements\nB) A method to keep colliding elements in the same table\nC) A method to handle hash collisions by finding the next available slot\nD) A technique for creating separate hash tables for each key",
                                                                                                "output": "C"
                                                                                                },
                                                                                                {
                                                                                                "instruction": "In a hash table, what happens when the number of collisions increases?",
                                                                                                "input": "A) The table size increases\nB) The table becomes less efficient\nC) The hash function is changed\nD) The load factor decreases",
                                                                                                "output": "B"
                                                                                                },
                                                                                                {
                                                                                                "instruction": "Which of the following is NOT a property of a good hash function?",
                                                                                                "input": "A) It generates unique hash values for distinct keys\nB) It has a low probability of collisions\nC) It operates in constant time\nD) It produces predictable patterns",
                                                                                                "output": "D"
                                                                                                },
                                                                                                {
                                                                                                "instruction": "Which of the following is used in the chaining method of collision resolution in hash tables?",
                                                                                                "input": "A) Linked lists\nB) Arrays\nC) Stacks\nD) Heaps",
                                                                                                "output": "A"
                                                                                                },
                                                                                                {
                                                                                                    "instruction": "Which of the following is an advantage of using a hash table?",
                                                                                                    "input": "A) The ability to sort data\nB) The ability to search, insert, and delete elements in constant time on average\nC) The ability to store elements in a fixed order\nD) The ability to store duplicate keys",
                                                                                                    "output": "B"
                                                                                                    },
                                                                                                    {
                                                                                                    "instruction": "What is the worst-case time complexity for searching an element in a hash table when there are many collisions?",
                                                                                                    "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n^2)",
                                                                                                    "output": "C"
                                                                                                    },
                                                                                                    {
                                                                                                    "instruction": "What is the primary disadvantage of using chaining for collision resolution in hash tables?",
                                                                                                    "input": "A) It requires a larger amount of memory\nB) It does not allow for fast access\nC) It cannot be used with dynamic resizing\nD) It increases the risk of collisions",
                                                                                                    "output": "A"
                                                                                                    },
                                                                                                    {
                                                                                                    "instruction": "What does 'rehashing' mean in the context of hash tables?",
                                                                                                    "input": "A) Changing the hash function to accommodate more keys\nB) Doubling the size of the hash table and recalculating the index of each element\nC) Deleting elements from the hash table\nD) Sorting the keys in the hash table",
                                                                                                    "output": "B"
                                                                                                    },
                                                                                                    {
                                                                                                    "instruction": "What happens when the load factor of a hash table exceeds a certain threshold?",
                                                                                                    "input": "A) The table automatically resizes\nB) The table crashes\nC) The table reduces its size\nD) The table reorganizes elements",
                                                                                                    "output": "A"
                                                                                                    },
                                                                                                    {
                                                                                                    "instruction": "Which of the following methods can be used for collision resolution in hash tables?",
                                                                                                    "input": "A) Linear probing\nB) Chaining\nC) Quadratic probing\nD) All of the above",
                                                                                                    "output": "D"
                                                                                                    },
                                                                                                    {
                                                                                                    "instruction": "What is the main disadvantage of linear probing for collision resolution in hash tables?",
                                                                                                    "input": "A) It leads to clustering of keys\nB) It uses more memory\nC) It requires rehashing frequently\nD) It is slower than chaining",
                                                                                                    "output": "A"
                                                                                                    },
                                                                                                    {
                                                                                                    "instruction": "What is a characteristic of a hash table's underlying array?",
                                                                                                    "input": "A) It is always sorted\nB) It stores elements based on a hash value\nC) It does not resize automatically\nD) It does not support collisions",
                                                                                                    "output": "B"
                                                                                                    },
                                                                                                    {
                                                                                                    "instruction": "Which of the following is the most efficient way to handle hash collisions in a hash table?",
                                                                                                    "input": "A) Chaining with a linked list\nB) Chaining with a dynamic array\nC) Open addressing with linear probing\nD) Open addressing with quadratic probing",
                                                                                                    "output": "A"
                                                                                                    },
                                                                                                    {
                                                                                                    "instruction": "Which of the following will cause a hash table to experience poor performance?",
                                                                                                    "input": "A) A good hash function\nB) A high load factor\nC) A low number of collisions\nD) A dynamically resizing table",
                                                                                                    "output": "B"
                                                                                                    },
                                                                                                    {
                                                                                                    "instruction": "Which of the following operations has a time complexity of O(1) in a hash table, assuming no collisions?",
                                                                                                    "input": "A) Insertion\nB) Deletion\nC) Searching\nD) All of the above",
                                                                                                    "output": "D"
                                                                                                    },
                                                                                                    {
                                                                                                    "instruction": "What is the time complexity for finding an element in a hash table with an ideal hash function and no collisions?",
                                                                                                    "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n^2)",
                                                                                                    "output": "A"
                                                                                                    },
                                                                                                    {
                                                                                                    "instruction": "What happens when the hash table is resized due to the load factor exceeding a threshold?",
                                                                                                    "input": "A) The keys are redistributed across a new table with a larger size\nB) The keys are removed from the table\nC) The hash function is changed\nD) The table is rehashed into a smaller size",
                                                                                                    "output": "A"
                                                                                                    },
                                                                                                    {
                                                                                                    "instruction": "Which of the following is NOT a valid method for handling hash collisions?",
                                                                                                    "input": "A) Chaining\nB) Linear probing\nC) Quadratic probing\nD) Binning",
                                                                                                    "output": "D"
                                                                                                    },
                                                                                                    {
                                                                                                    "instruction": "Which of the following is true about hash tables?",
                                                                                                    "input": "A) Hash tables store elements based on the order they are inserted\nB) Hash tables do not support fast searching\nC) Hash tables store elements in a contiguous block of memory\nD) Hash tables do not support resizing",
                                                                                                    "output": "C"
                                                                                                    },
                                                                                                    {
                                                                                                    "instruction": "What is the effect of a bad hash function in a hash table?",
                                                                                                    "input": "A) It increases the number of collisions\nB) It reduces the memory usage\nC) It makes access to elements faster\nD) It does not affect the performance",
                                                                                                    "output": "A"
                                                                                                    },
                                                                                                    {
                                                                                                    "instruction": "What is the time complexity for inserting an element into a hash table in the worst case scenario (due to many collisions)?",
                                                                                                    "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n^2)",
                                                                                                    "output": "C"
                                                                                                    },
                                                                                                    {
                                                                                                    "instruction": "Which type of probing resolves collisions by checking subsequent slots in a specific sequence?",
                                                                                                    "input": "A) Linear probing\nB) Quadratic probing\nC) Double hashing\nD) Chaining",
                                                                                                    "output": "A"
                                                                                                    },
                                                                                                    {
                                                                                                    "instruction": "Which of the following statements about hash tables is false?",
                                                                                                    "input": "A) Hash tables provide O(1) average time complexity for search, insert, and delete operations\nB) Hash tables use a key-value mapping for storing elements\nC) A hash table is always sorted by the keys\nD) Hash tables require a hash function to map keys to indices",
                                                                                                    "output": "C"
                                                                                                    },
                                                                                                    {
                                                                                                        "instruction": "What is the main advantage of using a hash table for searching compared to other data structures like linked lists?",
                                                                                                        "input": "A) It stores data in a sorted order\nB) It provides O(1) average time complexity for searches\nC) It supports dynamic resizing\nD) It allows for fast searching by key index",
                                                                                                        "output": "B"
                                                                                                        },
                                                                                                        {
                                                                                                        "instruction": "Which of the following is true about open addressing in hash tables?",
                                                                                                        "input": "A) It resolves collisions by using an external data structure\nB) It stores all elements directly in the hash table\nC) It requires linked lists for chaining\nD) It stores elements in separate arrays",
                                                                                                        "output": "B"
                                                                                                        },
                                                                                                        {
                                                                                                        "instruction": "Which of the following hash table operations has the potential for O(n) time complexity?",
                                                                                                        "input": "A) Insert\nB) Delete\nC) Search\nD) All of the above in case of collisions",
                                                                                                        "output": "D"
                                                                                                        },
                                                                                                        {
                                                                                                        "instruction": "What is the best hash function for a hash table?",
                                                                                                        "input": "A) One that evenly distributes keys across the table\nB) One that generates unique values for every key\nC) One that sorts the keys\nD) One that uses a large prime number",
                                                                                                        "output": "A"
                                                                                                        },
                                                                                                        {
                                                                                                        "instruction": "What is a common drawback of using double hashing in hash tables?",
                                                                                                        "input": "A) It requires more memory\nB) It may lead to more collisions\nC) It requires two hash functions, which can be computationally expensive\nD) It does not support resizing",
                                                                                                        "output": "C"
                                                                                                        },
                                                                                                        {
                                                                                                        "instruction": "What is the time complexity for deleting an element in a hash table, assuming no collisions?",
                                                                                                        "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n^2)",
                                                                                                        "output": "A"
                                                                                                        },
                                                                                                        {
                                                                                                        "instruction": "Which of the following can lead to a hash table's performance degradation?",
                                                                                                        "input": "A) A low load factor\nB) A good hash function\nC) A high load factor\nD) Rehashing when the table is full",
                                                                                                        "output": "C"
                                                                                                        },
                                                                                                        {
                                                                                                        "instruction": "Which of the following is NOT a common method for resolving hash collisions?",
                                                                                                        "input": "A) Chaining\nB) Linear probing\nC) Quadratic probing\nD) Dynamic resizing",
                                                                                                        "output": "D"
                                                                                                        },
                                                                                                        {
                                                                                                        "instruction": "In a hash table, if two keys map to the same index, this is known as what?",
                                                                                                        "input": "A) A collision\nB) A hash overflow\nC) A key collision\nD) A hash collision resolution",
                                                                                                        "output": "A"
                                                                                                        },
                                                                                                        {
                                                                                                        "instruction": "Which of the following is NOT a benefit of using hash tables?",
                                                                                                        "input": "A) Efficient lookup time\nB) Support for complex queries\nC) Flexibility in storing various types of data\nD) Support for dynamic resizing",
                                                                                                        "output": "B"
                                                                                                        },
                                                                                                        {
                                                                                                        "instruction": "Which of the following best describes a hash table's 'load factor'?",
                                                                                                        "input": "A) The number of elements in the table divided by the table's capacity\nB) The total number of hash collisions that occur\nC) The average number of operations required for insertion\nD) The average number of keys in the hash table",
                                                                                                        "output": "A"
                                                                                                        },
                                                                                                        {
                                                                                                        "instruction": "What type of data structure is commonly used to implement the chaining method of collision resolution in hash tables?",
                                                                                                        "input": "A) Arrays\nB) Trees\nC) Linked lists\nD) Heaps",
                                                                                                        "output": "C"
                                                                                                        },
                                                                                                        {
                                                                                                        "instruction": "In hash tables, what is the effect of a high load factor?",
                                                                                                        "input": "A) It reduces memory usage\nB) It increases the likelihood of collisions\nC) It decreases the insertion time\nD) It reduces the time for searching an element",
                                                                                                        "output": "B"
                                                                                                        },
                                                                                                        {
                                                                                                        "instruction": "What is a common use case for hash tables in real-world applications?",
                                                                                                        "input": "A) Storing ordered data\nB) Implementing caching systems\nC) Sorting data\nD) Storing files in databases",
                                                                                                        "output": "B"
                                                                                                        },
                                                                                                        {
                                                                                                        "instruction": "Which of the following statements is true about hash tables?",
                                                                                                        "input": "A) Hash tables store elements in a sorted order\nB) Hash tables support fast lookups by key\nC) Hash tables always store elements in a fixed-size array\nD) Hash tables never suffer from collisions",
                                                                                                        "output": "B"
                                                                                                        },
                                                                                                        {
                                                                                                        "instruction": "Which of the following operations is typically performed when a hash table becomes too full?",
                                                                                                        "input": "A) Rehashing\nB) Sorting\nC) Shrinking\nD) Merging",
                                                                                                        "output": "A"
                                                                                                        },
                                                                                                        {
                                                                                                        "instruction": "What is one disadvantage of hash tables compared to binary search trees?",
                                                                                                        "input": "A) Hash tables have slower search times\nB) Hash tables require extra space for collision resolution\nC) Hash tables cannot handle large datasets\nD) Hash tables are not scalable",
                                                                                                        "output": "B"
                                                                                                        },
                                                                                                        {
                                                                                                        "instruction": "Which of the following is true about the time complexity of hash table operations?",
                                                                                                        "input": "A) The time complexity for insertion, deletion, and lookup is always O(n)\nB) The time complexity for insertion and deletion is O(1) in most cases\nC) The time complexity for lookup is always O(log n)\nD) The time complexity for all operations is constant",
                                                                                                        "output": "B"
                                                                                                        },
                                                                                                        {
                                                                                                        "instruction": "What factor can contribute to hash table collisions?",
                                                                                                        "input": "A) A bad hash function\nB) A high load factor\nC) Inserting too many elements\nD) All of the above",
                                                                                                        "output": "D"
                                                                                                        },
                                                                                                        {
                                                                                                            "instruction": "What is a potential problem when using a hash table with a poor hash function?",
                                                                                                            "input": "A) The table will become too small\nB) It may cause an uneven distribution of data, leading to collisions\nC) The keys will be sorted incorrectly\nD) The table will use too much memory",
                                                                                                            "output": "B"
                                                                                                            },
                                                                                                            {
                                                                                                            "instruction": "Which of the following best describes the process of rehashing in a hash table?",
                                                                                                            "input": "A) Doubling the size of the hash table and redistributing the elements\nB) Deleting all elements and resetting the table\nC) Adding more collision resolution methods\nD) Deleting the hash table and recreating it from scratch",
                                                                                                            "output": "A"
                                                                                                            },
                                                                                                            {
                                                                                                            "instruction": "What is the primary purpose of a hash function in a hash table?",
                                                                                                            "input": "A) To insert elements in a sorted order\nB) To generate unique keys for elements\nC) To map data to specific indices in the hash table\nD) To prevent hash collisions",
                                                                                                            "output": "C"
                                                                                                            },
                                                                                                            {
                                                                                                            "instruction": "What is a common characteristic of hash tables used for caching?",
                                                                                                            "input": "A) They do not support key-value pairs\nB) They are optimized for fast data retrieval\nC) They require expensive hash functions\nD) They store data in a sorted order",
                                                                                                            "output": "B"
                                                                                                            },
                                                                                                            {
                                                                                                            "instruction": "Which of the following can negatively affect the performance of a hash table?",
                                                                                                            "input": "A) Using a good hash function\nB) A high load factor\nC) A low number of collisions\nD) A small number of elements in the table",
                                                                                                            "output": "B"
                                                                                                            },
                                                                                                            {
                                                                                                            "instruction": "Which type of hashing technique uses a secondary hash function to resolve collisions?",
                                                                                                            "input": "A) Linear probing\nB) Quadratic probing\nC) Double hashing\nD) Chaining",
                                                                                                            "output": "C"
                                                                                                            },
                                                                                                            {
                                                                                                            "instruction": "What is the time complexity of searching for an element in a hash table with a good hash function and no collisions?",
                                                                                                            "input": "A) O(1)\nB) O(n)\nC) O(log n)\nD) O(n^2)",
                                                                                                            "output": "A"
                                                                                                            },
                                                                                                            {
                                                                                                            "instruction": "Which of the following hash table techniques is most suitable for handling a large number of collisions?",
                                                                                                            "input": "A) Open addressing\nB) Chaining\nC) Rehashing\nD) Linear probing",
                                                                                                            "output": "B"
                                                                                                            },
                                                                                                            {
                                                                                                            "instruction": "Which is NOT a disadvantage of hash tables?",
                                                                                                            "input": "A) Hash collisions\nB) Fixed table size\nC) Support for dynamic resizing\nD) Poor time complexity for search in case of high collisions",
                                                                                                            "output": "C"
                                                                                                            },
                                                                                                            {
                                                                                                            "instruction": "What is the result of applying a poor hash function to a hash table?",
                                                                                                            "input": "A) The keys are distributed evenly across the table\nB) There will be fewer collisions\nC) The time complexity of insertion will be reduced\nD) Collisions will be more frequent, leading to performance degradation",
                                                                                                            "output": "D"
                                                                                                            },
                                                                                                            {
                                                                                                            "instruction": "Which of the following is an example of open addressing in hash tables?",
                                                                                                            "input": "A) Using linked lists to store elements\nB) Storing elements at the next available slot in the table\nC) Storing elements in a separate array\nD) Using a hash table within another hash table",
                                                                                                            "output": "B"
                                                                                                            },
                                                                                                            {
                                                                                                            "instruction": "Which of the following statements about hash tables is correct?",
                                                                                                            "input": "A) Hash tables are faster than arrays for all operations\nB) Hash tables require more memory than arrays\nC) Hash tables are faster than linked lists for most operations\nD) Hash tables are slower than trees for all operations",
                                                                                                            "output": "C"
                                                                                                            },
                                                                                                            {
                                                                                                            "instruction": "In a hash table, what happens when the load factor exceeds a certain threshold?",
                                                                                                            "input": "A) The table resizes and rehashes the elements\nB) The table stores fewer elements\nC) The table becomes fixed in size\nD) The table fails to add new elements",
                                                                                                            "output": "A"
                                                                                                            },
                                                                                                            {
                                                                                                            "instruction": "In a hash table, if the hash function produces the same index for two different keys, this is known as what?",
                                                                                                            "input": "A) Hash collision\nB) Hash resolution\nC) Key conflict\nD) Hash redundancy",
                                                                                                            "output": "A"
                                                                                                            },
                                                                                                            {
                                                                                                            "instruction": "Which of the following is a correct example of quadratic probing in hash tables?",
                                                                                                            "input": "A) Searching for the next open slot using a linear function\nB) Using a fixed step size to find an open slot\nC) Using a secondary hash function to find an open slot\nD) Using a quadratic function to find an open slot after a collision",
                                                                                                            "output": "D"
                                                                                                            },
                                                                                                            {
                                                                                                            "instruction": "Which of the following is NOT a factor that affects the performance of a hash table?",
                                                                                                            "input": "A) The hash function\nB) The load factor\nC) The choice of collision resolution method\nD) The number of elements inserted",
                                                                                                            "output": "D"
                                                                                                            },
                                                                                                            {
                                                                                                            "instruction": "In a hash table, what happens when an element is inserted into a full table?",
                                                                                                            "input": "A) The table crashes\nB) The element is not inserted and an error occurs\nC) The table is resized and rehashed\nD) The element overwrites the first element",
                                                                                                            "output": "C"
                                                                                                            },
                                                                                                            {
                                                                                                            "instruction": "Which of the following best describes a hash table's performance when collisions are minimized?",
                                                                                                            "input": "A) The table's lookup time increases\nB) The table's lookup time is constant\nC) The table's lookup time is logarithmic\nD) The table's lookup time decreases exponentially",
                                                                                                            "output": "B"
                                                                                                            },
                {
                    "instruction": "What is a common method to avoid collisions in a hash table?",
                    "input": "A) Using a prime number for the table size\nB) Storing only unique keys\nC) Avoiding the use of a hash function\nD) Reducing the load factor",
                    "output": "A"
                    },
                    {
                    "instruction": "Which of the following can significantly improve the performance of a hash table?",
                    "input": "A) Using a complex hash function\nB) Ensuring the load factor stays below 0.5\nC) Storing data in sorted order\nD) Using a smaller hash table size",
                    "output": "B"
                    },
                    {
                    "instruction": "What is the purpose of a secondary hash function in double hashing?",
                    "input": "A) To compute the hash value of the key\nB) To resolve collisions by determining a new slot\nC) To increase the memory size of the table\nD) To shrink the table after resizing",
                    "output": "B"
                    },
                    {
                    "instruction": "Which hash table operation is O(1) in the average case with a good hash function?",
                    "input": "A) Insert\nB) Delete\nC) Lookup\nD) Rehash",
                    "output": "C"
                    },
                    {
                    "instruction": "In open addressing, what happens when a collision occurs?",
                    "input": "A) The element is stored at the next available index\nB) The element is stored in a linked list\nC) The element is stored at a random index\nD) The element is discarded",
                    "output": "A"
                    },
                    {
                    "instruction": "Which of the following is a key disadvantage of open addressing in hash tables?",
                    "input": "A) It increases the chance of clustering\nB) It requires more memory than chaining\nC) It reduces lookup performance\nD) It causes elements to be stored in linked lists",
                    "output": "A"
                    },
                    {
                    "instruction": "What happens when the load factor of a hash table exceeds a certain threshold?",
                    "input": "A) The hash table grows automatically\nB) The table stops accepting new elements\nC) The hash table shrinks\nD) The elements are rehashed",
                    "output": "D"
                    },
                    {
                    "instruction": "Which of the following best describes a perfect hash function?",
                    "input": "A) A hash function that never results in collisions\nB) A hash function that guarantees fast lookups\nC) A hash function that uses complex operations\nD) A hash function that uses prime numbers",
                    "output": "A"
                    },
                    {
                    "instruction": "In a hash table, what is a bucket?",
                    "input": "A) A memory slot for storing a hash value\nB) A slot that stores a key-value pair\nC) A secondary table for collision resolution\nD) A pointer to the next available index",
                    "output": "B"
                    },
                    {
                    "instruction": "Which of the following statements is true for hash tables?",
                    "input": "A) The hash function always produces unique hash codes\nB) The load factor affects the number of collisions\nC) Hash tables cannot handle null keys\nD) Hash tables can only store integer keys",
                    "output": "B"
                    },
                    {
                    "instruction": "What is one of the major drawbacks of chaining as a collision resolution technique in hash tables?",
                    "input": "A) Increased memory usage\nB) Reduced time complexity for lookups\nC) Difficulty in resizing the table\nD) The inability to use hash functions",
                    "output": "A"
                    },
                    {
                    "instruction": "Which of the following describes a hash collision?",
                    "input": "A) When two keys map to the same index in the hash table\nB) When a key is not found in the hash table\nC) When the table overflows\nD) When the load factor is too low",
                    "output": "A"
                    },
                    {
                    "instruction": "What is the average time complexity for searching in a hash table when collisions are rare?",
                    "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n^2)",
                    "output": "A"
                    },
                    {
                    "instruction": "In hash tables, what is rehashing?",
                    "input": "A) The process of finding a better hash function\nB) The process of resizing the table and redistributing elements\nC) The process of deleting elements from the table\nD) The process of storing elements in linked lists",
                    "output": "B"
                    },
                    {
                    "instruction": "Which of the following is an example of a hash table with open addressing?",
                    "input": "A) Hash map\nB) Hash set\nC) Hash table with chaining\nD) Hash table with linear probing",
                    "output": "D"
                    },
                    {
                    "instruction": "What is the purpose of a hash function in a hash table?",
                    "input": "A) To store data in sorted order\nB) To map keys to unique indices\nC) To detect collisions\nD) To calculate the load factor",
                    "output": "B"
                    },
                    {
                    "instruction": "Which of the following hash table operations is O(n) in the worst case?",
                    "input": "A) Insert\nB) Lookup\nC) Delete\nD) Resize",
                    "output": "D"
                    },
                    {
                    "instruction": "Which of the following is NOT a collision resolution technique in hash tables?",
                    "input": "A) Chaining\nB) Linear probing\nC) Rehashing\nD) Queueing",
                    "output": "D"
                    },
                    {
                        "instruction": "What is the average time complexity for inserting a new element into a hash table?",
                        "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n^2)",
                        "output": "A"
                        },
                        {
                        "instruction": "In which of the following cases would a hash table with open addressing perform poorly?",
                        "input": "A) When the load factor is high\nB) When the hash function is very simple\nC) When the number of keys is very low\nD) When there are no collisions",
                        "output": "A"
                        },
                        {
                        "instruction": "What does the term 'rehashing' refer to in hash tables?",
                        "input": "A) Redefining the hash function\nB) Changing the data type of the key\nC) Increasing the size of the table and redistributing the elements\nD) Deleting elements from the table",
                        "output": "C"
                        },
                        {
                        "instruction": "What is the main advantage of using chaining over open addressing in hash tables?",
                        "input": "A) It uses less memory\nB) It reduces the number of collisions\nC) It allows for dynamic resizing\nD) It handles high load factors better",
                        "output": "D"
                        },
                        {
                        "instruction": "What is a primary reason why hash tables are often faster than other data structures like arrays or linked lists?",
                        "input": "A) They store data in a sorted order\nB) They provide constant time complexity for most operations\nC) They use a linked list for collision resolution\nD) They store elements in a tree-like structure",
                        "output": "B"
                        },
                        {
                        "instruction": "In a hash table, if two different keys hash to the same index, this is known as:",
                        "input": "A) A collision\nB) A duplicate\nC) A miss\nD) A resize",
                        "output": "A"
                        },
                        {
                        "instruction": "Which of the following is a common use case for hash tables?",
                        "input": "A) Storing large datasets sequentially\nB) Performing quick lookups based on unique keys\nC) Sorting data in ascending order\nD) Traversing trees",
                        "output": "B"
                        },
                        {
                        "instruction": "In which scenario would quadratic probing be more advantageous than linear probing for collision resolution?",
                        "input": "A) When the hash table has a high load factor\nB) When the hash function is poor\nC) When we need to reduce clustering\nD) When the table size is very small",
                        "output": "C"
                        },
                        {
                        "instruction": "Which of the following hash table operations is NOT affected by the load factor?",
                        "input": "A) Insert\nB) Lookup\nC) Delete\nD) Rehash",
                        "output": "C"
                        },
                        {
                        "instruction": "Which of the following techniques is used to avoid collisions in a hash table?",
                        "input": "A) Linear probing\nB) Rehashing\nC) Using a different hash function\nD) All of the above",
                        "output": "D"
                        },
                        {
                        "instruction": "What happens when a hash table's load factor exceeds a certain threshold?",
                        "input": "A) The table resizes and the elements are redistributed\nB) The table is automatically deleted\nC) Collisions stop happening\nD) Insertions are no longer allowed",
                        "output": "A"
                        },
                        {
                        "instruction": "Which of the following is an example of an ideal situation for using a hash table?",
                        "input": "A) Storing ordered data\nB) Performing quick lookups based on a unique key\nC) Sorting elements in ascending order\nD) Traversing a list in a sequential manner",
                        "output": "B"
                        },
                        {
                        "instruction": "Which of the following factors affects the performance of a hash table the most?",
                        "input": "A) The quality of the hash function\nB) The size of the elements\nC) The type of collision resolution used\nD) The memory used by the hash table",
                        "output": "A"
                        },
                        {
                        "instruction": "Which of the following is the best hash function property for achieving minimal collisions?",
                        "input": "A) Uniform distribution of hash codes\nB) Complex mathematical calculations\nC) Returning the key value as the hash code\nD) Ensuring the key is always a prime number",
                        "output": "A"
                        },
                        {
                        "instruction": "In a hash table with chaining, what happens when two keys hash to the same index?",
                        "input": "A) The key-value pair is overwritten\nB) The second key is stored in a linked list at the same index\nC) The second key is ignored\nD) The table grows automatically",
                        "output": "B"
                        },
                        {
                        "instruction": "What is the maximum load factor for a hash table before performance degrades significantly?",
                        "input": "A) 0.1\nB) 0.5\nC) 0.7\nD) 1.0",
                        "output": "C"
                        },
                        {
                        "instruction": "What is a disadvantage of using double hashing for collision resolution in a hash table?",
                        "input": "A) It requires additional memory\nB) It requires a complex hash function\nC) It makes lookups slower\nD) It increases the chance of clustering",
                        "output": "B"
                        },
                        {
                        "instruction": "Which of the following is an ideal size for a hash table?",
                        "input": "A) A size that is a power of 2\nB) A size that is a prime number\nC) A size equal to the number of keys\nD) A size that is an even number",
                        "output": "B"
                        },
                        {
                        "instruction": "What happens when a hash table reaches its maximum load factor?",
                        "input": "A) It starts removing elements\nB) It begins resizing and redistributing elements\nC) It stops accepting new elements\nD) It ignores collisions",
                        "output": "B"
                        },
                    {
                        "instruction": "Which of the following is a disadvantage of using open addressing for collision resolution in hash tables?",
                        "input": "A) It increases the memory requirements\nB) It can result in clustering\nC) It makes insertions slower\nD) It requires additional memory for linked lists",
                        "output": "B"
                        },
                        {
                        "instruction": "Which of the following methods ensures that all keys are hashed to distinct indices in a hash table?",
                        "input": "A) Perfect hashing\nB) Double hashing\nC) Chaining\nD) Linear probing",
                        "output": "A"
                        },
                        {
                        "instruction": "In a hash table with open addressing, what is the typical action when a collision occurs?",
                        "input": "A) The key-value pair is discarded\nB) A new index is computed based on a collision resolution strategy\nC) The element is added to a linked list\nD) The table size is increased immediately",
                        "output": "B"
                        },
                        {
                        "instruction": "What is the purpose of the hash function in a hash table?",
                        "input": "A) To store the elements in sorted order\nB) To map keys to specific indices in the table\nC) To calculate the load factor\nD) To handle collisions",
                        "output": "B"
                        },
                        {
                        "instruction": "Which of the following strategies is most effective in reducing collisions in a hash table?",
                        "input": "A) Using a larger table size\nB) Using a prime number table size\nC) Using a non-linear hash function\nD) Increasing the number of keys",
                        "output": "B"
                        },
                        {
                        "instruction": "Which of the following best describes the concept of 'load factor' in a hash table?",
                        "input": "A) The number of empty slots in the table\nB) The ratio of the number of elements to the table size\nC) The number of collisions\nD) The number of slots available for insertion",
                        "output": "B"
                        },
                        {
                        "instruction": "What is the worst-case time complexity for searching in a hash table with open addressing and linear probing?",
                        "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n^2)",
                        "output": "C"
                        },
                        {
                        "instruction": "In which of the following cases would a hash table with chaining perform poorly?",
                        "input": "A) When the table is very large\nB) When the hash function is well-designed\nC) When there are too many collisions\nD) When the load factor is low",
                        "output": "C"
                        },
                        {
                        "instruction": "Which of the following is a common disadvantage of using hash tables?",
                        "input": "A) They require extra memory for pointers\nB) They cannot store large datasets\nC) Collisions can degrade performance\nD) They cannot perform deletion operations",
                        "output": "C"
                        },
                        {
                        "instruction": "What happens if the hash table size is too small in comparison to the number of keys?",
                        "input": "A) The table will automatically resize\nB) It will result in many collisions\nC) The performance will increase\nD) The hash function will adjust automatically",
                        "output": "B"
                        },
                        {
                        "instruction": "In a hash table, which of the following ensures that elements are evenly distributed across the table?",
                        "input": "A) A good hash function\nB) Rehashing\nC) Linear probing\nD) A small table size",
                        "output": "A"
                        },
                        {
                        "instruction": "Which of the following is true about hash tables with open addressing?",
                        "input": "A) They require less memory than those with chaining\nB) They handle collisions by using linked lists\nC) They can become inefficient when the load factor is high\nD) They perform better than chaining in all cases",
                        "output": "C"
                        },
                        {
                        "instruction": "What is the primary difference between a hash table and a binary search tree?",
                        "input": "A) A hash table stores data in sorted order, while a binary search tree does not\nB) A hash table uses a hash function to find the index, while a binary search tree uses comparisons\nC) A hash table uses a linked list for each key, while a binary search tree does not\nD) A binary search tree requires more memory than a hash table",
                        "output": "B"
                        },
                        {
                        "instruction": "Which of the following is true about rehashing in hash tables?",
                        "input": "A) It only happens when there are no collisions\nB) It involves increasing the size of the table and redistributing elements\nC) It reduces the performance of the hash table permanently\nD) It happens when the load factor is zero",
                        "output": "B"
                        },
                        {
                        "instruction": "Which of the following hash table techniques helps to resolve collisions by examining the next available slot in the array?",
                        "input": "A) Chaining\nB) Linear probing\nC) Quadratic probing\nD) Double hashing",
                        "output": "B"
                        },
                        {
                        "instruction": "What is the time complexity for deleting an element from a hash table using open addressing?",
                        "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n^2)",
                        "output": "A"
                        },
                        {
                        "instruction": "In a hash table, what is the ideal behavior when a key is inserted into an already filled slot during open addressing?",
                        "input": "A) The key is ignored\nB) The key overwrites the existing key\nC) The key is placed in the next available slot\nD) The table is resized immediately",
                        "output": "C"
                        },
                        {
                        "instruction": "Which of the following is an advantage of using hash tables over arrays?",
                        "input": "A) Faster insertion times\nB) Automatically sorted data\nC) Linear search for lookups\nD) Fixed table size",
                        "output": "A"
                        },
                        {
                        "instruction": "Which of the following is the main drawback of open addressing in hash tables?",
                        "input": "A) It requires more memory\nB) It can result in clustering\nC) It makes deletion operations slower\nD) It is harder to implement",
                        "output": "B"
                        },
                        {
                            "instruction": "What is the typical time complexity for accessing an element in a hash table using a hash function?",
                            "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n^2)",
                            "output": "A"
                            },
                            {
                            "instruction": "In the context of a hash table, what is the main purpose of using a 'hash function'?",
                            "input": "A) To store data in sorted order\nB) To avoid memory leaks\nC) To map keys to specific array indices\nD) To reduce memory usage",
                            "output": "C"
                            },
                            {
                            "instruction": "Which of the following scenarios is most likely to cause a hash table to perform poorly?",
                            "input": "A) Low load factor\nB) High load factor\nC) Use of a prime number table size\nD) Even distribution of keys",
                            "output": "B"
                            },
                            {
                            "instruction": "What is a common technique used to resolve collisions in a hash table?",
                            "input": "A) Rehashing\nB) Linear probing\nC) Chaining\nD) All of the above",
                            "output": "D"
                            },
                            {
                            "instruction": "What is the time complexity of rehashing a hash table when the load factor exceeds a certain threshold?",
                            "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n^2)",
                            "output": "C"
                            },
                            {
                            "instruction": "In a hash table, which technique uses a secondary hash function to handle collisions?",
                            "input": "A) Linear probing\nB) Quadratic probing\nC) Double hashing\nD) Chaining",
                            "output": "C"
                            },
                            {
                            "instruction": "Which of the following is an advantage of using chaining for collision resolution in hash tables?",
                            "input": "A) It is faster than open addressing\nB) It can handle high load factors well\nC) It requires less memory than open addressing\nD) It ensures no collisions",
                            "output": "B"
                            },
                            {
                            "instruction": "Which of the following is true about the performance of a hash table?",
                            "input": "A) Performance is always O(1) for all operations\nB) Performance can degrade to O(n) if too many collisions occur\nC) Performance is always O(log n)\nD) Performance is always O(n^2)",
                            "output": "B"
                            },
                            {
                            "instruction": "What is the result of inserting a key into a hash table with open addressing when the load factor is above 1?",
                            "input": "A) The key is inserted without any issues\nB) The table automatically resizes and the keys are rehashed\nC) The key is discarded\nD) The insertion operation takes O(n^2) time",
                            "output": "B"
                            },
                            {
                            "instruction": "What does the term 'clustering' refer to in the context of hash tables?",
                            "input": "A) Grouping similar keys together to improve performance\nB) A situation where a series of adjacent slots are filled due to collisions\nC) The process of resizing the table\nD) The distribution of keys across different indices",
                            "output": "B"
                            },
                            {
                            "instruction": "Which of the following hashing techniques can be used to avoid clustering in open addressing?",
                            "input": "A) Quadratic probing\nB) Linear probing\nC) Chaining\nD) Double hashing",
                            "output": "A"
                            },
                            {
                            "instruction": "Which of the following is true about resizing a hash table?",
                            "input": "A) The table size is halved when resizing\nB) The hash table must be resized each time a new element is inserted\nC) The table is resized when the load factor exceeds a certain threshold\nD) Resizing decreases the performance of the hash table permanently",
                            "output": "C"
                            },
                            {
                            "instruction": "Which of the following is the most significant drawback of using linear probing for collision resolution in a hash table?",
                            "input": "A) It can lead to clustering\nB) It requires more memory\nC) It is slower than other methods\nD) It does not handle collisions well",
                            "output": "A"
                            },
                            {
                            "instruction": "Which of the following is a key benefit of using a hash table over an array?",
                            "input": "A) Faster average time complexity for search operations\nB) Automatic sorting of elements\nC) Fixed size with no resizing\nD) All elements are stored contiguously in memory",
                            "output": "A"
                            },
                            {
                            "instruction": "What does the 'load factor' represent in a hash table?",
                            "input": "A) The number of keys currently stored in the hash table\nB) The number of empty slots in the hash table\nC) The ratio of the number of elements to the table size\nD) The average time complexity for operations",
                            "output": "C"
                            },
                            {
                            "instruction": "What is the worst-case time complexity for searching an element in a hash table with open addressing and quadratic probing?",
                            "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n^2)",
                            "output": "C"
                            },
                            {
                            "instruction": "Which of the following is true for a hash table using chaining?",
                            "input": "A) The hash table never suffers from clustering\nB) The elements are stored in a linked list at each index\nC) The elements are stored in a contiguous array\nD) Rehashing is not necessary",
                            "output": "B"
                            },
                            {
                            "instruction": "What does double hashing use to resolve collisions in a hash table?",
                            "input": "A) A secondary hash function\nB) A linked list at each index\nC) A fixed step size\nD) A random number generator",
                            "output": "A"
                            },
                            {
                            "instruction": "What happens if two keys produce the same index in a hash table?",
                            "input": "A) The second key overwrites the first key\nB) A collision occurs, and a collision resolution technique is used\nC) The hash table grows in size automatically\nD) The second key is ignored",
                            "output": "B"
                            },
                        {
                            "instruction": "Which of the following is the worst-case time complexity for insertion in a hash table with chaining?",
                            "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n^2)",
                            "output": "C"
                            },
                            {
                            "instruction": "In a hash table, which of the following is used to handle collisions by creating multiple linked lists at each index?",
                            "input": "A) Linear probing\nB) Quadratic probing\nC) Chaining\nD) Double hashing",
                            "output": "C"
                            },
                            {
                            "instruction": "Which of the following techniques helps in reducing collisions when using open addressing in hash tables?",
                            "input": "A) Chaining\nB) Rehashing\nC) Load factor increase\nD) Using prime number table sizes",
                            "output": "B"
                            },
                            {
                            "instruction": "What is a hash functions primary purpose in a hash table?",
                            "input": "A) To increase the size of the table\nB) To map data to a specific location\nC) To resolve collisions\nD) To improve load factor",
                            "output": "B"
                            },
                            {
                            "instruction": "Which of the following hash table operations typically takes O(1) time?",
                            "input": "A) Insertion\nB) Deletion\nC) Search\nD) All of the above",
                            "output": "D"
                            },
                            {
                            "instruction": "In a hash table with open addressing, which of the following probing methods uses a quadratic function to resolve collisions?",
                            "input": "A) Linear probing\nB) Quadratic probing\nC) Double hashing\nD) Chaining",
                            "output": "B"
                            },
                            {
                            "instruction": "Which of the following is a disadvantage of chaining in hash tables?",
                            "input": "A) Extra memory required for linked lists\nB) Increased time complexity\nC) Increased collision rates\nD) Slower search time",
                            "output": "A"
                            },
                            {
                            "instruction": "Which of the following properties are essential for a good hash function in hash tables?",
                            "input": "A) The function must be fast and produce a uniform distribution of keys\nB) The function must be complex and computationally expensive\nC) The function must always return the same index\nD) The function must handle collisions automatically",
                            "output": "A"
                            },
                            {
                            "instruction": "Which method is most commonly used to handle collisions in hash tables with open addressing?",
                            "input": "A) Chaining\nB) Linear probing\nC) Double hashing\nD) None of the above",
                            "output": "B"
                            },
                            {
                            "instruction": "What happens when the load factor of a hash table becomes too high?",
                            "input": "A) The hash table automatically rehashes\nB) Performance degrades, leading to more collisions\nC) The table size decreases\nD) Insertion becomes impossible",
                            "output": "B"
                            },
                            {
                            "instruction": "What is the average time complexity for searching an element in a well-distributed hash table with chaining?",
                            "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n^2)",
                            "output": "A"
                            },
                            {
                            "instruction": "What is the role of a secondary hash function in double hashing?",
                            "input": "A) To reduce clustering\nB) To speed up the primary hash function\nC) To resolve collisions more efficiently\nD) To guarantee no collisions",
                            "output": "C"
                            },
                            {
                            "instruction": "Which of the following is an advantage of open addressing over chaining in hash tables?",
                            "input": "A) It requires less memory\nB) It handles collisions more efficiently\nC) It uses linked lists\nD) It improves load factor",
                            "output": "A"
                            },
                            {
                            "instruction": "What is the time complexity of searching in a hash table that uses linear probing for collision resolution and has a high load factor?",
                            "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n^2)",
                            "output": "C"
                            },
                            {
                            "instruction": "What is the average time complexity of inserting an element in a hash table with chaining?",
                            "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n^2)",
                            "output": "A"
                            },
                            {
                            "instruction": "What is the main disadvantage of using linear probing in open addressing for collision resolution?",
                            "input": "A) It may cause clustering\nB) It is slower than other methods\nC) It requires more memory\nD) It does not resolve collisions",
                            "output": "A"
                            },
                            {
                            "instruction": "Which of the following is true about a hash table with a high load factor?",
                            "input": "A) It is more space-efficient\nB) It leads to fewer collisions\nC) It may cause longer probe sequences\nD) It requires fewer rehashing operations",
                            "output": "C"
                            },
                            {
                            "instruction": "Which of the following is true for double hashing in hash tables?",
                            "input": "A) It uses a secondary hash function to calculate probe sequence\nB) It requires a fixed step size\nC) It uses linked lists for collision resolution\nD) It is slower than linear probing",
                            "output": "A"
                            },
                            {
                            "instruction": "Which of the following is not typically a disadvantage of hash tables?",
                            "input": "A) It requires a complex hash function\nB) It may suffer from clustering\nC) It cannot be used to store large amounts of data\nD) It requires a fixed size",
                            "output": "C"
                            },
                            {
                            "instruction": "A __________ is used to map data to a specific location in a hash table.",
                            "input": "",
                            "output": "hash function"
                            },
                            {
                            "instruction": "In a hash table, collisions are resolved using techniques such as chaining or __________.",
                            "input": "",
                            "output": "open addressing"
                            },
                            {
                            "instruction": "The time complexity of searching in a well-distributed hash table with chaining is __________.",
                            "input": "",
                            "output": "O(1)"
                            },
                            {
                            "instruction": "In open addressing, when a collision occurs, the next available slot is found by methods such as linear probing or __________.",
                            "input": "",
                            "output": "quadratic probing"
                            },
                            {
                            "instruction": "The __________ property of a hash table ensures that it performs well even when the table is nearly full.",
                            "input": "",
                            "output": "load factor"
                            },
                            {
                            "instruction": "A good hash function ensures a uniform distribution of keys across the hash table, minimizing the chance of __________.",
                            "input": "",
                            "output": "collisions"
                            },
                            {
                            "instruction": "When using chaining to resolve collisions in a hash table, each table index points to a __________.",
                            "input": "",
                            "output": "linked list"
                            },
                            {
                            "instruction": "In a hash table with open addressing, the sequence of probes can be determined using a __________ function.",
                            "input": "",
                            "output": "secondary hash"
                            },
                            {
                            "instruction": "When the load factor of a hash table exceeds a certain threshold, the table is __________.",
                            "input": "",
                            "output": "rehased"
                            },
                            {
                            "instruction": "The average time complexity of inserting an element in a hash table with chaining is __________.",
                            "input": "",
                            "output": "O(1)"
                            },
                            {
                            "instruction": "In hash tables, __________ probing is used to find the next available slot by moving sequentially in a linear fashion.",
                            "input": "",
                            "output": "linear"
                            },
                            {
                            "instruction": "In the __________ method of collision resolution, each key is stored at an index and if there is a collision, the key is placed in the next available slot.",
                            "input": "",
                            "output": "open addressing"
                            },
                            {
                            "instruction": "In a hash table, the __________ is the number of elements stored in the table divided by the number of available slots.",
                            "input": "",
                            "output": "load factor"
                            },
                            {
                            "instruction": "The worst-case time complexity for searching in a hash table with open addressing is __________.",
                            "input": "",
                            "output": "O(n)"
                            },
                            {
                            "instruction": "A __________ hash function is one where the key is hashed to a table index, and if there is a collision, the next available slot is probed using a secondary hash function.",
                            "input": "",
                            "output": "double"
                            },
                            {
                            "instruction": "In a hash table, if the table is too full, it may lead to __________ where finding available slots becomes difficult.",
                            "input": "",
                            "output": "clustering"
                            },
                            {
                            "instruction": "The concept of __________ in hash tables involves adjusting the table size when the number of elements becomes too large or too small.",
                            "input": "",
                            "output": "rehashing"
                            },
                            {
                            "instruction": "In a hash table, the index at which a key is inserted is determined by applying a __________ function.",
                            "input": "",
                            "output": "hash"
                            },
                            {
                            "instruction": "The worst-case time complexity for inserting an element in a hash table with chaining is __________.",
                            "input": "",
                            "output": "O(n)"
                                },
                                {
                                "instruction": "When implementing a hash table, the performance of operations like search, insert, and delete can be significantly affected by the __________ of the hash function.",
                                "input": "",
                                "output": "quality"
                                },
                                {
                                "instruction": "The process of finding the next available slot in open addressing is called __________.",
                                "input": "",
                                "output": "probing"
                                },
                                {
                                "instruction": "In a hash table with linear probing, the sequence of slots checked is determined by adding a constant value to the current index. This is called __________.",
                                "input": "",
                                "output": "linear probing"
                                },
                                {
                                "instruction": "In a hash table, when two keys hash to the same index, it is called a __________.",
                                "input": "",
                                "output": "collision"
                                },
                                {
                                "instruction": "A hash table uses a __________ to map a key to an index in the table.",
                                "input": "",
                                "output": "hash function"
                                },
                                {
                                "instruction": "In a hash table, the process of resizing the table and redistributing the keys to new indices is called __________.",
                                "input": "",
                                "output": "rehashing"
                                },
                                {
                                "instruction": "The __________ method resolves hash table collisions by storing multiple elements at the same index, using a secondary data structure like a linked list.",
                                "input": "",
                                "output": "chaining"
                                },
                                {
                                "instruction": "When the load factor of a hash table exceeds a certain threshold, it may be necessary to __________ the table to accommodate more elements.",
                                "input": "",
                                "output": "rehash"
                                },
                                {
                                "instruction": "A __________ hash table uses a linked list to store multiple values at the same index in case of a collision.",
                                "input": "",
                                "output": "chained"
                                },
                                {
                                "instruction": "In a hash table with __________ addressing, elements are stored directly in the table, and collisions are resolved by finding an open slot.",
                                "input": "",
                                "output": "open"
                                },
                                {
                                "instruction": "The __________ value in a hash table indicates how full the table is and helps determine when rehashing is needed.",
                                "input": "",
                                "output": "load factor"
                                },
                                {
                                "instruction": "A __________ function in a hash table aims to produce a unique index for each key, but collisions may still occur.",
                                "input": "",
                                "output": "hash"
                                },
                                {
                                "instruction": "The worst-case time complexity for searching in a hash table with open addressing is __________.",
                                "input": "",
                                "output": "O(n)"
                                },
                                {
                                "instruction": "In hash tables, the __________ method of collision resolution uses multiple hash functions to minimize collisions.",
                                "input": "",
                                "output": "double hashing"
                                },
                                {
                                "instruction": "When keys are clustered in a hash table, the situation is known as __________, which may degrade the table's performance.",
                                "input": "",
                                "output": "clustering"
                                },
                                {
                                "instruction": "In a hash table, if a key hashes to an index that is already occupied, it is called a __________.",
                                "input": "",
                                "output": "collision"
                                },
                                {
                                "instruction": "The __________ property of a hash function ensures that it minimizes collisions and distributes keys evenly across the table.",
                                "input": "",
                                "output": "uniformity"
                                },
                                {
                                "instruction": "A __________ function is used in a hash table to map a key to a specific index in the table.",
                                "input": "",
                                "output": "hash"
                                },
                                {
                                "instruction": "In hash tables, __________ probing is used to find an open slot by incrementing the index based on a predefined step size.",
                                "input": "",
                                "output": "quadratic"
                                },
                                {
                                "instruction": "In a hash table, if a key hashes to an already occupied index, the next index is checked using a technique known as __________.",
                                "input": "",
                                "output": "probing"
                                },
                                {
                                "instruction": "In a hash table, when the table becomes too full, the performance of the operations __________.",
                                "input": "",
                                "output": "decreases"
                                },
                                {
                                "instruction": "In open addressing, when a collision occurs, the next slot to check is determined by a __________ function.",
                                "input": "",
                                "output": "probing"
                                },
                                {
                                "instruction": "A __________ hash table uses an array of linked lists to store multiple elements at the same index.",
                                "input": "",
                                "output": "chained"
                                },
                                {
                                "instruction": "In a hash table, when a key is inserted, its corresponding index is determined by applying a __________.",
                                "input": "",
                                "output": "hash function"
                                },
                                {
                                "instruction": "The __________ property of a hash function minimizes the chance of two keys mapping to the same index.",
                                "input": "",
                                "output": "uniformity"
                                },
                                {
                                "instruction": "The __________ time complexity of insertion in a hash table with chaining is O(1) in the average case.",
                                "input": "",
                                "output": "amortized"
                                },
                                {
                                "instruction": "The concept of __________ in hash tables helps in reducing collisions by distributing keys uniformly across the available slots.",
                                "input": "",
                                "output": "hashing"
                                },
                                {
                                "instruction": "In a hash table, the process of resizing and redistributing keys when the table becomes too full is called __________.",
                                "input": "",
                                "output": "rehashing"
                                },
                                {
                                "instruction": "A __________ hash function minimizes clustering and ensures a uniform distribution of keys across the hash table.",
                                "input": "",
                                "output": "good"
                                },
                                {
                                "instruction": "In a hash table, the average time complexity of a successful search is O(1) when the table is well-distributed, but it can be O(n) in the __________ case.",
                                "input": "",
                                "output": "worst"
                                },                                    
                                {
                                    "instruction": "In a hash table, a good hash function guarantees that all keys will hash to unique indices.",
                                    "input": "",
                                    "output": "False"
                                    },
                                    {
                                    "instruction": "In open addressing, when a collision occurs, the next index is determined by a fixed step size.",
                                    "input": "",
                                    "output": "True"
                                    },
                                    {
                                    "instruction": "Hash tables are always more efficient than arrays for searching elements.",
                                    "input": "",
                                    "output": "False"
                                    },
                                    {
                                    "instruction": "The time complexity for inserting an element into a hash table with chaining is always O(1).",
                                    "input": "",
                                    "output": "False"
                                    },
                                    {
                                    "instruction": "The load factor in a hash table determines when to resize the table.",
                                    "input": "",
                                    "output": "True"
                                    },
                                    {
                                    "instruction": "In a hash table, collisions can occur even with a perfect hash function.",
                                    "input": "",
                                    "output": "True"
                                    },
                                    {
                                    "instruction": "The worst-case time complexity for searching in a hash table with open addressing is O(1).",
                                    "input": "",
                                    "output": "False"
                                    },
                                    {
                                    "instruction": "Chaining is a method of resolving collisions in hash tables using a secondary data structure like a linked list.",
                                    "input": "",
                                    "output": "True"
                                    },
                                    {
                                    "instruction": "When a hash table becomes too full, its performance improves because there are fewer collisions.",
                                    "input": "",
                                    "output": "False"
                                    },
                                    {
                                    "instruction": "The primary disadvantage of using chaining to handle collisions is that it requires additional memory to store the linked lists.",
                                    "input": "",
                                    "output": "True"
                                    },
                                    {
                                    "instruction": "Rehashing is the process of resizing the hash table when the load factor exceeds a predefined threshold.",
                                    "input": "",
                                    "output": "True"
                                    },
                                    {
                                    "instruction": "In a hash table with double hashing, collisions are resolved by applying a second hash function to the key.",
                                    "input": "",
                                    "output": "True"
                                    },
                                    {
                                    "instruction": "The time complexity of deleting an element in a hash table is always O(1).",
                                    "input": "",
                                    "output": "False"
                                    },
                                    {
                                    "instruction": "Linear probing in open addressing involves checking the next index in a linear fashion when a collision occurs.",
                                    "input": "",
                                    "output": "True"
                                    },
                                    {
                                    "instruction": "The performance of a hash table is independent of the quality of the hash function used.",
                                    "input": "",
                                    "output": "False"
                                    },
                                    {
                                    "instruction": "Quadratic probing resolves collisions by checking indices that follow a quadratic sequence.",
                                    "input": "",
                                    "output": "True"
                                    },
                                    {
                                    "instruction": "In a hash table, if the hash function is poor, it can lead to clustering and degrade performance.",
                                    "input": "",
                                    "output": "True"
                                    },
                                    {
                                    "instruction": "If a hash table has a low load factor, it will experience more collisions.",
                                    "input": "",
                                    "output": "False"
                                    },
                                    {
                                    "instruction": "A hash table with a high load factor is more likely to need rehashing to maintain its performance.",
                                    "input": "",
                                    "output": "True"
                                    },
                                    {
                                    "instruction": "In a hash table, a collision occurs when two different keys map to the same index.",
                                    "input": "",
                                    "output": "True"
                                    },
                                {
                                    "instruction": "Hash tables can only be used with integer keys.",
                                    "input": "",
                                    "output": "False"
                                    },
                                    {
                                    "instruction": "The load factor in a hash table is the ratio of the number of elements to the total size of the table.",
                                    "input": "",
                                    "output": "True"
                                    },
                                    {
                                    "instruction": "A hash table with a large number of collisions will still have constant time complexity for search operations.",
                                    "input": "",
                                    "output": "False"
                                    },
                                    {
                                    "instruction": "In double hashing, the second hash function is applied to resolve collisions in the hash table.",
                                    "input": "",
                                    "output": "True"
                                    },
                                    {
                                    "instruction": "The performance of a hash table is improved if the table size is always a power of two.",
                                    "input": "",
                                    "output": "True"
                                    },
                                    {
                                    "instruction": "Chaining in hash tables eliminates collisions completely.",
                                    "input": "",
                                    "output": "False"
                                    },
                                    {
                                    "instruction": "In a hash table, the number of collisions is affected by the size of the table and the quality of the hash function.",
                                    "input": "",
                                    "output": "True"
                                    },
                                    {
                                    "instruction": "In a hash table, the worst-case time complexity for searching is O(n), which happens when all keys hash to the same index.",
                                    "input": "",
                                    "output": "True"
                                    },
                                    {
                                    "instruction": "A hash table guarantees O(1) time complexity for search operations if the table is well-maintained.",
                                    "input": "",
                                    "output": "True"
                                    },
                                    {
                                    "instruction": "Load factor and collisions are not related to the performance of a hash table.",
                                    "input": "",
                                    "output": "False"
                                    },
                                    {
                                    "instruction": "When the load factor exceeds 1, a hash table will begin to resize automatically to maintain efficiency.",
                                    "input": "",
                                    "output": "True"
                                    },
                                    {
                                    "instruction": "In hash tables, a primary concern is choosing an appropriate hash function that minimizes collisions.",
                                    "input": "",
                                    "output": "True"
                                    },
                                    {
                                    "instruction": "In a hash table, a linked list is used in the chaining method to store multiple elements at the same index.",
                                    "input": "",
                                    "output": "True"
                                    },
                                    {
                                    "instruction": "A well-designed hash function ensures that every key maps to a unique index in the table.",
                                    "input": "",
                                    "output": "False"
                                    },
                                    {
                                    "instruction": "In quadratic probing, the size of the step increases quadratically when a collision occurs.",
                                    "input": "",
                                    "output": "True"
                                    },
                                    {
                                    "instruction": "In a hash table, chaining uses extra memory to store linked lists but performs better in terms of collision resolution.",
                                    "input": "",
                                    "output": "True"
                                    },
                                    {
                                    "instruction": "The hash function used in a hash table must always return an integer value.",
                                    "input": "",
                                    "output": "False"
                                    },
                                    {
                                    "instruction": "The time complexity of a hash table search operation is O(1) in the best-case scenario when there are no collisions.",
                                    "input": "",
                                    "output": "True"
                                    },
                                    {
                                    "instruction": "Hash tables can only handle keys that are integers or strings.",
                                    "input": "",
                                    "output": "False"
                                    },
                                    {
                                    "instruction": "In a hash table, linear probing resolves collisions by checking subsequent positions in a linear fashion.",
                                    "input": "",
                                    "output": "True"
                                    },                                                                            
                                {
                                    "instruction": "Rehashing in a hash table is an expensive operation, but it is necessary when the load factor exceeds a threshold.",
                                    "input": "",
                                    "output": "True"
                                    },
                                    {
                                    "instruction": "In a hash table, if the number of collisions is too high, the hash table will slow down due to clustering.",
                                    "input": "",
                                    "output": "True"
                                    },
                                    {
                                    "instruction": "In open addressing, when a collision occurs, the next available slot is checked based on a predetermined probing sequence.",
                                    "input": "",
                                    "output": "True"
                                    },
                                    {
                                    "instruction": "Hash tables do not allow for duplicate keys.",
                                    "input": "",
                                    "output": "True"
                                    },
                                    {
                                    "instruction": "A poor hash function can cause a hash table to degenerate into a linked list, leading to O(n) time complexity for search operations.",
                                    "input": "",
                                    "output": "True"
                                    },
                                    {
                                    "instruction": "If a hash table has a high load factor, it will experience fewer collisions.",
                                    "input": "",
                                    "output": "False"
                                    },
                                    {
                                    "instruction": "In a hash table, each key must be hashed to the same index for efficient searching.",
                                    "input": "",
                                    "output": "False"
                                    },
                                    {
                                    "instruction": "The performance of a hash table can be significantly impacted by the distribution of keys and the quality of the hash function.",
                                    "input": "",
                                    "output": "True"
                                    },
                                    {
                                    "instruction": "Hash tables allow for both insertion and deletion of elements in constant time, O(1), in the best case.",
                                    "input": "",
                                    "output": "True"
                                    },
                                    {
                                    "instruction": "In a hash table, collisions are inevitable and can only be minimized, not eliminated.",
                                    "input": "",
                                    "output": "True"
                                    },
                                {
                                    "instruction": "What is the base case in a recursive function?",
                                    "input": "A. The part of the function where recursion is initiated\nB. The condition under which the function stops calling itself\nC. The point where the function calls itself\nD. None of the above",
                                    "output": "B"
                                    },
                                    {
                                    "instruction": "Which of the following is an essential characteristic of a recursive function?",
                                    "input": "A. It has a base case and recursive case\nB. It only has a base case\nC. It does not call itself\nD. None of the above",
                                    "output": "A"
                                    },
                                    {
                                    "instruction": "What happens if a recursive function does not have a base case?",
                                    "input": "A. It will stop after a few iterations\nB. It will result in a stack overflow\nC. It will never terminate\nD. Both B and C",
                                    "output": "D"
                                    },
                                    {
                                    "instruction": "Which of the following is an example of a recursive function?",
                                    "input": "A. A function that calculates the factorial of a number\nB. A function that adds two numbers\nC. A function that finds the maximum of two numbers\nD. None of the above",
                                    "output": "A"
                                    },
                                    {
                                    "instruction": "How does recursion work?",
                                    "input": "A. A function calls itself with different parameters until a base case is met\nB. A function uses loops to repeat itself\nC. A function stores its results in memory\nD. None of the above",
                                    "output": "A"
                                    },
                                    {
                                    "instruction": "In the recursive function `factorial(n) = n * factorial(n-1)`, what is the base case?",
                                    "input": "A. factorial(n) = 1\nB. factorial(n) = 0\nC. factorial(1) = 1\nD. factorial(n) = n",
                                    "output": "C"
                                    },
                                    {
                                    "instruction": "Which of the following problems can be solved using recursion?",
                                    "input": "A. Calculating Fibonacci numbers\nB. Finding the greatest common divisor (GCD) of two numbers\nC. Performing a binary search\nD. All of the above",
                                    "output": "D"
                                    },
                                    {
                                    "instruction": "What is the time complexity of a recursive function that divides the problem in half at each step (e.g., binary search)?",
                                    "input": "A. O(n)\nB. O(log n)\nC. O(n^2)\nD. O(1)",
                                    "output": "B"
                                    },
                                    {
                                    "instruction": "What does the term 'recursive depth' refer to in a recursive function?",
                                    "input": "A. The maximum number of recursive calls that occur before reaching the base case\nB. The number of parameters passed to the function\nC. The depth of the data structure being used\nD. None of the above",
                                    "output": "A"
                                    },
                                    {
                                    "instruction": "Which of the following can be a disadvantage of recursion?",
                                    "input": "A. It requires more memory due to the call stack\nB. It is always faster than iterative solutions\nC. It cannot be used in problem-solving\nD. None of the above",
                                    "output": "A"
                                    },
                                    {
                                    "instruction": "What is the purpose of the `return` statement in a recursive function?",
                                    "input": "A. To return a value to the calling function\nB. To end the function execution\nC. To make the recursion stop\nD. All of the above",
                                    "output": "D"
                                    },
                                    {
                                    "instruction": "In a recursive function, what happens after each recursive call?",
                                    "input": "A. The function waits for a return value from itself\nB. The function stops calling itself\nC. The function stores intermediate results\nD. The function starts another loop",
                                    "output": "A"
                                    },
                                    {
                                    "instruction": "Which of the following is a correct way to define a recursive function in Python?",
                                    "input": "A. `def func():` followed by `func()` inside the function\nB. `def func() {}` with a loop inside\nC. `function func() {}` with a return statement\nD. `def func():` without any recursive call",
                                    "output": "A"
                                    },
                                    {
                                    "instruction": "Which problem can be solved using tail recursion?",
                                    "input": "A. Calculating the factorial of a number\nB. Generating Fibonacci numbers\nC. Traversing a tree\nD. Both A and B",
                                    "output": "A"
                                    },
                                    {
                                    "instruction": "What is the difference between direct and indirect recursion?",
                                    "input": "A. Direct recursion calls itself, indirect recursion calls another function that eventually calls the original function\nB. Direct recursion calls another function, indirect recursion calls itself\nC. Direct recursion uses loops, indirect recursion does not\nD. None of the above",
                                    "output": "A"
                                    },
                                    {
                                    "instruction": "Which of the following recursive cases leads to a base case?",
                                    "input": "A. A recursive function that keeps calling itself with smaller arguments\nB. A recursive function that does not call itself\nC. A function that always calls the same parameter\nD. None of the above",
                                    "output": "A"
                                    },
                                    {
                                    "instruction": "What is the space complexity of a recursive function with a constant depth of recursion?",
                                    "input": "A. O(n)\nB. O(log n)\nC. O(1)\nD. O(n^2)",
                                    "output": "C"
                                    },
                                    {
                                    "instruction": "What is the result of this recursive function call: `factorial(0)`?",
                                    "input": "A. 1\nB. 0\nC. Undefined\nD. None of the above",
                                    "output": "A"
                                    },
                                    {
                                    "instruction": "Which of the following is true about recursion?",
                                    "input": "A. Recursion is always more efficient than iteration\nB. Recursion can lead to a stack overflow if not managed properly\nC. Recursion uses less memory than iteration\nD. Recursion does not require a base case",
                                    "output": "B"
                                    },
                                    {
                                    "instruction": "What happens in a recursive function when it reaches the base case?",
                                    "input": "A. The function calls itself again\nB. The function stops calling itself and returns a result\nC. The function enters an infinite loop\nD. The function returns `None`",
                                    "output": "B"
                                    },   
                                {
                                    "instruction": "Which of the following is an example of a recursive data structure?",
                                    "input": "A. Array\nB. Linked list\nC. Stack\nD. Tree",
                                    "output": "D"
                                    },
                                    {
                                    "instruction": "What is the time complexity of the recursive function `fib(n)` that calculates the nth Fibonacci number without memoization?",
                                    "input": "A. O(n)\nB. O(n^2)\nC. O(2^n)\nD. O(log n)",
                                    "output": "C"
                                    },
                                    {
                                    "instruction": "What is the primary benefit of using recursion over iteration?",
                                    "input": "A. It requires less memory\nB. It is easier to implement for certain problems\nC. It runs faster\nD. It does not need a base case",
                                    "output": "B"
                                    },
                                    {
                                    "instruction": "Which of the following best describes 'recursion depth'?",
                                    "input": "A. The number of times a function can be called before a return statement is executed\nB. The number of recursive calls made before reaching the base case\nC. The maximum number of function arguments used\nD. The time taken for recursion to reach the base case",
                                    "output": "B"
                                    },
                                    {
                                    "instruction": "What happens during a 'stack overflow' in recursion?",
                                    "input": "A. The program successfully exits the recursion\nB. The recursive calls exceed the system's stack limit\nC. The function runs infinitely without stopping\nD. None of the above",
                                    "output": "B"
                                    },
                                    {
                                    "instruction": "Which of the following functions can be used to implement a recursive solution?",
                                    "input": "A. Factorial calculation\nB. Binary search\nC. Tree traversal\nD. All of the above",
                                    "output": "D"
                                    },
                                    {
                                    "instruction": "What is the primary purpose of the base case in recursion?",
                                    "input": "A. To define the functions input\nB. To stop the function from calling itself\nC. To divide the problem into smaller subproblems\nD. To ensure the function runs indefinitely",
                                    "output": "B"
                                    },
                                    {
                                    "instruction": "How does the function call stack behave during recursion?",
                                    "input": "A. The calls are added to the stack and then removed when the base case is reached\nB. The stack only grows but never shrinks\nC. The stack never grows beyond the base case\nD. The stack is not affected by recursion",
                                    "output": "A"
                                    },
                                    {
                                    "instruction": "What is an example of a problem that cannot be efficiently solved with recursion?",
                                    "input": "A. Calculating factorial\nB. Finding the greatest common divisor (GCD)\nC. Counting the number of digits in a large number\nD. Sorting large datasets with many elements",
                                    "output": "D"
                                    },
                                    {
                                    "instruction": "What happens when recursion is applied in an inefficient manner, such as recalculating the same value multiple times?",
                                    "input": "A. The solution is optimized automatically\nB. The function performs unnecessary work, leading to inefficiency\nC. The base case is reached earlier\nD. It speeds up the execution",
                                    "output": "B"
                                    },
                                    {
                                    "instruction": "In which scenario is recursion considered more suitable than iteration?",
                                    "input": "A. When the problem requires simple loop constructs\nB. When the problem involves a naturally recursive data structure, such as trees\nC. When the problem can be solved in constant time\nD. None of the above",
                                    "output": "B"
                                    },
                                    {
                                    "instruction": "Which of the following is NOT an advantage of recursion?",
                                    "input": "A. It simplifies the code\nB. It can lead to a stack overflow in case of excessive recursion depth\nC. It avoids the need for loops\nD. It generally has higher time complexity than iteration",
                                    "output": "D"
                                    },
                                    {
                                    "instruction": "Which of the following is the correct way to stop infinite recursion?",
                                    "input": "A. By returning a value\nB. By using a base case that terminates the recursion\nC. By reducing the recursion depth\nD. By calling the recursion less frequently",
                                    "output": "B"
                                    },
                                    {
                                    "instruction": "How can recursion be more memory-intensive than iteration?",
                                    "input": "A. Because recursion uses function calls that consume memory on the call stack\nB. Because recursion uses loops that consume memory\nC. Because recursion stores intermediate results\nD. None of the above",
                                    "output": "A"
                                    },
                                    {
                                    "instruction": "In the recursive definition of the Fibonacci sequence, `fib(n) = fib(n-1) + fib(n-2)`, what is the base case?",
                                    "input": "A. fib(0) = 0, fib(1) = 1\nB. fib(0) = 1, fib(1) = 1\nC. fib(0) = 1, fib(1) = 0\nD. fib(n) = 0 for n < 0",
                                    "output": "A"
                                    },
                                    {
                                    "instruction": "How can recursion be optimized to avoid redundant calculations?",
                                    "input": "A. By using memoization\nB. By using a loop instead\nC. By increasing the recursion depth\nD. By calling the function more times",
                                    "output": "A"
                                    },
                                    {
                                    "instruction": "Which of the following statements is true regarding tail recursion?",
                                    "input": "A. The recursive call is the last operation performed in the function\nB. The function performs the recursive call before returning a result\nC. Tail recursion can be optimized by the compiler to avoid stack overflow\nD. All of the above",
                                    "output": "D"
                                    },
                                    {
                                    "instruction": "Which is true about direct and indirect recursion?",
                                    "input": "A. Direct recursion calls itself, while indirect recursion calls other functions that eventually call the original function\nB. Direct recursion uses loops, while indirect recursion does not\nC. Direct recursion is always slower than indirect recursion\nD. Indirect recursion is not allowed in programming languages",
                                    "output": "A"
                                    },
                                    {
                                    "instruction": "What is a major disadvantage of deep recursion in programming?",
                                    "input": "A. It improves performance\nB. It can lead to stack overflow if the recursion depth is too large\nC. It reduces the memory usage of the program\nD. It is faster than iterative solutions",
                                    "output": "B"
                                    },
                                    {
                                    "instruction": "Which of the following is an example of a recursive algorithm?",
                                    "input": "A. Merge sort\nB. Quick sort\nC. Binary search\nD. All of the above",
                                    "output": "D"
                                    },         
                                    {
                                        "instruction": "What is the base case for a recursive function that sums all elements in an array?",
                                        "input": "A. When the array is empty\nB. When the sum of the array is greater than 0\nC. When the array contains only one element\nD. When the sum is greater than the length of the array",
                                        "output": "A"
                                        },
                                        {
                                        "instruction": "Which of the following is a characteristic of recursive functions?",
                                        "input": "A. They always use iteration to solve problems\nB. They break a problem into smaller subproblems\nC. They avoid using a return statement\nD. They use global variables extensively",
                                        "output": "B"
                                        },
                                        {
                                        "instruction": "What does the recursion depth indicate in a recursive function?",
                                        "input": "A. The number of times the function has been called\nB. The number of recursive calls to reach the base case\nC. The amount of memory used by the function\nD. The time complexity of the function",
                                        "output": "B"
                                        },
                                        {
                                        "instruction": "Which of the following problems is best solved using recursion?",
                                        "input": "A. Finding the factorial of a number\nB. Calculating the sum of an array\nC. Traversing a tree data structure\nD. All of the above",
                                        "output": "D"
                                        },
                                        {
                                        "instruction": "What happens when recursion does not have a valid base case?",
                                        "input": "A. The recursion will eventually stop\nB. The program will run indefinitely, causing infinite recursion\nC. The program will execute faster\nD. The recursion will be optimized automatically",
                                        "output": "B"
                                        },
                                        {
                                        "instruction": "Which of the following is an example of a recursive function call?",
                                        "input": "A. Calling the same function within itself\nB. Calling a different function that does not call the original function\nC. Returning the same value without changing the parameters\nD. Using a for loop to iterate over a range of values",
                                        "output": "A"
                                        },
                                        {
                                        "instruction": "What is the result of an infinite recursion in a program?",
                                        "input": "A. The program will execute successfully\nB. The program will consume more memory and eventually crash due to stack overflow\nC. The program will optimize itself and run faster\nD. The recursion will automatically stop after a fixed number of calls",
                                        "output": "B"
                                        },
                                        {
                                        "instruction": "How can you improve the efficiency of a recursive function?",
                                        "input": "A. By using iteration instead\nB. By reducing the recursion depth\nC. By using memoization or dynamic programming\nD. By removing the base case",
                                        "output": "C"
                                        },
                                        {
                                        "instruction": "Which of the following problems can be solved using recursion?",
                                        "input": "A. Factorial calculation\nB. Tree traversal\nC. Fibonacci sequence calculation\nD. All of the above",
                                        "output": "D"
                                        },
                                        {
                                        "instruction": "What is tail recursion?",
                                        "input": "A. Recursion where the last operation is a recursive call\nB. Recursion that uses a while loop to optimize the function calls\nC. Recursion with an extra return statement to simplify the function\nD. Recursion where the recursive function calls itself multiple times in a row",
                                        "output": "A"
                                        },
                                        {
                                        "instruction": "Which of the following is a disadvantage of recursion?",
                                        "input": "A. Recursion can lead to more readable code\nB. Recursion may use more memory due to function calls on the call stack\nC. Recursion is always faster than iteration\nD. Recursion always avoids the use of loops",
                                        "output": "B"
                                        },
                                        {
                                        "instruction": "What does the `return` statement in a recursive function typically do?",
                                        "input": "A. It stops the recursion at the base case\nB. It begins the recursion from the beginning\nC. It counts the number of recursive calls\nD. It calculates the final result after all recursive calls",
                                        "output": "A"
                                        },
                                        {
                                        "instruction": "Which of the following examples will cause infinite recursion?",
                                        "input": "A. A recursive function with a base case\nB. A recursive function without a base case\nC. A recursive function that calls itself only once\nD. A function that calls another function to handle recursion",
                                        "output": "B"
                                        },
                                        {
                                        "instruction": "In recursive functions, what happens when the base case is reached?",
                                        "input": "A. The function calls itself again\nB. The function terminates and returns a value\nC. The function continues to call itself indefinitely\nD. The function resets the recursion depth to 0",
                                        "output": "B"
                                        },
                                        {
                                        "instruction": "What is a common use case for recursion in computer science?",
                                        "input": "A. To handle iterative loops more efficiently\nB. To traverse tree structures like binary trees\nC. To optimize memory usage\nD. To avoid using algorithms",
                                        "output": "B"
                                        },
                                        {
                                        "instruction": "Which of the following is the main reason to use recursion?",
                                        "input": "A. To simplify problems that can be broken down into smaller subproblems\nB. To increase the memory usage\nC. To handle simple loops\nD. To avoid using arrays",
                                        "output": "A"
                                        },
                                        {
                                        "instruction": "What is the purpose of memoization in recursion?",
                                        "input": "A. To allow the function to call itself multiple times\nB. To store intermediate results and avoid redundant calculations\nC. To prevent recursion from ever reaching the base case\nD. To reduce the overall time complexity of the recursion",
                                        "output": "B"
                                        },
                                        {
                                        "instruction": "What would happen if a recursive function doesn't reduce its problem size towards the base case?",
                                        "input": "A. The function will run forever\nB. The function will reach the base case immediately\nC. The function will execute faster\nD. The function will crash due to insufficient memory",
                                        "output": "A"
                                        },
                                        {
                                        "instruction": "In the recursive solution for the factorial of `n`, what is the base case?",
                                        "input": "A. `n = 1`\nB. `n = 0`\nC. `n = 2`\nD. `n < 0`",
                                        "output": "B"
                                        },
                                        {
                                            "instruction": "Which of the following is true about recursion in algorithms?",
                                            "input": "A. Recursion is always more efficient than iteration\nB. Recursion reduces code readability\nC. Recursion can be used to solve problems that can be broken down into smaller, similar problems\nD. Recursion is faster than dynamic programming",
                                            "output": "C"
                                            },
                                            {
                                            "instruction": "What is the primary advantage of using recursion in problem-solving?",
                                            "input": "A. It uses less memory than iteration\nB. It makes code more readable by simplifying complex problems\nC. It eliminates the need for loops\nD. It is always more efficient than iteration",
                                            "output": "B"
                                            },
                                            {
                                            "instruction": "In a recursive function, what is the role of the return value?",
                                            "input": "A. It marks the end of the recursion\nB. It combines results from recursive calls to compute the final value\nC. It counts the number of function calls\nD. It stores intermediate results for later use",
                                            "output": "B"
                                            },
                                            {
                                            "instruction": "What happens when a recursive function is called without a base case?",
                                            "input": "A. The recursion stops after a fixed number of calls\nB. The function calls itself indefinitely, causing a stack overflow\nC. The function will always return a result\nD. The program will execute faster",
                                            "output": "B"
                                            },
                                            {
                                            "instruction": "Which of the following is a disadvantage of recursion?",
                                            "input": "A. It consumes less memory than iteration\nB. It can lead to stack overflow if the recursion depth is too large\nC. It is always easier to debug than iterative solutions\nD. It requires fewer lines of code than iteration",
                                            "output": "B"
                                            },
                                            {
                                            "instruction": "What does a recursive function use to remember its state across calls?",
                                            "input": "A. A global variable\nB. A local variable\nC. The function call stack\nD. A static array",
                                            "output": "C"
                                            },
                                            {
                                            "instruction": "Which of the following statements is true about tail recursion?",
                                            "input": "A. It is recursion that happens after the recursive call\nB. It helps in optimizing memory usage by eliminating the function call stack\nC. It only applies to functions with a single recursive call\nD. It is slower than non-tail recursion",
                                            "output": "B"
                                            },
                                            {
                                            "instruction": "Which problem is most commonly solved using recursion?",
                                            "input": "A. Linear search in an array\nB. Traversing a tree structure\nC. Sorting an array using QuickSort\nD. Both B and C",
                                            "output": "D"
                                            },
                                            {
                                            "instruction": "How does recursion affect the time complexity of an algorithm?",
                                            "input": "A. It always increases the time complexity\nB. It always decreases the time complexity\nC. It can reduce the time complexity when combined with memoization\nD. It does not affect the time complexity",
                                            "output": "C"
                                            },
                                            {
                                            "instruction": "In the Fibonacci sequence, which of the following recursive calls is made?",
                                            "input": "A. F(n) = F(n-1) + F(n-2)\nB. F(n) = F(n+1) + F(n+2)\nC. F(n) = F(n-1) * F(n-2)\nD. F(n) = F(n-1) / F(n-2)",
                                            "output": "A"
                                            },
                                            {
                                            "instruction": "Which of the following is a typical use of recursion in a programming problem?",
                                            "input": "A. Finding the maximum number in an array\nB. Reversing a string\nC. Traversing a binary tree\nD. Sorting an array using bubble sort",
                                            "output": "C"
                                            },
                                            {
                                            "instruction": "What is the time complexity of a recursive function that splits a problem into two subproblems, each of size n/2?",
                                            "input": "A. O(n)\nB. O(n log n)\nC. O(log n)\nD. O(n^2)",
                                            "output": "B"
                                            },
                                            {
                                            "instruction": "Which of the following techniques is used to improve the performance of recursive functions that involve repeated subproblem computations?",
                                            "input": "A. Tail recursion\nB. Memoization\nC. Iteration\nD. Recursion depth limiting",
                                            "output": "B"
                                            },
                                            {
                                            "instruction": "In recursion, what is the effect of reaching the base case?",
                                            "input": "A. The function will call itself again\nB. The recursion will terminate and return the final result\nC. The function will be skipped\nD. The recursion depth will be reset to 0",
                                            "output": "B"
                                            },
                                            {
                                            "instruction": "Which of the following recursive algorithms is used to solve the Tower of Hanoi problem?",
                                            "input": "A. Merge sort\nB. Depth-first search\nC. Recursive algorithm for moving disks between rods\nD. Dijkstras algorithm",
                                            "output": "C"
                                            },
                                            {
                                            "instruction": "Which of the following statements about recursion is correct?",
                                            "input": "A. Recursion always uses less memory than iteration\nB. Recursive functions do not require a base case\nC. Recursive functions always have a higher time complexity than their iterative counterparts\nD. Recursive functions are useful for breaking down problems into smaller subproblems",
                                            "output": "D"
                                            },
                                            {
                                            "instruction": "What is the main reason for using recursion instead of iteration?",
                                            "input": "A. Recursion is always faster\nB. Recursion allows complex problems to be expressed in simpler, smaller steps\nC. Recursion avoids using memory\nD. Recursion requires less time to compute",
                                            "output": "B"
                                            },
                                            {
                                            "instruction": "How can you prevent stack overflow in recursive functions?",
                                            "input": "A. By increasing the recursion depth\nB. By ensuring that the base case is reached in each recursive call\nC. By removing the return statement\nD. By using iteration instead of recursion",
                                            "output": "B"
                                            },
                                            {
                                            "instruction": "A recursive function must have a(n) __________ to avoid infinite recursion.",
                                            "input": "",
                                            "output": "base case"
                                            },
                                            {
                                            "instruction": "The __________ function in recursion is responsible for reducing the problem's size with each recursive call.",
                                            "input": "",
                                            "output": "recursive case"
                                            },
                                            {
                                            "instruction": "In recursion, the __________ helps to prevent infinite recursion by providing a stopping condition.",
                                            "input": "",
                                            "output": "base case"
                                            },
                                            {
                                            "instruction": "In a tail-recursive function, the recursive call is the __________ operation performed before returning the result.",
                                            "input": "",
                                            "output": "last"
                                            },
                                            {
                                            "instruction": "Each recursive call in a function occupies space in the __________.",
                                            "input": "",
                                            "output": "stack"
                                            },
                                            {
                                            "instruction": "A __________ function calls itself indirectly through another function.",
                                            "input": "",
                                            "output": "mutual recursive"
                                            },
                                            {
                                            "instruction": "The time complexity of a recursive algorithm is determined by the number of __________ in each recursive call.",
                                            "input": "",
                                            "output": "subproblems"
                                            },
                                            {
                                            "instruction": "In the Fibonacci sequence, a naive recursive implementation has an exponential time complexity of __________.",
                                            "input": "",
                                            "output": "O(2^n)"
                                            },
                                            {
                                            "instruction": "A __________ is used in dynamic programming to store results of subproblems and avoid redundant calculations in recursion.",
                                            "input": "",
                                            "output": "memoization"
                                            },
                                            {
                                            "instruction": "The __________ is a commonly used data structure that helps manage the state of recursive calls in a program.",
                                            "input": "",
                                            "output": "stack"
                                            },
                                            {
                                            "instruction": "In recursion, a __________ reduces the problem to a simpler or smaller problem at each step.",
                                            "input": "",
                                            "output": "recursive case"
                                            },
                                            {
                                            "instruction": "A recursive function that does not reduce the problem size or reaches the base case will lead to a __________.",
                                            "input": "",
                                            "output": "stack overflow"
                                            },
                                            {
                                            "instruction": "The recursive function calls itself on a smaller subset of the original problem and typically solves the problem by combining the results, a technique called __________.",
                                            "input": "",
                                            "output": "divide and conquer"
                                            },
                                            {
                                            "instruction": "In recursion, when the problem becomes simple enough to solve directly, we call it the __________.",
                                            "input": "",
                                            "output": "base case"
                                            },
                                            {
                                            "instruction": "When solving a problem recursively, the problem is typically divided into __________ that can be solved recursively.",
                                            "input": "",
                                            "output": "subproblems"
                                            },
                                            {
                                            "instruction": "Recursion is often used to solve problems involving data structures like __________, where elements are organized hierarchically.",
                                            "input": "",
                                            "output": "trees"
                                            },
                                            {
                                            "instruction": "In recursion, if the base case is not defined correctly, the program will run into a __________.",
                                            "input": "",
                                            "output": "stack overflow"
                                            },
                                            {
                                            "instruction": "In tail recursion, the function makes the recursive call as its __________ operation.",
                                            "input": "",
                                            "output": "last"
                                            },
                                            {
                                            "instruction": "Recursion can be used in algorithms like __________ sort and merge sort.",
                                            "input": "",
                                            "output": "quick"
                                            },
                                            {
                                            "instruction": "The recursive algorithm that divides a problem into smaller subproblems and solves them recursively is called the __________ technique.",
                                            "input": "",
                                            "output": "divide and conquer"
                                            },
                                        {
                                            "instruction": "A recursive function must have a(n) __________ to avoid infinite recursion.",
                                            "input": "",
                                            "output": "base case"
                                            },
                                            {
                                            "instruction": "The __________ function in recursion is responsible for reducing the problem's size with each recursive call.",
                                            "input": "",
                                            "output": "recursive case"
                                            },
                                            {
                                            "instruction": "In recursion, the __________ helps to prevent infinite recursion by providing a stopping condition.",
                                            "input": "",
                                            "output": "base case"
                                            },
                                            {
                                            "instruction": "In a tail-recursive function, the recursive call is the __________ operation performed before returning the result.",
                                            "input": "",
                                            "output": "last"
                                            },
                                            {
                                            "instruction": "Each recursive call in a function occupies space in the __________.",
                                            "input": "",
                                            "output": "stack"
                                            },
                                            {
                                            "instruction": "A __________ function calls itself indirectly through another function.",
                                            "input": "",
                                            "output": "mutual recursive"
                                            },
                                            {
                                            "instruction": "The time complexity of a recursive algorithm is determined by the number of __________ in each recursive call.",
                                            "input": "",
                                            "output": "subproblems"
                                            },
                                            {
                                            "instruction": "In the Fibonacci sequence, a naive recursive implementation has an exponential time complexity of __________.",
                                            "input": "",
                                            "output": "O(2^n)"
                                            },
                                            {
                                            "instruction": "A __________ is used in dynamic programming to store results of subproblems and avoid redundant calculations in recursion.",
                                            "input": "",
                                            "output": "memoization"
                                            },
                                            {
                                            "instruction": "The __________ is a commonly used data structure that helps manage the state of recursive calls in a program.",
                                            "input": "",
                                            "output": "stack"
                                            },
                                            {
                                            "instruction": "In recursion, a __________ reduces the problem to a simpler or smaller problem at each step.",
                                            "input": "",
                                            "output": "recursive case"
                                            },
                                            {
                                            "instruction": "A recursive function that does not reduce the problem size or reaches the base case will lead to a __________.",
                                            "input": "",
                                            "output": "stack overflow"
                                            },
                                            {
                                            "instruction": "The recursive function calls itself on a smaller subset of the original problem and typically solves the problem by combining the results, a technique called __________.",
                                            "input": "",
                                            "output": "divide and conquer"
                                            },
                                            {
                                            "instruction": "In recursion, when the problem becomes simple enough to solve directly, we call it the __________.",
                                            "input": "",
                                            "output": "base case"
                                            },
                                            {
                                            "instruction": "When solving a problem recursively, the problem is typically divided into __________ that can be solved recursively.",
                                            "input": "",
                                            "output": "subproblems"
                                            },
                                            {
                                            "instruction": "Recursion is often used to solve problems involving data structures like __________, where elements are organized hierarchically.",
                                            "input": "",
                                            "output": "trees"
                                            },
                                            {
                                            "instruction": "In recursion, if the base case is not defined correctly, the program will run into a __________.",
                                            "input": "",
                                            "output": "stack overflow"
                                            },
                                            {
                                            "instruction": "In tail recursion, the function makes the recursive call as its __________ operation.",
                                            "input": "",
                                            "output": "last"
                                            },
                                            {
                                            "instruction": "Recursion can be used in algorithms like __________ sort and merge sort.",
                                            "input": "",
                                            "output": "quick"
                                            },
                                            {
                                            "instruction": "The recursive algorithm that divides a problem into smaller subproblems and solves them recursively is called the __________ technique.",
                                            "input": "",
                                            "output": "divide and conquer"
                                            },
                                            {
                                                "instruction": "The __________ is a process of solving a problem by breaking it down into smaller subproblems of the same type.",
                                                "input": "",
                                                "output": "recursion"
                                                },
                                                {
                                                "instruction": "In recursion, a function that calls itself is referred to as a __________ function.",
                                                "input": "",
                                                "output": "recursive"
                                                },
                                                {
                                                "instruction": "When a recursive function has no valid stopping condition, it will result in a __________.",
                                                "input": "",
                                                "output": "stack overflow"
                                                },
                                                {
                                                "instruction": "The recursive approach is less efficient for solving problems that have overlapping subproblems, which can be avoided by using __________.",
                                                "input": "",
                                                "output": "memoization"
                                                },
                                                {
                                                "instruction": "Recursion can be classified into two types: __________ and tail recursion.",
                                                "input": "",
                                                "output": "normal"
                                                },
                                                {
                                                "instruction": "In a recursive function, the __________ part handles the reduction of the problem's size with each recursive call.",
                                                "input": "",
                                                "output": "recursive case"
                                                },
                                                {
                                                "instruction": "The number of recursive calls made in a recursion tree is represented by the __________ of the tree.",
                                                "input": "",
                                                "output": "height"
                                                },
                                                {
                                                "instruction": "The __________ of a recursive algorithm refers to the time it takes to solve the problem for all recursive calls.",
                                                "input": "",
                                                "output": "time complexity"
                                                },
                                                {
                                                "instruction": "In recursion, the __________ is reached when the function has completed its task and begins to return the result.",
                                                "input": "",
                                                "output": "base case"
                                                },
                                                {
                                                "instruction": "Recursion can be used to solve problems such as __________ traversal of a binary tree.",
                                                "input": "",
                                                "output": "preorder"
                                                },
                                                {
                                                "instruction": "In a recursive function, the __________ is the step that makes the recursive call to the function.",
                                                "input": "",
                                                "output": "recursive case"
                                                },
                                                {
                                                "instruction": "A recursive function needs a __________ to break the recursion and avoid infinite loops.",
                                                "input": "",
                                                "output": "base case"
                                                },
                                                {
                                                "instruction": "The time complexity of a recursive algorithm can often be improved by using __________, where previously computed results are stored for reuse.",
                                                "input": "",
                                                "output": "memoization"
                                                },
                                                {
                                                "instruction": "In a recursive function, the __________ represents the condition that causes the function to stop calling itself.",
                                                "input": "",
                                                "output": "base case"
                                                },
                                                {
                                                "instruction": "A recursive function can be optimized to an iterative one using the concept of __________ recursion.",
                                                "input": "",
                                                "output": "tail"
                                                },
                                                {
                                                "instruction": "The process of reducing a large problem into smaller, similar subproblems in recursion is called __________.",
                                                "input": "",
                                                "output": "problem decomposition"
                                                },
                                                {
                                                "instruction": "The maximum depth of recursive calls in a function is directly related to the __________ of the problem being solved.",
                                                "input": "",
                                                "output": "size"
                                                },
                                                {
                                                "instruction": "In a recursive algorithm, the number of recursive calls needed to solve the problem is called the __________ of recursion.",
                                                "input": "",
                                                "output": "depth"
                                                },
                                                {
                                                "instruction": "A recursive function is generally easier to implement for problems that have a natural __________ structure.",
                                                "input": "",
                                                "output": "hierarchical"
                                                },
                                                {
                                                "instruction": "In recursive problems, the intermediate results are often stored in a(n) __________ to avoid recomputing them multiple times.",
                                                "input": "",
                                                "output": "cache"
                                                },
                                                {
                                                    "instruction": "A recursive function can call itself indefinitely without a base case.",
                                                    "input": "",
                                                    "output": "False"
                                                    },
                                                    {
                                                    "instruction": "In recursion, the base case is used to break the infinite loop of function calls.",
                                                    "input": "",
                                                    "output": "True"
                                                    },
                                                    {
                                                    "instruction": "Recursive functions are always more efficient than iterative ones.",
                                                    "input": "",
                                                    "output": "False"
                                                    },
                                                    {
                                                    "instruction": "In tail recursion, the recursive call is the last operation in the function before returning a value.",
                                                    "input": "",
                                                    "output": "True"
                                                    },
                                                    {
                                                    "instruction": "Recursion can be used to solve problems like factorial, Fibonacci series, and tree traversals.",
                                                    "input": "",
                                                    "output": "True"
                                                    },
                                                    {
                                                    "instruction": "In a recursive function, the recursive case is where the problem is reduced to a simpler version of itself.",
                                                    "input": "",
                                                    "output": "True"
                                                    },
                                                    {
                                                    "instruction": "Recursive functions do not use the call stack for keeping track of function calls.",
                                                    "input": "",
                                                    "output": "False"
                                                    },
                                                    {
                                                    "instruction": "A function that calls itself directly is known as mutual recursion.",
                                                    "input": "",
                                                    "output": "False"
                                                    },
                                                    {
                                                    "instruction": "Stack overflow occurs in recursion if the function doesn't reach a base case or if too many recursive calls are made.",
                                                    "input": "",
                                                    "output": "True"
                                                    },
                                                    {
                                                    "instruction": "In recursion, a base case is optional, but without one, the function will still terminate correctly.",
                                                    "input": "",
                                                    "output": "False"
                                                    },
                                                    {
                                                    "instruction": "Recursive functions can sometimes be optimized by converting them into iterative ones.",
                                                    "input": "",
                                                    "output": "True"
                                                    },
                                                    {
                                                    "instruction": "Tail recursion is a special form of recursion that does not use additional stack space.",
                                                    "input": "",
                                                    "output": "True"
                                                    },
                                                    {
                                                    "instruction": "Recursion is always more space-efficient than iteration.",
                                                    "input": "",
                                                    "output": "False"
                                                    },
                                                    {
                                                    "instruction": "In recursion, the recursive case is responsible for reducing the problem size at each step.",
                                                    "input": "",
                                                    "output": "True"
                                                    },
                                                    {
                                                    "instruction": "Recursion always reduces the time complexity of an algorithm.",
                                                    "input": "",
                                                    "output": "False"
                                                    },
                                                    {
                                                    "instruction": "The depth of recursion in a function is directly related to the size of the problem being solved.",
                                                    "input": "",
                                                    "output": "True"
                                                    },
                                                    {
                                                    "instruction": "Recursion is a technique used only for problems that can be divided into smaller subproblems of the same type.",
                                                    "input": "",
                                                    "output": "True"
                                                    },
                                                    {
                                                    "instruction": "A recursive function cannot be optimized using dynamic programming techniques like memoization.",
                                                    "input": "",
                                                    "output": "False"
                                                    },
                                                    {
                                                    "instruction": "Recursion can be used to implement algorithms like quicksort and mergesort.",
                                                    "input": "",
                                                    "output": "True"
                                                    },
                                                    {
                                                    "instruction": "Recursive functions in most programming languages require more memory due to the call stack used during function calls.",
                                                    "input": "",
                                                    "output": "True"
                                                    },
                                            {
                                                "instruction": "A recursive function can be replaced by a loop if the problem can be solved iteratively.",
                                                "input": "",
                                                "output": "True"
                                                },
                                                {
                                                "instruction": "Every recursive problem has a base case and a recursive case.",
                                                "input": "",
                                                "output": "True"
                                                },
                                                {
                                                "instruction": "The recursive case always involves calling the function with the same parameters as the original call.",
                                                "input": "",
                                                "output": "False"
                                                },
                                                {
                                                "instruction": "Recursive algorithms are typically easier to understand than iterative ones for problems with a clear recursive structure.",
                                                "input": "",
                                                "output": "True"
                                                },
                                                {
                                                "instruction": "When solving a problem recursively, each recursive call must always make progress towards the base case.",
                                                "input": "",
                                                "output": "True"
                                                },
                                                {
                                                "instruction": "Recursive algorithms can sometimes be more difficult to debug than iterative algorithms due to multiple function calls.",
                                                "input": "",
                                                "output": "True"
                                                },
                                                {
                                                "instruction": "The time complexity of recursive algorithms is always easier to analyze than that of iterative algorithms.",
                                                "input": "",
                                                "output": "False"
                                                },
                                                {
                                                "instruction": "Recursive calls can be made even if the function does not modify its arguments.",
                                                "input": "",
                                                "output": "True"
                                                },
                                                {
                                                "instruction": "In recursion, the problem is broken down into smaller subproblems that can be solved using the same method.",
                                                "input": "",
                                                "output": "True"
                                                },
                                                {
                                                "instruction": "Recursive functions are generally more memory-efficient than iterative solutions.",
                                                "input": "",
                                                "output": "False"
                                                },
                                                {
                                                "instruction": "The process of recursion will automatically return the correct solution if the base case is not reached.",
                                                "input": "",
                                                "output": "False"
                                                },
                                                {
                                                "instruction": "Every recursive function must use a base case to prevent infinite recursion.",
                                                "input": "",
                                                "output": "True"
                                                },
                                                {
                                                "instruction": "Recursion always results in better performance than iteration due to its compact nature.",
                                                "input": "",
                                                "output": "False"
                                                },
                                                {
                                                "instruction": "Tail recursion is the most efficient form of recursion since it does not require additional stack frames.",
                                                "input": "",
                                                "output": "True"
                                                },
                                                {
                                                "instruction": "A recursive function can be written in an iterative form using explicit stacks or queues.",
                                                "input": "",
                                                "output": "True"
                                                },
                                                {
                                                "instruction": "Recursive solutions are more useful for problems that involve hierarchical data structures, like trees.",
                                                "input": "",
                                                "output": "True"
                                                },
                                                {
                                                "instruction": "Recursive calls are automatically optimized by the compiler in most programming languages.",
                                                "input": "",
                                                "output": "False"
                                                },
                                                {
                                                "instruction": "A recursive function should not modify global variables to avoid unnecessary complexity.",
                                                "input": "",
                                                "output": "True"
                                                },
                                                {
                                                "instruction": "Recursion does not require a base case when solving problems involving simple iterations.",
                                                "input": "",
                                                "output": "False"
                                                },
                                                {
                                                "instruction": "The depth of recursion refers to the number of times the function calls itself before reaching the base case.",
                                                "input": "",
                                                "output": "True"
                                                },
                                                {
                                                    "instruction": "What is the purpose of the try block in exception handling?",
                                                    "input": "A) To define the code that might throw an exception\nB) To catch the exceptions\nC) To handle the exception\nD) To terminate the program",
                                                    "output": "A"
                                                    },
                                                    {
                                                    "instruction": "Which of the following statements is true about exceptions?",
                                                    "input": "A) Exceptions are handled automatically without the need for try-catch blocks\nB) Exceptions need to be caught and handled explicitly\nC) Exceptions can only be handled by the system\nD) Exceptions cannot be propagated outside a method",
                                                    "output": "B"
                                                    },
                                                    {
                                                    "instruction": "What is the use of the 'finally' block in exception handling?",
                                                    "input": "A) To execute code before throwing an exception\nB) To execute code only when an exception occurs\nC) To execute code regardless of whether an exception occurs or not\nD) To catch the exception",
                                                    "output": "C"
                                                    },
                                                    {
                                                    "instruction": "Which of the following exceptions is checked at compile time?",
                                                    "input": "A) RuntimeException\nB) NullPointerException\nC) IOException\nD) ArithmeticException",
                                                    "output": "C"
                                                    },
                                                    {
                                                    "instruction": "Which method is used to throw an exception in Java?",
                                                    "input": "A) throw()\nB) throw\nC) exception()\nD) raises()",
                                                    "output": "B"
                                                    },
                                                    {
                                                    "instruction": "Which of the following is an unchecked exception in Java?",
                                                    "input": "A) IOException\nB) SQLException\nC) ArrayIndexOutOfBoundsException\nD) FileNotFoundException",
                                                    "output": "C"
                                                    },
                                                    {
                                                    "instruction": "What happens when an exception is thrown but not caught?",
                                                    "input": "A) The program continues execution without any problem\nB) The program crashes immediately\nC) The program throws another exception\nD) The exception is logged automatically",
                                                    "output": "B"
                                                    },
                                                    {
                                                    "instruction": "Which of the following keywords is used to handle exceptions in Java?",
                                                    "input": "A) catch\nB) throw\nC) throws\nD) handle",
                                                    "output": "A"
                                                    },
                                                    {
                                                    "instruction": "Which exception is thrown when a program attempts to divide by zero in Java?",
                                                    "input": "A) ArithmeticException\nB) NullPointerException\nC) IllegalArgumentException\nD) NumberFormatException",
                                                    "output": "A"
                                                    },
                                                    {
                                                    "instruction": "Which of the following is true about the 'throw' keyword in Java?",
                                                    "input": "A) It is used to declare an exception\nB) It is used to catch an exception\nC) It is used to handle multiple exceptions\nD) It is used to explicitly throw an exception",
                                                    "output": "D"
                                                    },
                                                    {
                                                    "instruction": "What does the 'throws' keyword indicate in method declaration?",
                                                    "input": "A) The method will throw an exception\nB) The method will handle the exception\nC) The method will catch all exceptions\nD) The method will terminate the program if an exception occurs",
                                                    "output": "A"
                                                    },
                                                    {
                                                    "instruction": "Which of the following is the correct syntax for catching multiple exceptions in a single catch block?",
                                                    "input": "A) catch (IOException | ArithmeticException e)\nB) catch(IOException && ArithmeticException e)\nC) catch(IOException, ArithmeticException e)\nD) catch (IOException | ArithmeticException) e",
                                                    "output": "A"
                                                    },
                                                    {
                                                    "instruction": "Which of the following is the superclass of all exceptions in Java?",
                                                    "input": "A) Error\nB) Throwable\nC) Exception\nD) Object",
                                                    "output": "B"
                                                    },
                                                    {
                                                    "instruction": "What is the default behavior of an exception handler if no catch block is provided?",
                                                    "input": "A) It terminates the program without any message\nB) It sends an error message to the user\nC) It throws the exception to the method caller\nD) It handles the exception automatically",
                                                    "output": "C"
                                                    },
                                                    {
                                                    "instruction": "What is the result of this code snippet: 'throw new Exception(\"Error\");'?",
                                                    "input": "A) An exception is thrown and the program continues execution\nB) An exception is thrown and the program terminates\nC) An exception is thrown but not caught\nD) The code will compile but not run",
                                                    "output": "B"
                                                    },
                                                    {
                                                    "instruction": "Which exception class is the root class of all checked exceptions?",
                                                    "input": "A) Exception\nB) RuntimeException\nC) Throwable\nD) Error",
                                                    "output": "A"
                                                    },
                                                    {
                                                    "instruction": "In Java, what type of exceptions can be caught by the catch block?",
                                                    "input": "A) Only checked exceptions\nB) Only unchecked exceptions\nC) Both checked and unchecked exceptions\nD) No exceptions can be caught",
                                                    "output": "C"
                                                    },
                                                    {
                                                    "instruction": "Which statement about exceptions in Java is false?",
                                                    "input": "A) All exceptions are objects of classes derived from the Throwable class\nB) Every exception must be caught or declared in the method signature\nC) The throw keyword is used to catch exceptions\nD) Exceptions in Java can be propagated through method calls",
                                                    "output": "C"
                                                    },
                                                    {
                                                    "instruction": "What is the best practice for exception handling in Java?",
                                                    "input": "A) Catch all exceptions using a generic catch block\nB) Only catch checked exceptions\nC) Catch only specific exceptions\nD) Use multiple catch blocks for every type of exception",
                                                    "output": "C"
                                                    },
                                                    {
                                                    "instruction": "Which of the following is not a valid exception handler type in Java?",
                                                    "input": "A) catch\nB) try\nC) handle\nD) finally",
                                                    "output": "C"
                                                    },
                                        {
                                            "instruction": "What is the correct way to catch multiple exceptions using multiple catch blocks?",
                                            "input": "A) catch (IOException | SQLException e)\nB) catch (IOException) catch (SQLException)\nC) catch (IOException, SQLException) e\nD) catch (IOException & SQLException) e",
                                            "output": "B"
                                            },
                                            {
                                            "instruction": "What is the effect of catching the exception type Throwable?",
                                            "input": "A) It catches all exceptions and errors\nB) It only catches runtime exceptions\nC) It only catches checked exceptions\nD) It does not catch any exceptions",
                                            "output": "A"
                                            },
                                            {
                                            "instruction": "What happens when an exception is thrown in a method with no catch block?",
                                            "input": "A) The program catches the exception automatically\nB) The program stops and exits\nC) The exception is propagated to the caller\nD) The exception is logged and ignored",
                                            "output": "C"
                                            },
                                            {
                                            "instruction": "Which of the following is used to define an exception class in Java?",
                                            "input": "A) Extending the Throwable class\nB) Extending the Error class\nC) Extending the Exception class\nD) Extending the RuntimeException class",
                                            "output": "C"
                                            },
                                            {
                                            "instruction": "Which exception is thrown when trying to access an array index out of bounds?",
                                            "input": "A) NullPointerException\nB) IndexOutOfBoundsException\nC) ArithmeticException\nD) ClassCastException",
                                            "output": "B"
                                            },
                                            {
                                            "instruction": "Which of the following is not a valid exception handler in Java?",
                                            "input": "A) try\nB) catch\nC) finally\nD) handle",
                                            "output": "D"
                                            },
                                            {
                                            "instruction": "How do you rethrow an exception in Java?",
                                            "input": "A) Using the throw keyword\nB) Using the return keyword\nC) Using the catch block\nD) Using the throws keyword",
                                            "output": "A"
                                            },
                                            {
                                            "instruction": "Which statement is used to define an exception in Java?",
                                            "input": "A) throw\nB) throws\nC) try\nD) catch",
                                            "output": "B"
                                            },
                                            {
                                            "instruction": "Which exception occurs when a program attempts to access an invalid memory location?",
                                            "input": "A) IllegalArgumentException\nB) NullPointerException\nC) AccessViolationException\nD) ArrayIndexOutOfBoundsException",
                                            "output": "B"
                                            },
                                            {
                                            "instruction": "What happens when the exception is thrown and not caught in Java?",
                                            "input": "A) It gets automatically logged\nB) It causes the program to terminate\nC) It is propagated up to the caller method\nD) The program continues executing",
                                            "output": "C"
                                            },
                                            {
                                            "instruction": "What is the main difference between 'throw' and 'throws' in exception handling?",
                                            "input": "A) throw is used in method declaration, throws is used to throw an exception\nB) throw is used to catch exceptions, throws is used to throw exceptions\nC) throw is used to throw exceptions, throws is used to declare exceptions\nD) There is no difference",
                                            "output": "C"
                                            },
                                            {
                                            "instruction": "What will happen if an exception is thrown within the 'finally' block?",
                                            "input": "A) It will terminate the program immediately\nB) It will propagate the exception to the caller\nC) It will be ignored by Java\nD) The exception thrown in 'finally' will replace the original exception",
                                            "output": "D"
                                            },
                                            {
                                            "instruction": "What type of exception is an ArithmeticException in Java?",
                                            "input": "A) Checked exception\nB) Unchecked exception\nC) Runtime exception\nD) Error",
                                            "output": "B"
                                            },
                                            {
                                            "instruction": "Which of the following exceptions can be handled by the 'throws' keyword?",
                                            "input": "A) Unchecked exceptions\nB) Errors\nC) Checked exceptions\nD) Runtime exceptions",
                                            "output": "C"
                                            },
                                            {
                                            "instruction": "In the following code snippet, what is the role of 'finally' block?\n\ntry { throw new Exception(); } catch (Exception e) { System.out.println(\"Caught\"); } finally { System.out.println(\"Finally\"); }",
                                            "input": "A) It will never execute\nB) It will execute regardless of whether an exception occurs\nC) It will execute only if an exception is caught\nD) It will execute only if there is no exception",
                                            "output": "B"
                                            },
                                            {
                                            "instruction": "What is the correct way to handle multiple exceptions in a single catch block?",
                                            "input": "A) catch (IOException | SQLException e)\nB) catch (IOException & SQLException e)\nC) catch (IOException, SQLException e)\nD) catch (IOException, SQLException)",
                                            "output": "A"
                                            },
                                            {
                                            "instruction": "What exception is thrown if you attempt to convert a string to a number but the string does not represent a valid number?",
                                            "input": "A) NumberFormatException\nB) ArithmeticException\nC) IllegalArgumentException\nD) TypeError",
                                            "output": "A"
                                            },
                                            {
                                            "instruction": "What happens if a 'return' statement is executed before the 'finally' block?",
                                            "input": "A) The 'finally' block will not execute\nB) The 'finally' block will execute first, then the 'return' statement\nC) The 'finally' block will execute after the 'return' statement\nD) The program will stop immediately",
                                            "output": "C"
                                            },
                                            {
                                            "instruction": "Which of the following is a common cause of a 'NullPointerException' in Java?",
                                            "input": "A) Trying to access an element of an array that does not exist\nB) Trying to access a method of a null object\nC) Trying to open a file that doesn't exist\nD) Dividing by zero",
                                            "output": "B"
                                            },
                                        {
                                            "instruction": "Which of the following exceptions is a subclass of RuntimeException?",
                                            "input": "A) IOException\nB) ArithmeticException\nC) InterruptedException\nD) SQLException",
                                            "output": "B"
                                            },
                                            {
                                            "instruction": "What is the default exception handler when an uncaught exception occurs in Java?",
                                            "input": "A) The JVM terminates the program\nB) The catch block catches the exception\nC) The exception is logged\nD) The exception is passed to the 'finally' block",
                                            "output": "A"
                                            },
                                            {
                                            "instruction": "Which of the following statements is true about the 'throws' keyword?",
                                            "input": "A) It is used to throw an exception from a method\nB) It is used to specify which exceptions a method can throw\nC) It is used to catch exceptions\nD) It is used to handle errors",
                                            "output": "B"
                                            },
                                            {
                                            "instruction": "Which statement is correct about 'finally' blocks?",
                                            "input": "A) It is executed only if there is an exception\nB) It is executed only when there is no exception\nC) It is executed regardless of whether an exception occurs\nD) It cannot contain a return statement",
                                            "output": "C"
                                            },
                                            {
                                            "instruction": "What does the exception 'ClassNotFoundException' signify?",
                                            "input": "A) Class cannot be found during runtime\nB) Class does not exist in the project\nC) Class cannot be loaded during the program's execution\nD) Class does not have a constructor",
                                            "output": "C"
                                            },
                                            {
                                            "instruction": "Which of the following is a checked exception?",
                                            "input": "A) NullPointerException\nB) IOException\nC) ArithmeticException\nD) ArrayIndexOutOfBoundsException",
                                            "output": "B"
                                            },
                                            {
                                            "instruction": "Which of the following is used to create a custom exception in Java?",
                                            "input": "A) Extending the Exception class\nB) Implementing the Throwable interface\nC) Implementing the Error interface\nD) Extending the Throwable class",
                                            "output": "A"
                                            },
                                            {
                                            "instruction": "What happens when an exception occurs inside the 'finally' block?",
                                            "input": "A) The exception is ignored and the program continues\nB) The program stops execution immediately\nC) The original exception is overridden by the exception in 'finally'\nD) The exception in 'finally' is logged but does not stop execution",
                                            "output": "C"
                                            },
                                            {
                                            "instruction": "What will happen if you throw an exception from a method that is not declared with 'throws'?",
                                            "input": "A) The program will compile but the exception will not be caught\nB) The compiler will generate an error\nC) The exception will be ignored\nD) The method will be executed without throwing the exception",
                                            "output": "B"
                                            },
                                            {
                                            "instruction": "Which of the following is an unchecked exception?",
                                            "input": "A) IOException\nB) ArithmeticException\nC) ClassNotFoundException\nD) SQLException",
                                            "output": "B"
                                            },
                                            {
                                            "instruction": "Which method is used to print the stack trace of an exception?",
                                            "input": "A) printStackTrace()\nB) getStackTrace()\nC) logStackTrace()\nD) displayStackTrace()",
                                            "output": "A"
                                            },
                                            {
                                            "instruction": "What is the purpose of the 'catch' block in Java?",
                                            "input": "A) To define the exception type\nB) To log the exception\nC) To handle the exception\nD) To define the code that causes the exception",
                                            "output": "C"
                                            },
                                            {
                                            "instruction": "What does the 'throw' keyword do?",
                                            "input": "A) It is used to declare an exception\nB) It is used to handle an exception\nC) It is used to throw an exception explicitly\nD) It is used to catch an exception",
                                            "output": "C"
                                            },
                                            {
                                            "instruction": "Which of the following is true about runtime exceptions?",
                                            "input": "A) They are always checked exceptions\nB) They are caught explicitly using try-catch blocks\nC) They occur during compile-time\nD) They can occur at runtime and do not need to be declared",
                                            "output": "D"
                                            },
                                            {
                                            "instruction": "Which statement is true about the relationship between Exception and Throwable in Java?",
                                            "input": "A) Throwable is a subclass of Exception\nB) Exception is a subclass of Throwable\nC) Exception and Throwable are unrelated classes\nD) Throwable is used to catch checked exceptions, while Exception handles unchecked exceptions",
                                            "output": "B"
                                            },
                                            {
                                            "instruction": "What happens if you use a 'finally' block without a 'catch' block?",
                                            "input": "A) The program will not compile\nB) The 'finally' block will execute only when an exception occurs\nC) The 'finally' block will execute whether or not an exception occurs\nD) The 'finally' block will execute and terminate the program",
                                            "output": "C"
                                            },
                                            {
                                            "instruction": "What is the function of 'try' block in exception handling?",
                                            "input": "A) To catch an exception\nB) To declare the exception\nC) To execute code that might cause an exception\nD) To propagate the exception",
                                            "output": "C"
                                            },
                                            {
                                            "instruction": "What is a common cause for a 'StackOverflowError' in Java?",
                                            "input": "A) Infinite recursion\nB) Invalid method signature\nC) Accessing a null pointer\nD) Arithmetic operations",
                                            "output": "A"
                                            },                                                                                                                                                    
                                        {
                                            "instruction": "What type of exception is thrown when an array index is accessed outside its bounds?",
                                            "input": "A) NullPointerException\nB) ArrayIndexOutOfBoundsException\nC) ArithmeticException\nD) ClassNotFoundException",
                                            "output": "B"
                                            },
                                            {
                                            "instruction": "Which of the following statements is true about the 'throws' keyword in Java?",
                                            "input": "A) 'throws' is used to throw a runtime exception\nB) 'throws' is used to declare a method that does not throw exceptions\nC) 'throws' is used to declare that a method might throw exceptions\nD) 'throws' is used inside the catch block",
                                            "output": "C"
                                            },
                                            {
                                            "instruction": "What happens if you call a method that throws a checked exception but doesn't handle it?",
                                            "input": "A) The exception will be automatically handled\nB) The program will stop execution\nC) The method must be declared with 'throws' or the exception will be caught\nD) The method will compile but the exception will be ignored",
                                            "output": "C"
                                            },
                                            {
                                            "instruction": "Which of the following exceptions is a subclass of the Exception class but not the RuntimeException class?",
                                            "input": "A) NullPointerException\nB) IOException\nC) ArithmeticException\nD) ArrayIndexOutOfBoundsException",
                                            "output": "B"
                                            },
                                            {
                                            "instruction": "What is the correct syntax for handling exceptions in Java?",
                                            "input": "A) try {} catch() {}\nB) try () catch {} {}\nC) try() catch() {}\nD) try {} catch() {} finally {}",
                                            "output": "D"
                                            },
                                            {
                                            "instruction": "What is the base class for all errors and exceptions in Java?",
                                            "input": "A) Error\nB) Throwable\nC) Exception\nD) ThrowableError",
                                            "output": "B"
                                            },
                                            {
                                            "instruction": "What is the behavior of 'throw' in exception handling?",
                                            "input": "A) It throws an exception to the calling method\nB) It catches an exception and handles it\nC) It ignores exceptions\nD) It terminates the program",
                                            "output": "A"
                                            },
                                            {
                                            "instruction": "Which exception is thrown when an invalid object is passed to a method expecting a different type of object?",
                                            "input": "A) ClassCastException\nB) IllegalArgumentException\nC) NullPointerException\nD) IndexOutOfBoundsException",
                                            "output": "A"
                                            },
                                            {
                                            "instruction": "What is the role of the 'catch' block in Java exception handling?",
                                            "input": "A) To execute code before an exception is thrown\nB) To catch and handle exceptions that occur in the 'try' block\nC) To declare the types of exceptions that can occur\nD) To ensure that all exceptions are logged",
                                            "output": "B"
                                            },
                                            {
                                            "instruction": "Which exception occurs when attempting to divide by zero in Java?",
                                            "input": "A) ArithmeticException\nB) DivideByZeroException\nC) NullPointerException\nD) IndexOutOfBoundsException",
                                            "output": "A"
                                            },
                                            {
                                            "instruction": "In Java, how is an exception object passed from one method to another?",
                                            "input": "A) By passing the exception as a parameter to the next method\nB) By throwing the exception using the 'throw' keyword\nC) By returning the exception object to the calling method\nD) By logging the exception object",
                                            "output": "B"
                                            },
                                            {
                                            "instruction": "What is the purpose of 'finally' block in exception handling?",
                                            "input": "A) To execute code regardless of whether an exception occurred\nB) To throw exceptions\nC) To prevent the exception from occurring\nD) To log the exception details",
                                            "output": "A"
                                            },
                                            {
                                            "instruction": "What happens if a 'return' statement is used in a 'finally' block?",
                                            "input": "A) The 'finally' block is skipped\nB) The return statement is ignored\nC) The return value from the 'finally' block overrides other return values\nD) The return statement executes and the method exits",
                                            "output": "C"
                                            },
                                            {
                                            "instruction": "Which of the following is true about the 'try-with-resources' statement in Java?",
                                            "input": "A) It automatically closes resources used in the 'try' block\nB) It catches exceptions and logs them\nC) It is used only with checked exceptions\nD) It is used to explicitly handle IOException",
                                            "output": "A"
                                            },
                                            {
                                            "instruction": "What does the 'throw' keyword do in Java?",
                                            "input": "A) It rethrows an exception caught by a catch block\nB) It declares the exceptions that can be thrown by a method\nC) It explicitly throws an exception\nD) It prevents an exception from being thrown",
                                            "output": "C"
                                            },
                                            {
                                            "instruction": "What happens if an exception is thrown from the 'catch' block?",
                                            "input": "A) The program will stop execution\nB) The exception is logged\nC) The exception is passed to the 'finally' block\nD) A new exception will be thrown and can be caught again",
                                            "output": "D"
                                            },
                                            {
                                            "instruction": "Which of the following is a valid catch block for catching multiple exceptions in Java?",
                                            "input": "A) catch(IOException | SQLException e) {}\nB) catch(IOException, SQLException e) {}\nC) catch(IOException, SQLException) {}\nD) catch(Exception | Throwable) {}",
                                            "output": "A"
                                            },
                                            {
                                            "instruction": "What is the superclass of all exceptions in Java?",
                                            "input": "A) Throwable\nB) Exception\nC) RuntimeException\nD) Object",
                                            "output": "A"
                                            },
                                            {
                                            "instruction": "Which of the following exceptions cannot be caught by a 'try-catch' block?",
                                            "input": "A) NullPointerException\nB) StackOverflowError\nC) IOException\nD) ArithmeticException",
                                            "output": "B"
                                            },
                                        {
                                            "instruction": "An exception is an event that disrupts the normal flow of the program and occurs during ______.",
                                            "input": "",
                                            "output": "runtime"
                                            },
                                            {
                                            "instruction": "A ______ exception is an exception that can be caught by the program and handled by the 'catch' block.",
                                            "input": "",
                                            "output": "checked"
                                            },
                                            {
                                            "instruction": "When an exception is thrown, it is propagated up the ______ until it is caught.",
                                            "input": "",
                                            "output": "call stack"
                                            },
                                            {
                                            "instruction": "In Java, the ______ class is the superclass for all exceptions.",
                                            "input": "",
                                            "output": "Throwable"
                                            },
                                            {
                                            "instruction": "The keyword ______ is used to declare that a method can throw an exception.",
                                            "input": "",
                                            "output": "throws"
                                            },
                                            {
                                            "instruction": "The ______ block in Java is used to ensure that code is executed regardless of whether an exception is thrown.",
                                            "input": "",
                                            "output": "finally"
                                            },
                                            {
                                            "instruction": "A ______ exception is thrown when an invalid operation is performed, such as dividing by zero.",
                                            "input": "",
                                            "output": "ArithmeticException"
                                            },
                                            {
                                            "instruction": "The ______ block is used to handle exceptions thrown by the 'try' block.",
                                            "input": "",
                                            "output": "catch"
                                            },
                                            {
                                            "instruction": "______ exceptions are exceptions that the Java compiler requires the programmer to handle explicitly.",
                                            "input": "",
                                            "output": "Checked"
                                            },
                                            {
                                            "instruction": "If an exception is not caught, it is propagated up the ______.",
                                            "input": "",
                                            "output": "call stack"
                                            },
                                            {
                                            "instruction": "The ______ exception is thrown when a method tries to access a null object reference.",
                                            "input": "",
                                            "output": "NullPointerException"
                                            },
                                            {
                                            "instruction": "To explicitly throw an exception in Java, the ______ keyword is used.",
                                            "input": "",
                                            "output": "throw"
                                            },
                                            {
                                            "instruction": "When an exception is thrown inside the 'finally' block, it will ______ any exception thrown earlier in the 'try' or 'catch' block.",
                                            "input": "",
                                            "output": "override"
                                            },
                                            {
                                            "instruction": "A ______ exception is an exception that occurs during the execution of the program and is not checked at compile-time.",
                                            "input": "",
                                            "output": "runtime"
                                            },
                                            {
                                            "instruction": "The method ______() is used to print the stack trace of an exception.",
                                            "input": "",
                                            "output": "printStackTrace"
                                            },
                                            {
                                            "instruction": "A ______ exception is one that is caused by a programming error, such as trying to access an element out of bounds in an array.",
                                            "input": "",
                                            "output": "runtime"
                                            },
                                            {
                                            "instruction": "In Java, the ______ class is used to create custom exceptions.",
                                            "input": "",
                                            "output": "Exception"
                                            },
                                            {
                                            "instruction": "If an exception is caught, the program can either ______ it or handle it using a 'catch' block.",
                                            "input": "",
                                            "output": "log"
                                            },
                                            {
                                            "instruction": "______ exceptions are exceptions that the Java compiler does not require to be explicitly caught or declared.",
                                            "input": "",
                                            "output": "Unchecked"
                                            },
                                        {
                                            "instruction": "In Java, a ______ exception is an exception that is thrown explicitly by the programmer when an unexpected condition arises.",
                                            "input": "",
                                            "output": "user-defined"
                                            },
                                            {
                                            "instruction": "The ______ exception is thrown when a method is invoked on an object that is not initialized.",
                                            "input": "",
                                            "output": "NullPointerException"
                                            },
                                            {
                                            "instruction": "When an exception occurs, the program control jumps to the ______ block, if present.",
                                            "input": "",
                                            "output": "catch"
                                            },
                                            {
                                            "instruction": "The ______ keyword in Java is used to specify the type of exceptions a method can throw.",
                                            "input": "",
                                            "output": "throws"
                                            },
                                            {
                                            "instruction": "A ______ exception is thrown when an invalid index is accessed in an array.",
                                            "input": "",
                                            "output": "ArrayIndexOutOfBoundsException"
                                            },
                                            {
                                            "instruction": "______ exceptions occur when the program performs an invalid operation such as dividing by zero.",
                                            "input": "",
                                            "output": "ArithmeticException"
                                            },
                                            {
                                            "instruction": "The method ______() is used to get the message of the exception in Java.",
                                            "input": "",
                                            "output": "getMessage"
                                            },
                                            {
                                            "instruction": "In Java, the ______ exception is used to signal an illegal argument passed to a method.",
                                            "input": "",
                                            "output": "IllegalArgumentException"
                                            },
                                            {
                                            "instruction": "The ______ block in Java is executed only if no exception occurs in the 'try' block.",
                                            "input": "",
                                            "output": "finally"
                                            },
                                            {
                                            "instruction": "An exception that occurs when a file is not found in the specified path is called ______.",
                                            "input": "",
                                            "output": "FileNotFoundException"
                                            },
                                            {
                                            "instruction": "To handle multiple exceptions in a single 'catch' block, Java uses the ______ keyword.",
                                            "input": "",
                                            "output": "multi-catch"
                                            },
                                            {
                                            "instruction": "If an exception is not caught within a method, it can be passed to the ______ method to be handled.",
                                            "input": "",
                                            "output": "calling"
                                            },
                                            {
                                            "instruction": "A ______ exception indicates a problem that is beyond the control of the program, such as an I/O error.",
                                            "input": "",
                                            "output": "checked"
                                            },
                                            {
                                            "instruction": "______ exceptions are unchecked and do not need to be caught or declared.",
                                            "input": "",
                                            "output": "Runtime"
                                            },
                                            {
                                            "instruction": "When an exception is thrown in the 'finally' block, it ______ any exception thrown in the 'try' block.",
                                            "input": "",
                                            "output": "overrides"
                                            },
                                            {
                                            "instruction": "The ______ method is used to throw an exception explicitly in Java.",
                                            "input": "",
                                            "output": "throw"
                                            },
                                            {
                                            "instruction": "The exception handling mechanism in Java is designed to handle ______ conditions that may arise during program execution.",
                                            "input": "",
                                            "output": "error"
                                            },
                                            {
                                            "instruction": "When an exception is thrown and caught, the program execution continues from the ______ block.",
                                            "input": "",
                                            "output": "catch"
                                            },
                                            {
                                            "instruction": "An exception that causes the program to terminate abnormally is called a ______ exception.",
                                            "input": "",
                                            "output": "fatal"
                                            },
                                            {
                                                "instruction": "True or False: In Java, exceptions are used to handle runtime errors that may occur during program execution.",
                                                "input": "",
                                                "output": "True"
                                                },
                                                {
                                                "instruction": "True or False: A 'try' block in Java can contain multiple 'catch' blocks to handle different types of exceptions.",
                                                "input": "",
                                                "output": "True"
                                                },
                                                {
                                                "instruction": "True or False: All exceptions in Java are unchecked exceptions.",
                                                "input": "",
                                                "output": "False"
                                                },
                                                {
                                                "instruction": "True or False: The 'finally' block in Java is optional and is not executed if an exception occurs.",
                                                "input": "",
                                                "output": "False"
                                                },
                                                {
                                                "instruction": "True or False: Runtime exceptions in Java need to be explicitly declared in the method signature.",
                                                "input": "",
                                                "output": "False"
                                                },
                                                {
                                                "instruction": "True or False: A 'throw' statement in Java is used to explicitly throw an exception.",
                                                "input": "",
                                                "output": "True"
                                                },
                                                {
                                                "instruction": "True or False: Checked exceptions must be caught or declared in the method signature in Java.",
                                                "input": "",
                                                "output": "True"
                                                },
                                                {
                                                "instruction": "True or False: The 'catch' block in Java can handle only one type of exception at a time.",
                                                "input": "",
                                                "output": "False"
                                                },
                                                {
                                                "instruction": "True or False: The 'finally' block is executed after the 'try' and 'catch' blocks, even if no exception occurs.",
                                                "input": "",
                                                "output": "True"
                                                },
                                                {
                                                "instruction": "True or False: If a 'catch' block is present in a try-catch-finally structure, the 'finally' block will not be executed.",
                                                "input": "",
                                                "output": "False"
                                                },
                                                {
                                                "instruction": "True or False: A 'NullPointerException' in Java occurs when a method is called on an object that is not initialized.",
                                                "input": "",
                                                "output": "True"
                                                },
                                                {
                                                "instruction": "True or False: Java allows the use of the 'try' block without a 'catch' block.",
                                                "input": "",
                                                "output": "True"
                                                },
                                                {
                                                "instruction": "True or False: Exceptions in Java can be classified into two main categories: checked exceptions and unchecked exceptions.",
                                                "input": "",
                                                "output": "True"
                                                },
                                                {
                                                "instruction": "True or False: The 'Exception' class is a subclass of the 'Throwable' class in Java.",
                                                "input": "",
                                                "output": "True"
                                                },
                                                {
                                                "instruction": "True or False: A 'catch' block can be used to handle multiple exceptions by using the 'multi-catch' syntax.",
                                                "input": "",
                                                "output": "True"
                                                },
                                                {
                                                "instruction": "True or False: Unchecked exceptions in Java do not need to be declared in the method signature.",
                                                "input": "",
                                                "output": "True"
                                                },
                                                {
                                                "instruction": "True or False: The 'Exception' class in Java is used to define user-defined exceptions.",
                                                "input": "",
                                                "output": "True"
                                                },
                                                {
                                                "instruction": "True or False: If a 'finally' block is present, it will be executed even if a 'throw' statement is encountered in the 'try' block.",
                                                "input": "",
                                                "output": "True"
                                                },
                                                {
                                                "instruction": "True or False: A 'StackOverflowError' in Java is an example of a checked exception.",
                                                "input": "",
                                                "output": "False"
                                                },
                                                {
                                                "instruction": "True or False: The 'IllegalArgumentException' class is a subclass of the 'RuntimeException' class in Java.",
                                                "input": "",
                                                "output": "True"
                                                },
                                                {
                                                    "instruction": "True or False: The 'IOException' class in Java is a checked exception.",
                                                    "input": "",
                                                    "output": "True"
                                                    },
                                                    {
                                                    "instruction": "True or False: If a method throws an exception, it can be handled by the calling method using the 'try-catch' block.",
                                                    "input": "",
                                                    "output": "True"
                                                    },
                                                    {
                                                    "instruction": "True or False: A 'NumberFormatException' is thrown when an invalid number is passed to a method expecting a number.",
                                                    "input": "",
                                                    "output": "True"
                                                    },
                                                    {
                                                    "instruction": "True or False: In Java, throwing an exception causes the normal flow of execution to resume immediately.",
                                                    "input": "",
                                                    "output": "False"
                                                    },
                                                    {
                                                    "instruction": "True or False: A 'NullPointerException' occurs when attempting to call a method on a null object reference.",
                                                    "input": "",
                                                    "output": "True"
                                                    },
                                                    {
                                                    "instruction": "True or False: 'ArithmeticException' in Java occurs when there is an invalid mathematical operation like dividing by zero.",
                                                    "input": "",
                                                    "output": "True"
                                                    },
                                                    {
                                                    "instruction": "True or False: An exception can only be caught once in Java.",
                                                    "input": "",
                                                    "output": "True"
                                                    },
                                                    {
                                                    "instruction": "True or False: Java provides a way to catch multiple types of exceptions using a single 'catch' block.",
                                                    "input": "",
                                                    "output": "True"
                                                    },
                                                    {
                                                    "instruction": "True or False: A 'finally' block is optional and can be omitted when exception handling is not needed.",
                                                    "input": "",
                                                    "output": "True"
                                                    },
                                                    {
                                                    "instruction": "True or False: The 'throw' keyword is used to declare an exception.",
                                                    "input": "",
                                                    "output": "False"
                                                    },
                                                    {
                                                    "instruction": "True or False: The 'IOException' class is part of the 'java.io' package.",
                                                    "input": "",
                                                    "output": "True"
                                                    },
                                                    {
                                                    "instruction": "True or False: You can throw multiple exceptions from a method in Java using the 'throw' keyword.",
                                                    "input": "",
                                                    "output": "True"
                                                    },
                                                    {
                                                    "instruction": "True or False: 'ClassCastException' in Java occurs when an object is cast to an incompatible class.",
                                                    "input": "",
                                                    "output": "True"
                                                    },
                                                    {
                                                    "instruction": "True or False: A 'StringIndexOutOfBoundsException' occurs when an invalid index is used in string manipulation methods.",
                                                    "input": "",
                                                    "output": "True"
                                                    },
                                                    {
                                                    "instruction": "True or False: Checked exceptions in Java need to be handled or declared at compile time.",
                                                    "input": "",
                                                    "output": "True"
                                                    },
                                                    {
                                                    "instruction": "True or False: The 'Exception' class in Java is a direct subclass of the 'Throwable' class.",
                                                    "input": "",
                                                    "output": "True"
                                                    },
                                                    {
                                                    "instruction": "True or False: The 'catch' block in Java is used to catch and handle runtime exceptions only.",
                                                    "input": "",
                                                    "output": "False"
                                                    },
                                                    {
                                                    "instruction": "True or False: You cannot catch 'Error' objects in Java as they are considered fatal exceptions.",
                                                    "input": "",
                                                    "output": "True"
                                                    },
                                                    {
                                                    "instruction": "True or False: A 'throwable' object in Java is an instance of the 'Throwable' class or one of its subclasses.",
                                                    "input": "",
                                                    "output": "True"
                                                    },
                                            {
                                                "instruction": "What is the main characteristic of the Object-Oriented Programming paradigm?",
                                                "input": "A. Emphasis on procedures\nB. Emphasis on functions\nC. Emphasis on objects and classes\nD. Emphasis on memory management",
                                                "output": "C"
                                            },
                                            {
                                                "instruction": "Which programming paradigm is based on the concept of mathematical functions?",
                                                "input": "A. Object-Oriented Programming\nB. Functional Programming\nC. Procedural Programming\nD. Logic Programming",
                                                "output": "B"
                                            },
                                            {
                                                "instruction": "In which paradigm is the program viewed as a collection of procedures or routines?",
                                                "input": "A. Functional Programming\nB. Object-Oriented Programming\nC. Procedural Programming\nD. Logic Programming",
                                                "output": "C"
                                            },
                                            {
                                                "instruction": "Which of the following is a characteristic of Imperative programming?",
                                                "input": "A. Uses declarative statements\nB. Emphasis on 'what' to compute\nC. Uses a sequence of statements for execution\nD. Based on objects and classes",
                                                "output": "C"
                                            },
                                            {
                                                "instruction": "Which of these is a feature of Logic Programming?",
                                                "input": "A. Procedural flow\nB. Mathematical functions\nC. Declarative statements and rules\nD. Object inheritance",
                                                "output": "C"
                                            },
                                            {
                                                "instruction": "Which programming paradigm focuses on the use of state and changes in state?",
                                                "input": "A. Functional Programming\nB. Procedural Programming\nC. Object-Oriented Programming\nD. Imperative Programming",
                                                "output": "D"
                                            },
                                            {
                                                "instruction": "Which of the following languages is primarily based on the Object-Oriented Programming paradigm?",
                                                "input": "A. C\nB. Python\nC. Haskell\nD. Prolog",
                                                "output": "B"
                                            },
                                            {
                                                "instruction": "Which paradigm is best suited for tasks that require the use of mathematical functions and higher-order functions?",
                                                "input": "A. Object-Oriented Programming\nB. Functional Programming\nC. Procedural Programming\nD. Logic Programming",
                                                "output": "B"
                                            },
                                            {
                                                "instruction": "In Object-Oriented Programming, what is the term for a blueprint used to create objects?",
                                                "input": "A. Function\nB. Class\nC. Procedure\nD. Method",
                                                "output": "B"
                                            },
                                            {
                                                "instruction": "Which paradigm emphasizes recursion over iteration?",
                                                "input": "A. Procedural Programming\nB. Functional Programming\nC. Object-Oriented Programming\nD. Logic Programming",
                                                "output": "B"
                                            },
                                            {
                                                "instruction": "What is a key feature of Declarative Programming?",
                                                "input": "A. Focus on control flow\nB. Focus on what the program should accomplish\nC. Focus on specific step-by-step instructions\nD. Focus on object manipulation",
                                                "output": "B"
                                            },
                                            {
                                                "instruction": "Which paradigm typically uses 'if-else' statements to control program flow?",
                                                "input": "A. Declarative Programming\nB. Functional Programming\nC. Imperative Programming\nD. Logic Programming",
                                                "output": "C"
                                            },
                                            {
                                                "instruction": "What is the concept of Encapsulation in Object-Oriented Programming?",
                                                "input": "A. Grouping similar data together\nB. Hiding the internal state of objects\nC. A blueprint for creating objects\nD. Reusing existing code",
                                                "output": "B"
                                            },
                                            {
                                                "instruction": "Which paradigm treats computation as the evaluation of mathematical functions and avoids state changes?",
                                                "input": "A. Functional Programming\nB. Object-Oriented Programming\nC. Procedural Programming\nD. Logic Programming",
                                                "output": "A"
                                            },
                                            {
                                                "instruction": "Which language is known for its strong emphasis on Logic Programming?",
                                                "input": "A. Python\nB. Prolog\nC. Java\nD. C++",
                                                "output": "B"
                                            },
                                            {
                                                "instruction": "What does the term 'Inheritance' refer to in Object-Oriented Programming?",
                                                "input": "A. Ability to store data in classes\nB. Ability to use methods from other classes\nC. Ability to access variables within a function\nD. Ability to define functions inside classes",
                                                "output": "B"
                                            },
                                            {
                                                "instruction": "Which of the following is a primary feature of Procedural Programming?",
                                                "input": "A. Objects and classes\nB. Functions and procedures\nC. Logical rules\nD. Data immutability",
                                                "output": "B"
                                            },
                                            {
                                                "instruction": "Which of the following is not a feature of Object-Oriented Programming?",
                                                "input": "A. Encapsulation\nB. Polymorphism\nC. Recursion\nD. Inheritance",
                                                "output": "C"
                                            },
                                            {
                                                "instruction": "Which paradigm focuses on solving problems by defining rules and facts?",
                                                "input": "A. Functional Programming\nB. Object-Oriented Programming\nC. Logic Programming\nD. Procedural Programming",
                                                "output": "C"
                                            },
                                            {
                                                "instruction": "What does 'Polymorphism' mean in Object-Oriented Programming?",
                                                "input": "A. Overloading methods\nB. Using multiple classes in one object\nC. A function that changes its behavior based on input\nD. Hiding data within a class",
                                                "output": "C"
                                            },                                                                                                                                                        
                                            {
                                                "instruction": "Which programming paradigm is known for separating the code into reusable functions?",
                                                "input": "A. Object-Oriented Programming\nB. Functional Programming\nC. Procedural Programming\nD. Logic Programming",
                                                "output": "B"
                                            },
                                            {
                                                "instruction": "What is the key principle behind Procedural Programming?",
                                                "input": "A. Breaking down a program into reusable objects\nB. Dividing the program into functions or procedures\nC. Defining mathematical functions\nD. Solving problems through rules and facts",
                                                "output": "B"
                                            },
                                            {
                                                "instruction": "Which concept in Object-Oriented Programming allows an object to take on many forms?",
                                                "input": "A. Inheritance\nB. Polymorphism\nC. Abstraction\nD. Encapsulation",
                                                "output": "B"
                                            },
                                            {
                                                "instruction": "Which programming paradigm primarily deals with immutable data and avoids side effects?",
                                                "input": "A. Functional Programming\nB. Object-Oriented Programming\nC. Procedural Programming\nD. Logic Programming",
                                                "output": "A"
                                            },
                                            {
                                                "instruction": "Which of the following is not a characteristic of Imperative Programming?",
                                                "input": "A. Focus on how to perform tasks\nB. Program instructions are executed in sequence\nC. Emphasis on what the program should accomplish\nD. Modification of program state",
                                                "output": "C"
                                            },
                                            {
                                                "instruction": "In Object-Oriented Programming, which term refers to the combination of data and functions that operate on that data?",
                                                "input": "A. Class\nB. Object\nC. Method\nD. Module",
                                                "output": "B"
                                            },
                                            {
                                                "instruction": "Which of these programming paradigms is closest to human reasoning and logic?",
                                                "input": "A. Object-Oriented Programming\nB. Functional Programming\nC. Logic Programming\nD. Procedural Programming",
                                                "output": "C"
                                            },
                                            {
                                                "instruction": "What is a key characteristic of Declarative Programming?",
                                                "input": "A. Focus on how the program operates\nB. Focus on specifying what the program should do\nC. Writing code using procedures\nD. Maintaining state over time",
                                                "output": "B"
                                            },
                                            {
                                                "instruction": "In which paradigm is the flow of control determined by statements like 'if' and 'while'?",
                                                "input": "A. Functional Programming\nB. Object-Oriented Programming\nC. Logic Programming\nD. Imperative Programming",
                                                "output": "D"
                                            },
                                            {
                                                "instruction": "What is the key concept of a class in Object-Oriented Programming?",
                                                "input": "A. A blueprint for creating objects\nB. A storage container for program variables\nC. A function that modifies program state\nD. A process that executes program instructions",
                                                "output": "A"
                                            },
                                            {
                                                "instruction": "Which programming paradigm emphasizes the use of mathematical logic and predicates?",
                                                "input": "A. Functional Programming\nB. Logic Programming\nC. Object-Oriented Programming\nD. Procedural Programming",
                                                "output": "B"
                                            },
                                            {
                                                "instruction": "Which of the following best describes the Procedural Programming paradigm?",
                                                "input": "A. Use of objects and inheritance\nB. Organizing code into reusable functions or procedures\nC. Emphasizing state changes and side effects\nD. Emphasizing immutability and higher-order functions",
                                                "output": "B"
                                            },
                                            {
                                                "instruction": "What feature in Object-Oriented Programming allows code to be reused in different contexts?",
                                                "input": "A. Encapsulation\nB. Inheritance\nC. Polymorphism\nD. Abstraction",
                                                "output": "B"
                                            },
                                            {
                                                "instruction": "Which paradigm emphasizes on solving problems using mathematical equations and avoiding state changes?",
                                                "input": "A. Procedural Programming\nB. Functional Programming\nC. Object-Oriented Programming\nD. Logic Programming",
                                                "output": "B"
                                            },
                                            {
                                                "instruction": "What does the term 'Abstraction' mean in Object-Oriented Programming?",
                                                "input": "A. Hiding complex implementation details from the user\nB. Allowing multiple forms of objects\nC. Using predefined functions\nD. Inheriting features from parent classes",
                                                "output": "A"
                                            },
                                            {
                                                "instruction": "Which language primarily focuses on the Functional Programming paradigm?",
                                                "input": "A. C\nB. Java\nC. Lisp\nD. Python",
                                                "output": "C"
                                            },
                                            {
                                                "instruction": "In Procedural Programming, what is the purpose of a function?",
                                                "input": "A. To organize data and behavior\nB. To change the program state\nC. To provide a reusable code block for a specific task\nD. To define a class",
                                                "output": "C"
                                            },
                                            {
                                                "instruction": "Which of the following is a key difference between Procedural and Object-Oriented Programming?",
                                                "input": "A. Procedural programming focuses on data and objects, while Object-Oriented Programming focuses on functions\nB. Procedural programming uses inheritance and polymorphism, while Object-Oriented Programming uses procedures\nC. Procedural programming focuses on actions and sequences, while Object-Oriented Programming focuses on objects and state\nD. Procedural programming is based on logic, while Object-Oriented Programming is based on functions",
                                                "output": "C"
                                            },
                                            {
                                                "instruction": "Which of the following paradigms is primarily concerned with solving problems using formal logic?",
                                                "input": "A. Object-Oriented Programming\nB. Functional Programming\nC. Logic Programming\nD. Procedural Programming",
                                                "output": "C"
                                            },
                                            {
                                                "instruction": "In which programming paradigm is immutability of data a key concept?",
                                                "input": "A. Object-Oriented Programming\nB. Procedural Programming\nC. Functional Programming\nD. Logic Programming",
                                                "output": "C"
                                            },                                                                                                                                                                                                                                                                                                        
                                            {
                                                "instruction": "Which of the following is an advantage of Object-Oriented Programming?",
                                                "input": "A. It allows easy code reuse through inheritance\nB. It focuses on data manipulation\nC. It emphasizes procedural logic\nD. It only works with functional programming",
                                                "output": "A"
                                            },
                                            {
                                                "instruction": "Which of the following is a key principle of Functional Programming?",
                                                "input": "A. Immutability and higher-order functions\nB. Objects and inheritance\nC. Code blocks and loops\nD. Hierarchical class structure",
                                                "output": "A"
                                            },
                                            {
                                                "instruction": "Which of the following is true about Procedural Programming?",
                                                "input": "A. It focuses on managing state and side effects\nB. It uses functions and classes to structure the program\nC. It is based on solving problems using logic\nD. It uses functions as the main building blocks",
                                                "output": "D"
                                            },
                                            {
                                                "instruction": "Which of these concepts is associated with Logic Programming?",
                                                "input": "A. Variables and functions\nB. Predicates and rules\nC. Objects and classes\nD. Procedures and procedures calls",
                                                "output": "B"
                                            },
                                            {
                                                "instruction": "What does the concept of 'Encapsulation' in Object-Oriented Programming refer to?",
                                                "input": "A. Hiding implementation details and exposing only necessary parts\nB. Making functions reusable\nC. Allowing multiple forms for objects\nD. Organizing data into collections",
                                                "output": "A"
                                            },
                                            {
                                                "instruction": "Which of these paradigms supports recursion as a fundamental operation?",
                                                "input": "A. Functional Programming\nB. Procedural Programming\nC. Object-Oriented Programming\nD. Logic Programming",
                                                "output": "A"
                                            },
                                            {
                                                "instruction": "In which programming paradigm is the primary focus on solving problems using mathematical functions?",
                                                "input": "A. Logic Programming\nB. Procedural Programming\nC. Object-Oriented Programming\nD. Functional Programming",
                                                "output": "D"
                                            },
                                            {
                                                "instruction": "Which feature in Object-Oriented Programming helps to limit the scope of data and protect it from unauthorized access?",
                                                "input": "A. Inheritance\nB. Polymorphism\nC. Encapsulation\nD. Abstraction",
                                                "output": "C"
                                            },
                                            {
                                                "instruction": "In Logic Programming, which of these is used to derive conclusions?",
                                                "input": "A. Variables\nB. Rules and facts\nC. Methods\nD. Functions",
                                                "output": "B"
                                            },
                                            {
                                                "instruction": "Which of the following is an advantage of using Functional Programming?",
                                                "input": "A. It reduces complexity by using shared mutable state\nB. It encourages the use of objects and classes\nC. It leads to highly modular and reusable code\nD. It is easier to maintain and debug because of side effects",
                                                "output": "C"
                                            },
                                            {
                                                "instruction": "Which programming paradigm makes use of abstract data types and operations on them?",
                                                "input": "A. Logic Programming\nB. Object-Oriented Programming\nC. Procedural Programming\nD. Functional Programming",
                                                "output": "B"
                                            },
                                            {
                                                "instruction": "What does the term 'Polymorphism' mean in Object-Oriented Programming?",
                                                "input": "A. The ability to create new classes from existing ones\nB. The ability to use the same method name to perform different tasks\nC. Hiding implementation details and exposing only the necessary interface\nD. Encapsulating data within objects",
                                                "output": "B"
                                            },
                                            {
                                                "instruction": "Which of the following is a characteristic of Imperative Programming?",
                                                "input": "A. It focuses on how to achieve a result\nB. It focuses on specifying the result\nC. It does not allow state changes\nD. It does not require functions",
                                                "output": "A"
                                            },
                                            {
                                                "instruction": "Which programming paradigm defines the program as a sequence of steps or instructions that change the program state?",
                                                "input": "A. Object-Oriented Programming\nB. Functional Programming\nC. Imperative Programming\nD. Declarative Programming",
                                                "output": "C"
                                            },
                                            {
                                                "instruction": "What is the primary focus of Object-Oriented Programming?",
                                                "input": "A. Writing mathematical equations\nB. Manipulating data and avoiding state changes\nC. Organizing code into reusable objects and classes\nD. Using logic rules to deduce results",
                                                "output": "C"
                                            },
                                            {
                                                "instruction": "Which of the following is true about Declarative Programming?",
                                                "input": "A. It focuses on specifying the steps to achieve a result\nB. It focuses on describing the result, not the steps\nC. It uses functions as the main building blocks\nD. It organizes code around objects and classes",
                                                "output": "B"
                                            },
                                            {
                                                "instruction": "Which programming paradigm focuses on writing programs that specify a set of rules or logic to solve a problem?",
                                                "input": "A. Object-Oriented Programming\nB. Functional Programming\nC. Logic Programming\nD. Procedural Programming",
                                                "output": "C"
                                            },
                                            {
                                                "instruction": "Which of the following is an example of an Object-Oriented Programming language?",
                                                "input": "A. Haskell\nB. Java\nC. C\nD. Prolog",
                                                "output": "B"
                                            },
                                            {
                                                "instruction": "Which of the following is a key principle of Functional Programming?",
                                                "input": "A. Modifying shared state\nB. Using objects to organize code\nC. Avoiding side effects and mutable data\nD. Using logical rules and facts",
                                                "output": "C"
                                            },
                                            {
                                                "instruction": "Which of the following is a feature of Object-Oriented Programming?",
                                                "input": "A. It organizes code around reusable functions\nB. It allows for hierarchical classification of data\nC. It focuses on function execution rather than data management\nD. It encourages modular programming using objects and classes",
                                                "output": "D"
                                            },
                                            {
                                                "instruction": "Which of the following is true about Functional Programming?",
                                                "input": "A. It avoids the use of recursion\nB. It allows the use of mutable state\nC. It treats functions as first-class citizens\nD. It emphasizes the use of classes and objects",
                                                "output": "C"
                                            },
                                            {
                                                "instruction": "What is the primary goal of Declarative Programming?",
                                                "input": "A. To describe the steps required to achieve a result\nB. To define a set of rules and conditions for results\nC. To manipulate data and avoid state changes\nD. To organize code into classes and objects",
                                                "output": "B"
                                            },
                                            {
                                                "instruction": "Which of the following best describes Procedural Programming?",
                                                "input": "A. It organizes the program around procedures and functions\nB. It organizes the program around objects and data\nC. It uses recursion and immutable data\nD. It specifies the rules for logic-based solutions",
                                                "output": "A"
                                            },
                                            {
                                                "instruction": "Which paradigm is primarily used in artificial intelligence and expert systems?",
                                                "input": "A. Logic Programming\nB. Procedural Programming\nC. Object-Oriented Programming\nD. Functional Programming",
                                                "output": "A"
                                            },
                                            {
                                                "instruction": "Which of the following concepts is closely related to Object-Oriented Programming?",
                                                "input": "A. Functional purity\nB. Inheritance and polymorphism\nC. Use of first-class functions\nD. Recursive function calls",
                                                "output": "B"
                                            },
                                            {
                                                "instruction": "Which of the following is a major advantage of using Object-Oriented Programming?",
                                                "input": "A. It allows for faster execution\nB. It encourages code reuse and easier maintenance\nC. It eliminates the need for recursion\nD. It simplifies the program's logic",
                                                "output": "B"
                                            },
                                            {
                                                "instruction": "What is the key difference between Imperative and Declarative Programming?",
                                                "input": "A. Imperative programming focuses on specifying the result, while Declarative programming focuses on the steps to achieve it\nB. Declarative programming focuses on specifying the steps, while Imperative programming focuses on the result\nC. Declarative programming uses recursion, whereas Imperative programming uses iteration\nD. Imperative programming is used for logic-based applications, while Declarative programming is not",
                                                "output": "B"
                                            },
                                            {
                                                "instruction": "Which of the following paradigms is most likely to involve manipulating state and using loops?",
                                                "input": "A. Functional Programming\nB. Object-Oriented Programming\nC. Imperative Programming\nD. Logic Programming",
                                                "output": "C"
                                            },
                                            {
                                                "instruction": "Which of the following is true about Object-Oriented Programming?",
                                                "input": "A. It eliminates the need for functions\nB. It organizes data into hierarchical structures\nC. It avoids the use of functions altogether\nD. It uses classes and objects as the core building blocks",
                                                "output": "D"
                                            },
                                            {
                                                "instruction": "In which programming paradigm are side effects typically avoided?",
                                                "input": "A. Functional Programming\nB. Object-Oriented Programming\nC. Imperative Programming\nD. Logic Programming",
                                                "output": "A"
                                            },
                                            {
                                                "instruction": "Which programming paradigm makes heavy use of abstract data types (ADTs)?",
                                                "input": "A. Functional Programming\nB. Object-Oriented Programming\nC. Procedural Programming\nD. Logic Programming",
                                                "output": "B"
                                            },
                                            {
                                                "instruction": "In which paradigm is a program primarily described in terms of mathematical functions?",
                                                "input": "A. Object-Oriented Programming\nB. Functional Programming\nC. Procedural Programming\nD. Logic Programming",
                                                "output": "B"
                                            },
                                            {
                                                "instruction": "Which of the following programming paradigms is based on the manipulation of predicates and facts?",
                                                "input": "A. Logic Programming\nB. Object-Oriented Programming\nC. Functional Programming\nD. Imperative Programming",
                                                "output": "A"
                                            },
                                            {
                                                "instruction": "Which paradigm is most likely to use higher-order functions?",
                                                "input": "A. Functional Programming\nB. Object-Oriented Programming\nC. Procedural Programming\nD. Imperative Programming",
                                                "output": "A"
                                            },
                                            {
                                                "instruction": "Which of the following paradigms uses 'state' as an important concept?",
                                                "input": "A. Logic Programming\nB. Functional Programming\nC. Object-Oriented Programming\nD. Imperative Programming",
                                                "output": "D"
                                            },
                                            {
                                                "instruction": "Which programming paradigm uses 'methods' and 'objects' as the core components of a program?",
                                                "input": "A. Object-Oriented Programming\nB. Functional Programming\nC. Logic Programming\nD. Procedural Programming",
                                                "output": "A"
                                            },
                                            {
                                                "instruction": "Which programming paradigm is focused on breaking down a program into smaller, reusable units of code?",
                                                "input": "A. Object-Oriented Programming\nB. Functional Programming\nC. Procedural Programming\nD. Logic Programming",
                                                "output": "C"
                                            },
                                            {
                                                "instruction": "Which of the following programming paradigms focuses on creating declarative rules and deriving conclusions?",
                                                "input": "A. Logic Programming\nB. Object-Oriented Programming\nC. Procedural Programming\nD. Functional Programming",
                                                "output": "A"
                                            },
                                            {
                                                "instruction": "What is the primary goal of Procedural Programming?",
                                                "input": "A. Organizing data and functions into reusable objects\nB. Solving problems by specifying a sequence of steps to execute\nC. Creating new classes and objects dynamically\nD. Using recursion and higher-order functions for computation",
                                                "output": "B"
                                            },                                                                                                                                                                                                                                                                                                                        
                                            {
                                                "instruction": "In Object-Oriented Programming, a class is used to define the ________________ of an object.",
                                                "input": "",
                                                "output": "structure"
                                            },
                                            {
                                                "instruction": "Functional Programming focuses on the use of ________________ to manipulate data.",
                                                "input": "",
                                                "output": "functions"
                                            },
                                            {
                                                "instruction": "In Object-Oriented Programming, the ability of an object to take on different forms is called ________________.",
                                                "input": "",
                                                "output": "polymorphism"
                                            },
                                            {
                                                "instruction": "Declarative programming emphasizes the ________________ of the desired result, not the steps to achieve it.",
                                                "input": "",
                                                "output": "specification"
                                            },
                                            {
                                                "instruction": "In Logic Programming, facts and ________________ are used to infer new facts.",
                                                "input": "",
                                                "output": "rules"
                                            },
                                            {
                                                "instruction": "In Procedural Programming, a program is typically divided into ________________ that can be reused.",
                                                "input": "",
                                                "output": "functions"
                                            },
                                            {
                                                "instruction": "A characteristic feature of Object-Oriented Programming is the concept of ________________, where one class inherits properties and methods from another.",
                                                "input": "",
                                                "output": "inheritance"
                                            },
                                            {
                                                "instruction": "In Functional Programming, ________________ are used to avoid changing state or mutable data.",
                                                "input": "",
                                                "output": "pure functions"
                                            },
                                            {
                                                "instruction": "In Procedural Programming, data is typically manipulated through the use of ________________ and ________________.",
                                                "input": "",
                                                "output": "functions, procedures"
                                            },
                                            {
                                                "instruction": "In Object-Oriented Programming, objects are instances of ________________.",
                                                "input": "",
                                                "output": "classes"
                                            },
                                            {
                                                "instruction": "The process of dividing a problem into smaller, manageable pieces is known as ________________.",
                                                "input": "",
                                                "output": "modularization"
                                            },
                                            {
                                                "instruction": "In Functional Programming, ________________ is the concept of passing functions as arguments to other functions.",
                                                "input": "",
                                                "output": "higher-order functions"
                                            },
                                            {
                                                "instruction": "In Logic Programming, ________________ is used to express relationships between facts and rules.",
                                                "input": "",
                                                "output": "logic"
                                            },
                                            {
                                                "instruction": "In Object-Oriented Programming, ________________ allows different objects to respond to the same method call in different ways.",
                                                "input": "",
                                                "output": "polymorphism"
                                            },
                                            {
                                                "instruction": "In Functional Programming, ________________ is a technique that involves applying a function repeatedly to its own result.",
                                                "input": "",
                                                "output": "recursion"
                                            },
                                            {
                                                "instruction": "In Procedural Programming, ________________ are the building blocks of a program, and they contain sequences of instructions.",
                                                "input": "",
                                                "output": "procedures"
                                            },
                                            {
                                                "instruction": "In Declarative Programming, you focus on what you want to accomplish, rather than ________________.",
                                                "input": "",
                                                "output": "how"
                                            },
                                            {
                                                "instruction": "In Object-Oriented Programming, ________________ enables the same method to be used with different types of objects.",
                                                "input": "",
                                                "output": "polymorphism"
                                            },
                                            {
                                                "instruction": "In Logic Programming, a set of ________________ defines the behavior of the program based on facts and rules.",
                                                "input": "",
                                                "output": "predicates"
                                            },
                                            {
                                                "instruction": "In Object-Oriented Programming, ________________ is the concept where data and methods are bundled together in a class.",
                                                "input": "",
                                                "output": "encapsulation"
                                            },
                                            {
                                                "instruction": "A ________________ is a collection of related data and functions that operate on that data in Object-Oriented Programming.",
                                                "input": "",
                                                "output": "class"
                                            },
                                            {
                                                "instruction": "In Object-Oriented Programming, ________________ allows a class to be used as a blueprint for creating objects.",
                                                "input": "",
                                                "output": "instantiation"
                                            },
                                            {
                                                "instruction": "Functional Programming avoids ________________ by focusing on pure functions and immutability.",
                                                "input": "",
                                                "output": "side effects"
                                            },
                                            {
                                                "instruction": "In Procedural Programming, the program logic is organized as a sequence of ________________.",
                                                "input": "",
                                                "output": "commands"
                                            },
                                            {
                                                "instruction": "In Logic Programming, the ________________ mechanism allows the system to find solutions to queries.",
                                                "input": "",
                                                "output": "inference"
                                            },
                                            {
                                                "instruction": "The goal of ________________ programming is to make computations by changing the state of variables and using explicit commands.",
                                                "input": "",
                                                "output": "imperative"
                                            },
                                            {
                                                "instruction": "In Object-Oriented Programming, ________________ ensures that an object can access and modify only its own data and methods.",
                                                "input": "",
                                                "output": "encapsulation"
                                            },
                                            {
                                                "instruction": "In Functional Programming, ________________ allows functions to be composed and passed around like any other data.",
                                                "input": "",
                                                "output": "first-class functions"
                                            },
                                            {
                                                "instruction": "In Procedural Programming, ________________ allows functions to be called in a specific order to accomplish tasks.",
                                                "input": "",
                                                "output": "sequence"
                                            },
                                            {
                                                "instruction": "In Declarative Programming, the focus is on describing ________________ rather than specifying how to achieve it.",
                                                "input": "",
                                                "output": "what"
                                            },
                                            {
                                                "instruction": "In Logic Programming, a set of facts and ________________ is used to answer queries and draw conclusions.",
                                                "input": "",
                                                "output": "rules"
                                            },
                                            {
                                                "instruction": "In Functional Programming, ________________ is the concept of defining a function that calls itself.",
                                                "input": "",
                                                "output": "recursion"
                                            },
                                            {
                                                "instruction": "In Object-Oriented Programming, the behavior of an object is defined by its ________________.",
                                                "input": "",
                                                "output": "methods"
                                            },
                                            {
                                                "instruction": "In Logic Programming, a ________________ is used to express facts, relations, and rules.",
                                                "input": "",
                                                "output": "predicate"
                                            },
                                            {
                                                "instruction": "In Object-Oriented Programming, the ________________ is the collection of all methods and properties of a class.",
                                                "input": "",
                                                "output": "interface"
                                            },
                                            {
                                                "instruction": "In Object-Oriented Programming, ________________ defines a relationship where a child class inherits methods and properties from a parent class.",
                                                "input": "",
                                                "output": "inheritance"
                                            },
                                            {
                                                "instruction": "In Functional Programming, the process of creating a new function from existing ones is called ________________.",
                                                "input": "",
                                                "output": "function composition"
                                            },
                                            {
                                                "instruction": "In Procedural Programming, a ________________ is a reusable block of code that can be called with different parameters.",
                                                "input": "",
                                                "output": "function"
                                            },                                                                                                                                                                                                                                                                                                                                                                                                                            
                                            {
                                                "instruction": "In Object-Oriented Programming, inheritance allows a class to inherit methods and properties from another class.",
                                                "input": "",
                                                "output": "True"
                                            },
                                            {
                                                "instruction": "Functional Programming focuses on using loops and mutable state to manage computations.",
                                                "input": "",
                                                "output": "False"
                                            },
                                            {
                                                "instruction": "In Logic Programming, you define rules and facts to describe a problem and the system uses them to infer conclusions.",
                                                "input": "",
                                                "output": "True"
                                            },
                                            {
                                                "instruction": "Procedural Programming is based on a set of instructions to perform tasks in a specific sequence.",
                                                "input": "",
                                                "output": "True"
                                            },
                                            {
                                                "instruction": "In Declarative Programming, you specify the steps needed to achieve a result rather than the result itself.",
                                                "input": "",
                                                "output": "False"
                                            },
                                            {
                                                "instruction": "In Object-Oriented Programming, encapsulation ensures that the internal state of an object cannot be directly accessed.",
                                                "input": "",
                                                "output": "True"
                                            },
                                            {
                                                "instruction": "Imperative Programming emphasizes describing the 'what' of a task instead of the 'how'.",
                                                "input": "",
                                                "output": "False"
                                            },
                                            {
                                                "instruction": "In Logic Programming, facts are the basic truths that can be used to draw conclusions and answer queries.",
                                                "input": "",
                                                "output": "True"
                                            },
                                            {
                                                "instruction": "Functional Programming allows side effects in computations as long as they are well-managed.",
                                                "input": "",
                                                "output": "False"
                                            },
                                            {
                                                "instruction": "In Object-Oriented Programming, a method is a function defined within a class that operates on its objects.",
                                                "input": "",
                                                "output": "True"
                                            },
                                            {
                                                "instruction": "In Procedural Programming, recursion is not used, and all programs rely solely on loops.",
                                                "input": "",
                                                "output": "False"
                                            },
                                            {
                                                "instruction": "Functional Programming treats functions as first-class citizens, meaning functions can be passed as arguments or returned from other functions.",
                                                "input": "",
                                                "output": "True"
                                            },
                                            {
                                                "instruction": "Object-Oriented Programming encourages code reuse through inheritance and polymorphism.",
                                                "input": "",
                                                "output": "True"
                                            },
                                            {
                                                "instruction": "In Declarative Programming, the programmer specifies how to achieve a result rather than what the result is.",
                                                "input": "",
                                                "output": "False"
                                            },
                                            {
                                                "instruction": "In Logic Programming, recursion is a common technique for solving problems.",
                                                "input": "",
                                                "output": "True"
                                            },
                                            {
                                                "instruction": "Imperative Programming requires the programmer to define both the logic and control flow explicitly.",
                                                "input": "",
                                                "output": "True"
                                            },
                                            {
                                                "instruction": "Procedural Programming relies on object-oriented principles like inheritance and polymorphism.",
                                                "input": "",
                                                "output": "False"
                                            },
                                            {
                                                "instruction": "In Functional Programming, mutable state is encouraged to make code more efficient.",
                                                "input": "",
                                                "output": "False"
                                            },
                                            {
                                                "instruction": "Object-Oriented Programming promotes the use of functions that are tied to specific objects through methods.",
                                                "input": "",
                                                "output": "True"
                                            },
                                            {
                                                "instruction": "In Logic Programming, predicates represent facts or relations between objects.",
                                                "input": "",
                                                "output": "True"
                                            },
{
    "instruction": "Which of the following is the primary characteristic of a hash table?",
    "input": "A) It maps keys to values\nB) It maintains elements in sorted order\nC) It stores elements in a heap-like structure\nD) It stores elements in a balanced binary tree",
    "output": "A"
},
{
    "instruction": "What is the main benefit of using a doubly linked list over a singly linked list?",
    "input": "A) It allows traversal in both directions\nB) It requires less memory\nC) It is easier to implement\nD) It is faster to search through",
    "output": "A"
},
{
    "instruction": "Which of the following data structures is best for implementing a function that repeatedly returns the smallest element?",
    "input": "A) Min-Heap\nB) Stack\nC) Binary Search Tree\nD) Hash Table",
    "output": "A"
},
{
    "instruction": "Which type of tree is specifically balanced to ensure efficient search, insertion, and deletion?",
    "input": "A) AVL Tree\nB) Binary Search Tree\nC) Red-Black Tree\nD) B-tree",
    "output": "A"
},
{
    "instruction": "What is the space complexity of a binary tree with 'n' nodes?",
    "input": "A) O(n)\nB) O(log n)\nC) O(n^2)\nD) O(1)",
    "output": "A"
},
{
    "instruction": "Which operation is generally used to remove the smallest element from a priority queue?",
    "input": "A) Extract-min\nB) Insert\nC) Peek\nD) Delete-max",
    "output": "A"
},
{
    "instruction": "In which data structure do you typically find operations like push, pop, and peek?",
    "input": "A) Stack\nB) Queue\nC) Array\nD) Linked List",
    "output": "A"
},
{
    "instruction": "Which type of data structure is implemented with arrays, pointers, and dynamic resizing?",
    "input": "A) Dynamic Array\nB) Hash Table\nC) Linked List\nD) Stack",
    "output": "A"
},
{
    "instruction": "Which of the following data structures is used to implement breadth-first search in graphs?",
    "input": "A) Queue\nB) Stack\nC) Tree\nD) Heap",
    "output": "A"
},
{
    "instruction": "What is the time complexity for deleting an element from the end of a doubly linked list?",
    "input": "A) O(1)\nB) O(n)\nC) O(log n)\nD) O(n^2)",
    "output": "A"
},
{
    "instruction": "Which data structure is best suited for implementing an adjacency matrix for graph representation?",
    "input": "A) 2D Array\nB) Stack\nC) Queue\nD) Linked List",
    "output": "A"
},
{
    "instruction": "Which operation is the most time-efficient in a heap for retrieving the maximum element?",
    "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n^2)",
    "output": "A"
},
{
    "instruction": "Which data structure is used to implement an ordered map?",
    "input": "A) Red-Black Tree\nB) Linked List\nC) Stack\nD) Array",
    "output": "A"
},
{
    "instruction": "Which type of graph representation uses adjacency lists?",
    "input": "A) Graphs with sparse connections\nB) Graphs with dense connections\nC) Directed Acyclic Graphs\nD) Weighted graphs only",
    "output": "A"
},
{
    "instruction": "Which of the following data structures uses a FIFO (First In First Out) strategy?",
    "input": "A) Queue\nB) Stack\nC) Linked List\nD) Array",
    "output": "A"
},
{
    "instruction": "Which of the following data structures uses a LIFO (Last In First Out) strategy?",
    "input": "A) Stack\nB) Queue\nC) Tree\nD) Hash Table",
    "output": "A"
},
{
    "instruction": "Which operation is the most time-efficient in a stack for pushing an element?",
    "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n^2)",
    "output": "A"
},
{
    "instruction": "Which type of data structure is often used to implement recursive algorithms?",
    "input": "A) Stack\nB) Queue\nC) Array\nD) Tree",
    "output": "A"
},
{
    "instruction": "Which of the following data structures is ideal for representing relationships between objects in a non-hierarchical way?",
    "input": "A) Graph\nB) Binary Tree\nC) Queue\nD) Stack",
    "output": "A"
},
{
    "instruction": "What is the main advantage of a B-tree over a binary search tree?",
    "input": "A) It is balanced and maintains a sorted order for efficient searching.\nB) It supports a wider range of data types.\nC) It allows faster insertion and deletion operations.\nD) It is implemented with linked lists for faster access.",
    "output": "A"
},
{
    "instruction": "Which of the following data structures is used to represent a network of computers?",
    "input": "A) Graph\nB) Stack\nC) Array\nD) Tree",
    "output": "A"
},
{
    "instruction": "Which data structure is ideal for storing ordered data and supports fast lookups?",
    "input": "A) Binary Search Tree\nB) Linked List\nC) Queue\nD) Stack",
    "output": "A"
},
{
    "instruction": "In which data structure are elements ordered based on a key value?",
    "input": "A) Tree\nB) Queue\nC) Stack\nD) Hash Table",
    "output": "A"
},
{
    "instruction": "Which of the following is a disadvantage of using a linked list over an array?",
    "input": "A) Access time is slower\nB) It uses less memory\nC) Insertion is slower\nD) It supports constant-time random access",
    "output": "A"
},
{
    "instruction": "Which of the following is used to store multiple elements at once in memory?",
    "input": "A) Array\nB) Queue\nC) Stack\nD) Tree",
    "output": "A"
},
{
    "instruction": "What is the main purpose of a priority queue?",
    "input": "A) To allow elements to be processed in order of their priority\nB) To allow the last element to be accessed first\nC) To store elements in sorted order\nD) To store elements in the order they were inserted",
    "output": "A"
},
{
    "instruction": "Which data structure is used in the implementation of recursive function calls?",
    "input": "A) Stack\nB) Queue\nC) Tree\nD) Array",
    "output": "A"
},
{
    "instruction": "What is the worst-case time complexity for inserting an element into a hash table?",
    "input": "A) O(1)\nB) O(n)\nC) O(log n)\nD) O(n^2)",
    "output": "B"
},
{
    "instruction": "Which data structure is used for implementing a depth-first traversal of a graph?",
    "input": "A) Stack\nB) Queue\nC) Array\nD) Linked List",
    "output": "A"
},
{
    "instruction": "What is the space complexity of a dynamic array with 'n' elements?",
    "input": "A) O(n)\nB) O(1)\nC) O(log n)\nD) O(n^2)",
    "output": "A"
},
{
    "instruction": "Which data structure supports inserting elements at both ends in constant time?",
    "input": "A) Deque\nB) Stack\nC) Linked List\nD) Queue",
    "output": "A"
},
{
    "instruction": "What is the time complexity for searching an element in a balanced binary search tree?",
    "input": "A) O(log n)\nB) O(n)\nC) O(n^2)\nD) O(1)",
    "output": "A"
},
{
    "instruction": "What is the space complexity of a hash table with 'n' elements?",
    "input": "A) O(n)\nB) O(log n)\nC) O(n^2)\nD) O(1)",
    "output": "A"
},
{
    "instruction": "What is the key advantage of a linked list over an array?",
    "input": "A) It allows efficient insertions and deletions.\nB) It supports constant-time random access.\nC) It uses less memory.\nD) It provides faster searching.",
    "output": "A"
},
{
    "instruction": "Which data structure can be used to represent a collection of elements with no specific order?",
    "input": "A) Set\nB) Linked List\nC) Stack\nD) Queue",
    "output": "A"
},
{
    "instruction": "Which of the following data structures can efficiently store key-value pairs?",
    "input": "A) Hash Table\nB) Linked List\nC) Queue\nD) Stack",
    "output": "A"
},
{
    "instruction": "What is the primary characteristic of a queue?",
    "input": "A) FIFO (First In, First Out) ordering\nB) LIFO (Last In, First Out) ordering\nC) Sorted data structure\nD) Dynamic resizing",
    "output": "A"
},
{
    "instruction": "Which data structure is suitable for implementing a recursive function call stack?",
    "input": "A) Stack\nB) Queue\nC) Array\nD) Tree",
    "output": "A"
},
{
    "instruction": "What type of tree structure does not have duplicate values?",
    "input": "A) Binary Search Tree\nB) Binary Tree\nC) AVL Tree\nD) Heap",
    "output": "A"
},
{
    "instruction": "What type of data structure is used in implementing a database index?",
    "input": "A) B-tree\nB) Linked List\nC) Stack\nD) Queue",
    "output": "A"
},
{
    "instruction": "What is the primary function of a hash function in a hash table?",
    "input": "A) To convert keys into an index in an array\nB) To sort the data\nC) To link nodes in a linked list\nD) To maintain the order of elements",
    "output": "A"
},
{
    "instruction": "What type of data structure is best for implementing a priority queue?",
    "input": "A) Heap\nB) Stack\nC) Queue\nD) Linked List",
    "output": "A"
},
{
    "instruction": "Which data structure is commonly used in breadth-first search algorithms?",
    "input": "A) Queue\nB) Stack\nC) Linked List\nD) Array",
    "output": "A"
},
{
    "instruction": "In which data structure does each element have at most two children?",
    "input": "A) Binary Tree\nB) Linked List\nC) Graph\nD) Stack",
    "output": "A"
},
{
    "instruction": "What is the space complexity of a doubly linked list with 'n' elements?",
    "input": "A) O(n)\nB) O(1)\nC) O(n^2)\nD) O(log n)",
    "output": "A"
},
{
    "instruction": "Which data structure is typically used for implementing undo functionality in software?",
    "input": "A) Stack\nB) Queue\nC) Linked List\nD) Hash Table",
    "output": "A"
},
{
    "instruction": "In which situation is a binary search tree most useful?",
    "input": "A) Searching for elements in sorted data\nB) Traversing the data in a sequential manner\nC) Storing elements in FIFO order\nD) Implementing a queue for tasks",
    "output": "A"
},
{
    "instruction": "Which operation is commonly associated with heaps?",
    "input": "A) Insertion\nB) Deletion\nC) Sorting\nD) All of the above",
    "output": "D"
},
{
    "instruction": "Which type of data structure is best suited for handling hierarchical relationships?",
    "input": "A) Tree\nB) Queue\nC) Stack\nD) Graph",
    "output": "A"
},
{
    "instruction": "Which of the following data structures uses a hashing mechanism for storing data?",
    "input": "A) Hash Table\nB) Stack\nC) Array\nD) Tree",
    "output": "A"
},
{
    "instruction": "What is the worst-case time complexity for searching in a balanced binary search tree?",
    "input": "A) O(log n)\nB) O(n)\nC) O(n log n)\nD) O(1)",
    "output": "A"
},
{
    "instruction": "Which data structure allows constant time insertions and deletions at both ends?",
    "input": "A) Deque\nB) Stack\nC) Linked List\nD) Queue",
    "output": "A"
},
{
    "instruction": "What is the time complexity of accessing an element in a hash table by its key?",
    "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n^2)",
    "output": "A"
},
{
    "instruction": "Which of the following data structures supports random access to elements?",
    "input": "A) Array\nB) Linked List\nC) Stack\nD) Queue",
    "output": "A"
},
{
    "instruction": "What is the key feature of a circular linked list?",
    "input": "A) The last node points to the first node\nB) Nodes can have multiple parent nodes\nC) All nodes are in a linear structure\nD) It supports only FIFO operations",
    "output": "A"
},
{
    "instruction": "Which data structure is used to implement depth-first search?",
    "input": "A) Stack\nB) Queue\nC) Array\nD) Linked List",
    "output": "A"
},
{
    "instruction": "What is the primary use case of a trie?",
    "input": "A) Storing and searching strings\nB) Implementing a binary tree\nC) Implementing an undo stack\nD) Representing a graph",
    "output": "A"
},
{
    "instruction": "In which data structure are elements stored based on a hash key?",
    "input": "A) Hash Table\nB) Linked List\nC) Stack\nD) Queue",
    "output": "A"
},
{
    "instruction": "Which data structure allows access to elements by both ends?",
    "input": "A) Deque\nB) Stack\nC) Queue\nD) Array",
    "output": "A"
},
{
    "instruction": "Which data structure is ideal for storing a fixed sequence of elements?",
    "input": "A) Array\nB) Stack\nC) Tree\nD) Graph",
    "output": "A"
},
{
    "instruction": "In which data structure does each node have a unique predecessor?",
    "input": "A) Linked List\nB) Array\nC) Stack\nD) Queue",
    "output": "A"
},
{
    "instruction": "Which of the following operations has O(1) complexity in a stack?",
    "input": "A) Push\nB) Search\nC) Traverse\nD) Sort",
    "output": "A"
},
{
    "instruction": "What is a key advantage of a circular queue over a linear queue?",
    "input": "A) Efficient use of storage by wrapping around.\nB) Easier to implement.\nC) Allows LIFO access.\nD) Supports non-integer data types.",
    "output": "A"
},
{
    "instruction": "Which data structure is best suited for representing family trees?",
    "input": "A) Tree\nB) Array\nC) Queue\nD) Stack",
    "output": "A"
},
{
    "instruction": "What is the time complexity for inserting an element at the end of a linked list?",
    "input": "A) O(n)\nB) O(1)\nC) O(log n)\nD) O(n^2)",
    "output": "A"
},
{
    "instruction": "Which data structure would be best for implementing a dynamic list?",
    "input": "A) Linked List\nB) Array\nC) Stack\nD) Queue",
    "output": "A"
},
{
    "instruction": "Which operation is faster in a doubly linked list than in a singly linked list?",
    "input": "A) Deletion of a node\nB) Search\nC) Sorting\nD) Accessing by index",
    "output": "A"
},
{
    "instruction": "Which of the following uses a hierarchical model?",
    "input": "A) Tree\nB) Stack\nC) Queue\nD) Hash Table",
    "output": "A"
},
{
    "instruction": "Which data structure is typically used for evaluating arithmetic expressions?",
    "input": "A) Stack\nB) Tree\nC) Queue\nD) Graph",
    "output": "A"
},
{
    "instruction": "What data structure can have elements with no predecessor or successor?",
    "input": "A) Graph\nB) Stack\nC) Array\nD) Linked List",
    "output": "A"
},
{
    "instruction": "Which data structure is most efficient for implementing an autocomplete feature?",
    "input": "A) Trie\nB) Stack\nC) Queue\nD) Heap",
    "output": "A"
},
{
    "instruction": "What is the advantage of a binary search tree?",
    "input": "A) Allows efficient searching of ordered data.\nB) Provides FIFO access.\nC) Provides LIFO access.\nD) Stores data in a sequential format.",
    "output": "A"
},
{
    "instruction": "Which data structure allows quick access using a key?",
    "input": "A) Hash Table\nB) Queue\nC) Stack\nD) Tree",
    "output": "A"
},
{
    "instruction": "What is the main characteristic of a priority queue?",
    "input": "A) Elements are removed based on priority, not arrival order.\nB) Elements are accessed randomly.\nC) Elements are removed based on arrival order.\nD) Elements are arranged in a linear order.",
    "output": "A"
},
{
    "instruction": "What is the most common use case for a doubly linked list?",
    "input": "A) Implementing a deque\nB) Storing elements sequentially\nC) Sorting numbers\nD) Storing elements in LIFO order",
    "output": "A"
},
{
    "instruction": "In which scenario would a stack be most useful?",
    "input": "A) Managing function calls in programming\nB) Managing tasks in a printer queue\nC) Storing elements that require sequential access\nD) Implementing a binary search tree",
    "output": "A"
},
{
    "instruction": "Which data structure is best for finding the shortest path in a graph?",
    "input": "A) Queue\nB) Stack\nC) Array\nD) Linked List",
    "output": "A"
},
{
    "instruction": "What is a major advantage of a linked list over an array?",
    "input": "A) It supports dynamic memory allocation.\nB) It has faster indexing.\nC) It is easier to sort.\nD) It is more memory-efficient.",
    "output": "A"
},
{
    "instruction": "Which data structure would be best for storing elements with duplicate values?",
    "input": "A) Linked List\nB) Set\nC) Hash Table\nD) Binary Search Tree",
    "output": "A"
},
{
    "instruction": "Choose the correct answer about data structures in programming.",
    "input": "A) A data structure organizes data for efficient access.\nB) A data structure is only used for database storage.\nC) Data structures are unrelated to algorithms.\nD) Data structures are only used in machine learning.",
    "output": "A"
},
{
    "instruction": "Which data structure uses the Last In, First Out (LIFO) principle?",
    "input": "A) Stack\nB) Queue\nC) Linked List\nD) Tree",
    "output": "A"
},
{
    "instruction": "What is the primary characteristic of a linked list?",
    "input": "A) Each element points to the next element.\nB) All elements are stored sequentially in memory.\nC) It only supports LIFO operations.\nD) Elements can be accessed directly by index.",
    "output": "A"
},
{
    "instruction": "Which data structure is used for implementing recursion?",
    "input": "A) Stack\nB) Array\nC) Tree\nD) Queue",
    "output": "A"
},
{
    "instruction": "Which of these data structures allows First In, First Out (FIFO) operations?",
    "input": "A) Queue\nB) Stack\nC) Tree\nD) Graph",
    "output": "A"
},
{
    "instruction": "What is the time complexity of accessing an element by index in an array?",
    "input": "A) O(1)\nB) O(n)\nC) O(log n)\nD) O(n^2)",
    "output": "A"
},
{
    "instruction": "Which data structure is typically used to represent hierarchical relationships?",
    "input": "A) Tree\nB) Array\nC) Stack\nD) Hash Table",
    "output": "A"
},
{
    "instruction": "In which data structure is each element connected to two others in a linear form?",
    "input": "A) Doubly linked list\nB) Queue\nC) Stack\nD) Binary tree",
    "output": "A"
},
{
    "instruction": "What is the main purpose of a hash table?",
    "input": "A) To provide fast data retrieval based on key-value pairs.\nB) To maintain elements in sorted order.\nC) To store data in a hierarchical format.\nD) To enable Last In, First Out access.",
    "output": "A"
},
{
    "instruction": "Which data structure is most efficient for implementing priority queues?",
    "input": "A) Heap\nB) Stack\nC) Linked List\nD) Array",
    "output": "A"
},
{
    "instruction": "What is a key property of a binary search tree?",
    "input": "A) Each node has at most two children.\nB) Nodes are stored in a circular structure.\nC) Nodes can have multiple parent nodes.\nD) Each node has exactly three children.",
    "output": "A"
},
{
    "instruction": "Which data structure can be used to solve maze problems?",
    "input": "A) Graph\nB) Queue\nC) Array\nD) Linked List",
    "output": "A"
},
{
    "instruction": "Which data structure is best for implementing an undo function in applications?",
    "input": "A) Stack\nB) Queue\nC) Array\nD) Graph",
    "output": "A"
},
{
    "instruction": "What is a common use case for a queue?",
    "input": "A) Task scheduling\nB) Traversing a tree in reverse order\nC) Storing unique keys only\nD) Sorting elements in descending order",
    "output": "A"
},
{
    "instruction": "Which data structure is used in depth-first search algorithms?",
    "input": "A) Stack\nB) Queue\nC) Tree\nD) Array",
    "output": "A"
},
{
    "instruction": "Which data structure is typically used to implement a breadth-first search?",
    "input": "A) Queue\nB) Stack\nC) Heap\nD) Tree",
    "output": "A"
},
{
    "instruction": "Which of these operations is NOT commonly associated with stacks?",
    "input": "A) FIFO\nB) Push\nC) Pop\nD) Peek",
    "output": "A"
},
{
    "instruction": "Which data structure is most suitable for maintaining a sorted list of elements?",
    "input": "A) Binary Search Tree\nB) Stack\nC) Queue\nD) Hash Table",
    "output": "A"
},
{
    "instruction": "Which data structure is commonly used for caching due to its fast access speed?",
    "input": "A) Hash Table\nB) Array\nC) Queue\nD) Tree",
    "output": "A"
},
{
    "instruction": "What is the main advantage of using a linked list over an array?",
    "input": "A) Dynamic size and easy insertion and deletion.\nB) Faster access to elements by index.\nC) Uses less memory.\nD) Allows indexing of elements.",
    "output": "A"
},
{
    "instruction": "Which of the following is true about a hash table with open addressing?",
    "input": "A) Collisions are resolved by probing\nB) Each key is mapped to a unique index\nC) It uses linked lists for handling collisions\nD) It supports faster retrieval than a hash table with chaining",
    "output": "A"
},
{
    "instruction": "What is the space complexity of a singly linked list with 'n' elements?",
    "input": "A) O(n)\nB) O(1)\nC) O(log n)\nD) O(n^2)",
    "output": "A"
},
{
    "instruction": "Which of the following is a disadvantage of using a heap data structure?",
    "input": "A) It does not support efficient searching\nB) It has high insertion cost\nC) It is not suitable for priority queues\nD) It requires a large amount of memory",
    "output": "A"
},
{
    "instruction": "Which data structure is used to implement undo operations in software applications?",
    "input": "A) Stack\nB) Queue\nC) Linked List\nD) Array",
    "output": "A"
},
{
    "instruction": "Which data structure is typically used for implementing a recursive function call?",
    "input": "A) Stack\nB) Queue\nC) Array\nD) Tree",
    "output": "A"
},
{
    "instruction": "What is the time complexity for inserting an element into the middle of a singly linked list?",
    "input": "A) O(n)\nB) O(log n)\nC) O(1)\nD) O(n^2)",
    "output": "A"
},
{
    "instruction": "Which of the following operations can be performed on a hash table with constant time complexity?",
    "input": "A) Insertion and lookup\nB) Sorting\nC) Searching by key\nD) Deletion",
    "output": "A"
},
{
    "instruction": "What is the main difference between a binary search tree and an AVL tree?",
    "input": "A) An AVL tree is self-balancing, while a binary search tree is not\nB) A binary search tree allows duplicate keys, while an AVL tree does not\nC) A binary search tree supports faster insertions than an AVL tree\nD) An AVL tree has a larger memory footprint than a binary search tree",
    "output": "A"
},
{
    "instruction": "In which situation is a circular linked list most beneficial?",
    "input": "A) When you need to iterate through the list repeatedly\nB) When you need to store elements in sorted order\nC) When you need random access to elements\nD) When you need to store large data elements",
    "output": "A"
},
{
    "instruction": "Which of the following is a characteristic of a red-black tree?",
    "input": "A) It is a self-balancing binary search tree\nB) It supports constant-time search\nC) It is not suitable for use in databases\nD) It uses linked lists to store elements",
    "output": "A"
},
{
    "instruction": "Which operation is used to find the maximum element in a max heap?",
    "input": "A) Peek\nB) Insert\nC) Delete\nD) Extract-min",
    "output": "A"
},
{
    "instruction": "What is the time complexity of searching for an element in a balanced binary search tree?",
    "input": "A) O(log n)\nB) O(n)\nC) O(n^2)\nD) O(1)",
    "output": "A"
},
{
    "instruction": "What is the primary use of a hash function in a hash table?",
    "input": "A) To map keys to specific indices\nB) To sort the elements based on their values\nC) To balance the tree structure\nD) To track the size of the hash table",
    "output": "A"
},
{
    "instruction": "Which of the following data structures is best for storing ordered data and supporting fast access?",
    "input": "A) Binary Search Tree\nB) Stack\nC) Queue\nD) Hash Table",
    "output": "A"
},
{
    "instruction": "What is the key disadvantage of a static array?",
    "input": "A) Its size cannot be changed after it is created\nB) It does not allow random access to elements\nC) It is slower than a linked list\nD) It requires too much memory",
    "output": "A"
},
{
    "instruction": "Which type of tree is a balanced binary tree that ensures logarithmic time complexity for search, insertion, and deletion?",
    "input": "A) AVL Tree\nB) Binary Tree\nC) Red-Black Tree\nD) B-tree",
    "output": "A"
},
{
    "instruction": "Which of the following is true about a queue?",
    "input": "A) It follows the FIFO (First In, First Out) principle\nB) It allows random access to elements\nC) It supports faster search operations than a stack\nD) It uses a LIFO (Last In, First Out) principle",
    "output": "A"
},
{
    "instruction": "Which of the following is a property of a hash table with chaining?",
    "input": "A) It handles collisions using linked lists\nB) It does not allow duplicate keys\nC) It always maintains a sorted order\nD) It has a fixed size",
    "output": "A"
},
{
    "instruction": "Which operation is most efficient for retrieving the top element in a stack?",
    "input": "A) O(1)\nB) O(n)\nC) O(log n)\nD) O(n^2)",
    "output": "A"
},
{
    "instruction": "Fill in the blank: A __________ is a data structure that stores elements in a first-in-first-out (FIFO) order.",
    "input": "",
    "output": "Queue"
},
{
    "instruction": "Fill in the blank: A __________ is a linear data structure where elements are added or removed from only one end, called the top.",
    "input": "",
    "output": "Stack"
},
{
    "instruction": "Fill in the blank: In a binary search tree (BST), the left child is always __________ than the parent node.",
    "input": "",
    "output": "Smaller"
},
{
    "instruction": "Fill in the blank: A __________ is a self-balancing binary search tree in which the difference in heights of left and right subtrees cannot be more than one.",
    "input": "",
    "output": "AVL Tree"
},
{
    "instruction": "Fill in the blank: In a graph, an edge is a connection between two __________.",
    "input": "",
    "output": "Vertices"
},
{
    "instruction": "Fill in the blank: A __________ table is a data structure that maps keys to values using a hash function.",
    "input": "",
    "output": "Hash"
},
{
    "instruction": "Fill in the blank: In a circular linked list, the last node's next pointer points to the __________ node.",
    "input": "",
    "output": "First"
},
{
    "instruction": "Fill in the blank: The time complexity for searching in a hash table is typically __________.",
    "input": "",
    "output": "O(1)"
},
{
    "instruction": "Fill in the blank: A __________ is a tree data structure in which each parent node can have multiple children, commonly used in databases.",
    "input": "",
    "output": "B-tree"
},
{
    "instruction": "Fill in the blank: A __________ is used in graph traversal to visit all the vertices of a graph in a breadth-first manner.",
    "input": "",
    "output": "Queue"
},
{
    "instruction": "Fill in the blank: In a priority queue, the __________ element is the one with the highest priority.",
    "input": "",
    "output": "First"
},
{
    "instruction": "Fill in the blank: The operation of __________ in a stack removes the top element from the stack.",
    "input": "",
    "output": "Pop"
},
{
    "instruction": "Fill in the blank: In a doubly linked list, each node has two pointers: one to the next node and one to the __________ node.",
    "input": "",
    "output": "Previous"
},
{
    "instruction": "Fill in the blank: A __________ is a tree in which the left child node is less than the parent node and the right child node is greater.",
    "input": "",
    "output": "Binary Search Tree"
},
{
    "instruction": "Fill in the blank: The operation of __________ in a queue adds an element to the end of the queue.",
    "input": "",
    "output": "Enqueue"
},
{
    "instruction": "Fill in the blank: A __________ is a data structure used to store key-value pairs and supports fast lookups.",
    "input": "",
    "output": "Hash Map"
},
{
    "instruction": "Fill in the blank: A __________ is a type of graph where edges have a direction from one vertex to another.",
    "input": "",
    "output": "Directed Graph"
},
{
    "instruction": "Fill in the blank: A __________ is a tree in which every node has at most two children.",
    "input": "",
    "output": "Binary Tree"
},
{
    "instruction": "Fill in the blank: In a linked list, each element is called a __________.",
    "input": "",
    "output": "Node"
},
{
    "instruction": "Fill in the blank: The operation of __________ in a heap is used to remove the root element, typically the maximum or minimum.",
    "input": "",
    "output": "Extract"
},
{
    "instruction": "True or False: A stack follows the FIFO (First In, First Out) principle.",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: A binary search tree allows efficient searching, insertion, and deletion of elements.",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: In a linked list, elements can only be accessed sequentially, not directly.",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: A hash table with chaining handles collisions by rehashing keys.",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: A red-black tree is a type of binary search tree that ensures the tree remains balanced after each operation.",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: A queue uses the LIFO (Last In, First Out) principle.",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: In an AVL tree, the height difference between the left and right subtrees can never exceed 1.",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: A priority queue always returns the smallest element first.",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: In a doubly linked list, each node has a pointer to both the previous and next node.",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: In a stack, the pop operation removes the last inserted element.",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: A heap data structure allows efficient retrieval of the smallest element.",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: A directed graph is a graph in which the edges have no direction.",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: A circular linked list allows efficient traversal of the list in both directions.",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: A hash map uses a hash function to map keys to their corresponding values.",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: A binary search tree is always balanced, meaning the left and right subtrees of each node have the same height.",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: The time complexity of inserting an element into a linked list is always O(n).",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: A breadth-first search (BFS) algorithm is implemented using a stack.",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: A graph is a data structure consisting of a collection of vertices and edges that connect pairs of vertices.",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: In a binary heap, the smallest element is always at the root.",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: A tree is a hierarchical data structure that consists of nodes connected by edges.",
    "input": "",
    "output": "True"
},
{
    "instruction": "Fill in the blank: In a binary search tree, the right child is always __________ than the parent node.",
    "input": "",
    "output": "Greater"
},
{
    "instruction": "Fill in the blank: A __________ is a data structure that stores elements in a non-linear fashion and allows traversal of nodes in multiple directions.",
    "input": "",
    "output": "Graph"
},
{
    "instruction": "Fill in the blank: The __________ operation in a stack retrieves the top element without removing it.",
    "input": "",
    "output": "Peek"
},
{
    "instruction": "Fill in the blank: In a circular queue, the front and rear pointers are connected to form a __________.",
    "input": "",
    "output": "Circle"
},
{
    "instruction": "Fill in the blank: In a binary tree, the left subtree of a node contains values __________ than the node's value.",
    "input": "",
    "output": "Smaller"
},
{
    "instruction": "Fill in the blank: The __________ operation in a binary heap ensures that the heap property is maintained after inserting a new element.",
    "input": "",
    "output": "Heapify"
},
{
    "instruction": "Fill in the blank: A __________ search algorithm starts by visiting the root and then recursively visits the left and right subtrees.",
    "input": "",
    "output": "Depth-first"
},
{
    "instruction": "Fill in the blank: A __________ is a dynamic array that automatically resizes when it becomes full.",
    "input": "",
    "output": "Vector"
},
{
    "instruction": "Fill in the blank: A __________ search tree balances itself during insertions and deletions to ensure O(log n) time complexity for operations.",
    "input": "",
    "output": "Red-Black Tree"
},
{
    "instruction": "Fill in the blank: The __________ operation in a queue removes the first element from the queue.",
    "input": "",
    "output": "Dequeue"
},
{
    "instruction": "Fill in the blank: The time complexity for searching an element in a balanced binary search tree is __________.",
    "input": "",
    "output": "O(log n)"
},
{
    "instruction": "Fill in the blank: In a heap, the root node always contains the __________ element.",
    "input": "",
    "output": "Maximum"
},
{
    "instruction": "Fill in the blank: A __________ is a type of search tree that uses balance factors to maintain efficient height.",
    "input": "",
    "output": "AVL Tree"
},
{
    "instruction": "Fill in the blank: A __________ list is a data structure in which each element points to the next and previous elements.",
    "input": "",
    "output": "Doubly Linked"
},
{
    "instruction": "Fill in the blank: A __________ tree allows searching, inserting, and deleting elements in O(log n) time on average.",
    "input": "",
    "output": "Binary Search"
},
{
    "instruction": "Fill in the blank: In a doubly linked list, the first element has a pointer to the __________ node.",
    "input": "",
    "output": "Next"
},
{
    "instruction": "Fill in the blank: A __________ is a specialized tree data structure used to implement a set with efficient searching, insertion, and deletion.",
    "input": "",
    "output": "Trie"
},
{
    "instruction": "Fill in the blank: A __________ is a type of graph where each edge has a weight associated with it.",
    "input": "",
    "output": "Weighted Graph"
},
{
    "instruction": "Fill in the blank: In a directed acyclic graph (DAG), there are no __________ between any two vertices.",
    "input": "",
    "output": "Cycles"
},
{
    "instruction": "Fill in the blank: A __________ queue is a queue in which elements can be added or removed from both ends.",
    "input": "",
    "output": "Deque"
},
{
    "instruction": "True or False: A circular queue can be implemented using an array.",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: A graph with no cycles is called a directed acyclic graph (DAG).",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: A hash table guarantees that there will never be a collision.",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: A depth-first search (DFS) is typically implemented using a queue.",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: The time complexity of deleting an element from a binary search tree is O(n).",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: A binary heap is a complete binary tree.",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: In a directed graph, the edges have no direction.",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: A stack is a data structure that follows the FIFO (First In, First Out) principle.",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: In a doubly linked list, each node points to both the next and previous node.",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: A priority queue always returns the element with the highest priority.",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: A linked list allows random access to elements.",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: A red-black tree maintains balance by ensuring that each node has two children.",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: A breadth-first search (BFS) uses a stack for its implementation.",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: A binary search tree can have duplicate elements in the tree.",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: The time complexity of accessing an element in an array is O(n).",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: A heap data structure can be used to efficiently implement a priority queue.",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: A graph can be represented using an adjacency matrix or adjacency list.",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: A trie is a tree-like data structure used for efficient string searches.",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: A stack supports operations like pop, push, and peek.",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: A queue supports only the dequeue operation from the front of the queue.",
    "input": "",
    "output": "False"
},
{
    "instruction": "Fill in the blank: The __________ operation in a priority queue removes the element with the highest priority.",
    "input": "",
    "output": "Dequeue"
},
{
    "instruction": "Fill in the blank: A __________ search algorithm works by dividing the search space in half at each step.",
    "input": "",
    "output": "Binary Search"
},
{
    "instruction": "Fill in the blank: The __________ operation in a linked list inserts an element at the beginning of the list.",
    "input": "",
    "output": "Insert"
},
{
    "instruction": "Fill in the blank: A __________ data structure consists of a sequence of elements in which each element points to the next element.",
    "input": "",
    "output": "Linked List"
},
{
    "instruction": "Fill in the blank: The maximum number of children a node can have in a binary tree is __________.",
    "input": "",
    "output": "2"
},
{
    "instruction": "Fill in the blank: In a hash table, elements are stored based on their __________ value.",
    "input": "",
    "output": "Hash"
},
{
    "instruction": "Fill in the blank: In a stack, the __________ operation retrieves and removes the top element.",
    "input": "",
    "output": "Pop"
},
{
    "instruction": "Fill in the blank: A __________ is a data structure used to represent hierarchical relationships between elements.",
    "input": "",
    "output": "Tree"
},
{
    "instruction": "Fill in the blank: The __________ operation in a queue inserts an element at the end of the queue.",
    "input": "",
    "output": "Enqueue"
},
{
    "instruction": "Fill in the blank: In a circular queue, when the rear pointer reaches the end of the array, it wraps around to the __________.",
    "input": "",
    "output": "Beginning"
},
{
    "instruction": "True or False: A doubly linked list allows traversal in only one direction.",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: A hash table can be used for fast lookup operations.",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: A binary tree can have more than two children per node.",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: A graph is always a tree.",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: A graph with no edges is known as an isolated graph.",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: A linked list provides constant-time access to elements by index.",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: In a binary heap, the heap property ensures that the parent node is either larger or smaller than the child nodes.",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: A tree can have one or more root nodes.",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: In an undirected graph, every edge has two directions.",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: A graph that is connected and has no cycles is called a tree.",
    "input": "",
    "output": "True"
},
{
    "instruction": "What is the primary purpose of encapsulation in object-oriented programming?",
    "input": "A. To protect the internal state of an object\nB. To allow multiple inheritance\nC. To implement method overloading\nD. To support polymorphism",
    "output": "A"
},
{
    "instruction": "Which of the following is an example of encapsulation in Java?",
    "input": "A. Using private fields and providing public getter/setter methods\nB. Using the extends keyword\nC. Overriding methods\nD. Using interfaces",
    "output": "A"
},
{
    "instruction": "In Java, what type of method is typically used to retrieve the value of a private instance variable?",
    "input": "A. Setter method\nB. Constructor method\nC. Getter method\nD. Main method",
    "output": "C"
},
{
    "instruction": "Which access modifier would you use to hide the implementation details of a class while exposing the necessary functionality?",
    "input": "A. public\nB. private\nC. protected\nD. default",
    "output": "B"
},
{
    "instruction": "Which of the following is NOT a benefit of encapsulation?",
    "input": "A. Increased security\nB. Easier debugging\nC. Reduced code complexity\nD. Direct access to internal variables",
    "output": "D"
},
{
    "instruction": "What is the term used to describe a class that hides its implementation details from other classes?",
    "input": "A. Abstract class\nB. Encapsulated class\nC. Inherited class\nD. Interface",
    "output": "B"
},
{
    "instruction": "How can encapsulation be achieved in Java?",
    "input": "A. By using private variables and public methods\nB. By creating an abstract class\nC. By using inheritance\nD. By overriding methods",
    "output": "A"
},
{
    "instruction": "Which of the following statements about encapsulation is true?",
    "input": "A. Encapsulation is the process of hiding implementation details and showing only functionality\nB. Encapsulation requires inheritance\nC. Encapsulation only applies to private methods\nD. Encapsulation is not supported in object-oriented programming",
    "output": "A"
},
{
    "instruction": "What is the role of the getter and setter methods in encapsulation?",
    "input": "A. They allow direct access to private variables\nB. They allow the internal state of an object to be modified outside the class\nC. They control how the data is accessed and modified\nD. They are used to inherit methods from other classes",
    "output": "C"
},
{
    "instruction": "Which of the following access levels provides the most restriction on member access in a class?",
    "input": "A. public\nB. protected\nC. private\nD. default",
    "output": "C"
},
{
    "instruction": "What happens if the fields of a class are declared as private and no setter method is provided?",
    "input": "A. The class becomes abstract\nB. The fields cannot be accessed or modified directly\nC. The class cannot be compiled\nD. The fields are visible to all other classes",
    "output": "B"
},
{
    "instruction": "What does the principle of encapsulation help to achieve in object-oriented programming?",
    "input": "A. Code reuse\nB. Data hiding\nC. Polymorphism\nD. Inheritance",
    "output": "B"
},
{
    "instruction": "Which of the following is the correct syntax for creating a getter method in Java?",
    "input": "A. public void getValue() {}\nB. public int getValue() {}\nC. public getValue() {}\nD. private int getValue() {}",
    "output": "B"
},
{
    "instruction": "In encapsulation, which of the following is the best practice?",
    "input": "A. Expose only necessary information\nB. Make all fields public\nC. Use public methods for all operations\nD. Do not use setter methods",
    "output": "A"
},
{
    "instruction": "What happens when an object's state is directly accessible from outside the class?",
    "input": "A. The class is said to be fully encapsulated\nB. The class becomes vulnerable to changes that may violate its integrity\nC. The object's behavior is guaranteed to be consistent\nD. The class is automatically abstract",
    "output": "B"
},
{
    "instruction": "What keyword is commonly used in Java to restrict direct access to a class member?",
    "input": "A. final\nB. static\nC. private\nD. synchronized",
    "output": "C"
},
{
    "instruction": "Which of the following statements about encapsulation is FALSE?",
    "input": "A. It allows the internal workings of an object to be hidden\nB. It prevents direct access to an object's fields\nC. It restricts all methods from accessing a class's fields\nD. It improves maintainability and flexibility of the code",
    "output": "C"
},
{
    "instruction": "Which access modifier should be used for a field that is shared across all instances of a class but is hidden from outside access?",
    "input": "A. public\nB. private\nC. protected\nD. static",
    "output": "B"
},
{
    "instruction": "Encapsulation allows you to change the internal implementation of a class without affecting other parts of the program. True or False?",
    "input": "",
    "output": "True"
},
{
    "instruction": "Which of the following best describes a method that is used to modify an object's state in encapsulation?",
    "input": "A. Setter method\nB. Getter method\nC. Main method\nD. Constructor method",
    "output": "A"
},
{
    "instruction": "Which of the following is the main reason for using encapsulation in Java?",
    "input": "A. To increase the speed of execution\nB. To hide implementation details from the user\nC. To enable inheritance\nD. To allow method overloading",
    "output": "B"
},
{
    "instruction": "Which of the following is an example of a setter method in Java?",
    "input": "A. public int getX() {}\nB. public void setX(int x) {}\nC. public void printX() {}\nD. public int X() {}",
    "output": "B"
},
{
    "instruction": "What does encapsulation primarily focus on in an object-oriented program?",
    "input": "A. Code reusability\nB. Data hiding\nC. Method overloading\nD. Dynamic method dispatch",
    "output": "B"
},
{
    "instruction": "Which access modifier makes the member accessible within the same package only?",
    "input": "A. private\nB. protected\nC. public\nD. default",
    "output": "D"
},
{
    "instruction": "Which of the following is true about encapsulation?",
    "input": "A. It restricts access to certain components of an object\nB. It eliminates the need for constructors\nC. It makes fields public\nD. It always requires inheritance",
    "output": "A"
},
{
    "instruction": "In encapsulation, which of the following is typically used to control access to private data?",
    "input": "A. public fields\nB. getter and setter methods\nC. abstract classes\nD. static methods",
    "output": "B"
},
{
    "instruction": "Which of the following would be an appropriate use of encapsulation in Java?",
    "input": "A. Making all variables public to be easily accessed\nB. Providing methods to allow controlled access to private fields\nC. Using inheritance to expose private fields\nD. Writing methods that modify all internal fields directly",
    "output": "B"
},
{
    "instruction": "What is the purpose of the setter method in Java?",
    "input": "A. To retrieve a value of a field\nB. To update or modify the value of a field\nC. To print the value of a field\nD. To hide the field from other classes",
    "output": "B"
},
{
    "instruction": "In encapsulation, what type of fields are usually declared as private?",
    "input": "A. Fields that should be accessed only by specific methods\nB. Fields that can be directly accessed by any class\nC. Fields that need to be inherited by subclasses\nD. Fields that store constant values",
    "output": "A"
},
{
    "instruction": "Which of the following is an advantage of encapsulation?",
    "input": "A. It prevents inheritance\nB. It ensures that data is only modified through well-defined methods\nC. It eliminates the need for methods\nD. It makes the class less flexible",
    "output": "B"
},
{
    "instruction": "In Java, which keyword would you use to access a method in a superclass from a subclass?",
    "input": "A. super\nB. private\nC. protected\nD. final",
    "output": "A"
},
{
    "instruction": "What does the concept of encapsulation help protect?",
    "input": "A. The programs variables\nB. The integrity of an object's state\nC. The inheritance of a class\nD. The method of polymorphism",
    "output": "B"
},
{
    "instruction": "Which of the following statements is correct about encapsulation?",
    "input": "A. It allows changes in the implementation without affecting other parts of the program\nB. It prevents all access to object data\nC. It requires that all methods be public\nD. It prevents inheritance of methods",
    "output": "A"
},
{
    "instruction": "What is a disadvantage of encapsulation?",
    "input": "A. It exposes all fields and methods\nB. It adds complexity to the design and development\nC. It allows direct access to private fields\nD. It encourages the use of public methods",
    "output": "B"
},
{
    "instruction": "In a well-encapsulated class, which of the following would be allowed?",
    "input": "A. Direct access to private variables\nB. Controlled access to private variables via methods\nC. Direct inheritance of private methods\nD. Open access to all class methods",
    "output": "B"
},
{
    "instruction": "Which of the following is a key benefit of encapsulation?",
    "input": "A. It increases code duplication\nB. It increases code complexity\nC. It reduces the chance of unauthorized data manipulation\nD. It removes the need for getters and setters",
    "output": "C"
},
{
    "instruction": "In Java, what happens if a field is not provided with a getter method in an encapsulated class?",
    "input": "A. The field can be accessed directly\nB. The field is hidden from other classes\nC. The field is automatically public\nD. The class cannot be compiled",
    "output": "B"
},
{
    "instruction": "Which of the following statements about encapsulation is true?",
    "input": "A. Encapsulation allows a class to protect its internal state and ensure its integrity\nB. Encapsulation requires that all fields are public\nC. Encapsulation only works with abstract classes\nD. Encapsulation restricts method overriding",
    "output": "A"
},
{
    "instruction": "What is an encapsulated class?",
    "input": "A. A class that hides all its fields and methods from any other class\nB. A class that allows direct access to its variables\nC. A class that uses a combination of getter and setter methods\nD. A class that does not allow inheritance",
    "output": "C"
},
{
    "instruction": "Which of the following is NOT true about encapsulation in object-oriented programming?",
    "input": "A. Encapsulation allows you to change the implementation without affecting the outside world\nB. Encapsulation hides the details of the internal workings of a class\nC. Encapsulation is only concerned with data hiding\nD. Encapsulation improves code maintainability",
    "output": "C"
},
{
    "instruction": "In encapsulation, how do you provide access to a private field outside of the class?",
    "input": "A. By using a getter method\nB. By using a public field\nC. By using inheritance\nD. By overriding the field",
    "output": "A"
},
{
    "instruction": "In an encapsulated class, which method can be used to ensure that a field is modified only in a valid way?",
    "input": "A. Getter method\nB. Setter method\nC. Constructor\nD. Destructor",
    "output": "B"
},
{
    "instruction": "Which of the following concepts is NOT directly related to encapsulation?",
    "input": "A. Data hiding\nB. Access modifiers\nC. Polymorphism\nD. Getter and setter methods",
    "output": "C"
},
{
    "instruction": "What is the purpose of using access modifiers in encapsulation?",
    "input": "A. To allow access to methods without restriction\nB. To restrict access to the internal state of an object\nC. To provide the ability to modify a class's state\nD. To allow data sharing between different classes",
    "output": "B"
},
{
    "instruction": "Encapsulation is the concept of binding the data and the methods that operate on the data together within a single unit known as a ______.",
    "input": "",
    "output": "class"
},
{
    "instruction": "In Java, to restrict access to a field outside the class, we use the ______ access modifier.",
    "input": "",
    "output": "private"
},
{
    "instruction": "The methods that provide controlled access to private fields are known as ______ methods.",
    "input": "",
    "output": "getter and setter"
},
{
    "instruction": "By using encapsulation, you can protect an object's internal state and only expose the necessary behavior through ______.",
    "input": "",
    "output": "public methods"
},
{
    "instruction": "The ______ method is used to retrieve the value of a private field in an encapsulated class.",
    "input": "",
    "output": "getter"
},
{
    "instruction": "The ______ method is used to set or modify the value of a private field in an encapsulated class.",
    "input": "",
    "output": "setter"
},
{
    "instruction": "If a class has private fields and public getter and setter methods, this is an example of ______ in object-oriented programming.",
    "input": "",
    "output": "encapsulation"
},
{
    "instruction": "In Java, the ______ access modifier allows access to class members from any other class.",
    "input": "",
    "output": "public"
},
{
    "instruction": "In encapsulation, the internal details of a class are hidden and only accessible through a ______ interface.",
    "input": "",
    "output": "public"
},
{
    "instruction": "The purpose of encapsulation is to safeguard the objects data from unauthorized ______.",
    "input": "",
    "output": "access"
},
{
    "instruction": "Encapsulation helps improve software maintenance by reducing the ______ of a class's internal implementation.",
    "input": "",
    "output": "complexity"
},
{
    "instruction": "To achieve encapsulation in Java, you should declare fields as ______ and provide public methods for accessing and modifying them.",
    "input": "",
    "output": "private"
},
{
    "instruction": "When encapsulating data in Java, one common approach is to use ______ methods to protect the internal state of the object.",
    "input": "",
    "output": "getter and setter"
},
{
    "instruction": "Encapsulation allows a programmer to change the internal implementation of a class without affecting the ______ of the class.",
    "input": "",
    "output": "interface"
},
{
    "instruction": "The principle of encapsulation leads to the concept of data ______, where the data is hidden from the user.",
    "input": "",
    "output": "hiding"
},
{
    "instruction": "Encapsulation in Java promotes the use of ______ methods to allow interaction with an object's data in a controlled manner.",
    "input": "",
    "output": "public"
},
{
    "instruction": "In encapsulation, an objects state is typically made private, and only specific ______ are provided to interact with it.",
    "input": "",
    "output": "methods"
},
{
    "instruction": "Encapsulation helps ensure that an objects internal state is not ______ by external classes without proper validation.",
    "input": "",
    "output": "modified"
},
{
    "instruction": "To provide controlled access to private fields in Java, one typically creates ______ methods.",
    "input": "",
    "output": "getter and setter"
},
{
    "instruction": "Encapsulation allows a class to change its internal implementation without affecting the ______ of the class to the outside world.",
    "input": "",
    "output": "behavior"
},
{
    "instruction": "The principle of encapsulation in Java is implemented by using the ______ keyword for class fields.",
    "input": "",
    "output": "private"
},
{
    "instruction": "A class that hides its internal data and provides public methods to access it is an example of ______ in object-oriented programming.",
    "input": "",
    "output": "encapsulation"
},
{
    "instruction": "In Java, a method that sets the value of a private field is called a ______ method.",
    "input": "",
    "output": "setter"
},
{
    "instruction": "Encapsulation improves code security by hiding the ______ of an object from other classes.",
    "input": "",
    "output": "implementation"
},
{
    "instruction": "When encapsulating data, it is important to provide ______ methods to access or modify private fields.",
    "input": "",
    "output": "public"
},
{
    "instruction": "One of the main advantages of encapsulation is that it allows the programmer to change the ______ of a class without affecting other parts of the program.",
    "input": "",
    "output": "implementation"
},
{
    "instruction": "To ensure that the internal state of an object is not modified incorrectly, the fields are often declared as ______ in encapsulation.",
    "input": "",
    "output": "private"
},
{
    "instruction": "Encapsulation allows classes to maintain control over their ______ by providing setter and getter methods.",
    "input": "",
    "output": "state"
},
{
    "instruction": "In Java, the ______ method is used to retrieve the value of a private field from an object.",
    "input": "",
    "output": "getter"
},
{
    "instruction": "The core concept of encapsulation is to hide the ______ of an object from other objects.",
    "input": "",
    "output": "details"
},
{
    "instruction": "By providing controlled access to the data using methods, encapsulation reduces the likelihood of data ______.",
    "input": "",
    "output": "corruption"
},
{
    "instruction": "In Java, the ______ access modifier allows access to class members only within the same class.",
    "input": "",
    "output": "private"
},
{
    "instruction": "When implementing encapsulation, it is essential to ensure that the internal data is accessed only through ______ methods.",
    "input": "",
    "output": "getter and setter"
},
{
    "instruction": "Encapsulation allows an object to hide its ______ from other objects, ensuring that only the necessary parts are accessible.",
    "input": "",
    "output": "state"
},
{
    "instruction": "In encapsulation, a class's fields are typically marked as ______ to prevent direct access from outside the class.",
    "input": "",
    "output": "private"
},
{
    "instruction": "In Java, the ______ keyword is used to make a method or field accessible to any other class.",
    "input": "",
    "output": "public"
},
{
    "instruction": "To ensure that the state of an object cannot be directly accessed or modified, we use the ______ modifier in encapsulation.",
    "input": "",
    "output": "private"
},
{
    "instruction": "The benefit of using encapsulation is that it allows a class to ______ its internal data and expose only necessary methods.",
    "input": "",
    "output": "protect"
},
{
    "instruction": "Encapsulation helps to achieve a high level of ______ in a program by controlling access to an object's data.",
    "input": "",
    "output": "security"
},
{
    "instruction": "In a well-encapsulated class, the internal state is kept private and is modified only by calling a ______ method.",
    "input": "",
    "output": "setter"
},
{
    "instruction": "In Java, to access the private fields of a class, you must use the ______ method that acts as an intermediary.",
    "input": "",
    "output": "getter"
},
{
    "instruction": "In encapsulation, the private fields of a class are not directly accessible from outside the class, which ensures ______ of the data.",
    "input": "",
    "output": "security"
},
{
    "instruction": "The encapsulation principle supports the idea of ______ by exposing only necessary methods to interact with an object's data.",
    "input": "",
    "output": "information hiding"
},
{
    "instruction": "In Java, to allow controlled modification of a private field, a class will typically have a ______ method.",
    "input": "",
    "output": "setter"
},
{
    "instruction": "Encapsulation helps to prevent unintended changes to the internal state of an object by using private fields and ______ methods.",
    "input": "",
    "output": "public"
},
{
    "instruction": "A class's private data can be modified only by using its ______ methods in encapsulation.",
    "input": "",
    "output": "setter"
},
{
    "instruction": "The use of encapsulation in programming makes the internal workings of an object ______ to the outside world.",
    "input": "",
    "output": "invisible"
},
{
    "instruction": "The main purpose of encapsulation is to achieve data ______ by preventing unauthorized access to an object's fields.",
    "input": "",
    "output": "protection"
},
{
    "instruction": "By using encapsulation, a class's internal state can only be changed through the methods it ______.",
    "input": "",
    "output": "exposes"
},
{
    "instruction": "The process of encapsulation involves bundling the data and methods that operate on the data into a ______.",
    "input": "",
    "output": "single unit"
},
{
    "instruction": "In Java, a class's fields can be declared as ______ to ensure they cannot be modified directly from outside the class.",
    "input": "",
    "output": "private"
},
{
    "instruction": "In encapsulation, the concept of providing controlled access to private fields using methods is called ______.",
    "input": "",
    "output": "accessor pattern"
},
{
    "instruction": "To make an objects fields mutable while still controlling access, the class can use ______ methods.",
    "input": "",
    "output": "setter and getter"
},
{
    "instruction": "Encapsulation allows you to restrict the ______ of data fields in a class to prevent unauthorized modification.",
    "input": "",
    "output": "visibility"
},
{
    "instruction": "A common advantage of encapsulation is that it reduces the complexity of a program by hiding unnecessary ______.",
    "input": "",
    "output": "details"
},
{
    "instruction": "In Java, encapsulation is achieved by using the ______ keyword to restrict direct access to fields and methods.",
    "input": "",
    "output": "private"
},
{
    "instruction": "The process of encapsulating data helps to provide flexibility for changing the internal structure without affecting ______.",
    "input": "",
    "output": "other parts of the program"
},
{
    "instruction": "Encapsulation supports the principle of ______ by allowing a class to define how its data can be accessed or modified.",
    "input": "",
    "output": "data abstraction"
},
{
    "instruction": "When encapsulating an object's data, we typically use a ______ method to retrieve its current value.",
    "input": "",
    "output": "getter"
},
{
    "instruction": "Encapsulation is a principle of object-oriented programming that restricts direct access to an object's data and only allows access through public methods.",
    "input": "",
    "output": "True"
},
{
    "instruction": "In encapsulation, the internal state of an object is directly accessible from outside the class.",
    "input": "",
    "output": "False"
},
{
    "instruction": "The primary purpose of encapsulation is to hide an object's internal state and protect it from unauthorized modification.",
    "input": "",
    "output": "True"
},
{
    "instruction": "Encapsulation allows classes to expose all their internal fields to external code for better accessibility.",
    "input": "",
    "output": "False"
},
{
    "instruction": "The process of encapsulation involves binding data and methods that operate on that data within a single unit or class.",
    "input": "",
    "output": "True"
},
{
    "instruction": "In Java, encapsulation is achieved by making fields public and providing getter and setter methods.",
    "input": "",
    "output": "False"
},
{
    "instruction": "Encapsulation helps to achieve data security by controlling access to private fields using getter and setter methods.",
    "input": "",
    "output": "True"
},
{
    "instruction": "The getter method is used to set the value of a private field in an encapsulated class.",
    "input": "",
    "output": "False"
},
{
    "instruction": "Encapsulation allows the programmer to change the internal implementation of a class without affecting its interface to other classes.",
    "input": "",
    "output": "True"
},
{
    "instruction": "In encapsulation, data can be accessed directly from outside the class by calling the public fields.",
    "input": "",
    "output": "False"
},
{
    "instruction": "Encapsulation is a key feature in object-oriented programming that promotes the idea of data hiding.",
    "input": "",
    "output": "True"
},
{
    "instruction": "In encapsulation, both fields and methods that access the fields should be private to maintain proper access control.",
    "input": "",
    "output": "False"
},
{
    "instruction": "By using encapsulation, the internal state of an object can be protected from accidental or unauthorized changes.",
    "input": "",
    "output": "True"
},
{
    "instruction": "Encapsulation reduces the complexity of a program by exposing all internal fields of a class to external classes.",
    "input": "",
    "output": "False"
},
{
    "instruction": "Encapsulation is an effective technique for controlling how data is accessed and modified in an object.",
    "input": "",
    "output": "True"
},
{
    "instruction": "In encapsulation, private fields can only be accessed and modified directly within the class they are defined in.",
    "input": "",
    "output": "True"
},
{
    "instruction": "Encapsulation helps maintain the integrity of an object's state by preventing it from being modified by external code.",
    "input": "",
    "output": "True"
},
{
    "instruction": "Encapsulation is only useful in programming languages that support object-oriented principles.",
    "input": "",
    "output": "True"
},
{
    "instruction": "With encapsulation, external code can freely modify the internal data of an object as long as it uses the public methods.",
    "input": "",
    "output": "False"
},
{
    "instruction": "In encapsulation, access to an object's internal state is only allowed through public methods, which are known as getter and setter methods.",
    "input": "",
    "output": "True"
},
{
    "instruction": "Encapsulation allows a class to control how its data is accessed and modified, which helps reduce the risk of data corruption.",
    "input": "",
    "output": "True"
},
{
    "instruction": "The encapsulation principle requires that all data within a class must be publicly accessible.",
    "input": "",
    "output": "False"
},
{
    "instruction": "In Java, encapsulation is implemented by declaring fields as private and providing public getter and setter methods.",
    "input": "",
    "output": "True"
},
{
    "instruction": "The purpose of encapsulation is to make the internal state of an object more accessible to other objects.",
    "input": "",
    "output": "False"
},
{
    "instruction": "Encapsulation helps in maintaining the consistency and integrity of an object's state by restricting unauthorized access to its data.",
    "input": "",
    "output": "True"
},
{
    "instruction": "Encapsulation in object-oriented programming promotes the concept of hiding unnecessary details from other objects.",
    "input": "",
    "output": "True"
},
{
    "instruction": "Encapsulation only applies to methods, not to the data or fields within a class.",
    "input": "",
    "output": "False"
},
{
    "instruction": "By using encapsulation, you can change the internal structure of an object without affecting the external code that uses it.",
    "input": "",
    "output": "True"
},
{
    "instruction": "The core idea behind encapsulation is to expose all data and methods to external users for better flexibility.",
    "input": "",
    "output": "False"
},
{
    "instruction": "Encapsulation allows you to encapsulate both the data (fields) and the methods that operate on the data within a single unit.",
    "input": "",
    "output": "True"
},
{
    "instruction": "Encapsulation ensures that all methods in a class are public and can be accessed by external code.",
    "input": "",
    "output": "False"
},
{
    "instruction": "Through encapsulation, an object's internal data is protected from direct access, and only specific methods can modify it.",
    "input": "",
    "output": "True"
},
{
    "instruction": "Encapsulation makes it easier to maintain a class by allowing changes to be made to its internal implementation without affecting other classes.",
    "input": "",
    "output": "True"
},
{
    "instruction": "In encapsulation, it is important for methods to be private so they cannot be accessed by external code.",
    "input": "",
    "output": "False"
},
{
    "instruction": "Encapsulation provides a way to restrict access to the internal state of an object, which helps in controlling the way data is modified.",
    "input": "",
    "output": "True"
},
{
    "instruction": "Encapsulation can help prevent issues like unauthorized access and unexpected changes to the internal state of an object.",
    "input": "",
    "output": "True"
},
{
    "instruction": "The encapsulation principle allows for easier debugging by providing clear boundaries between the internal and external interfaces of a class.",
    "input": "",
    "output": "True"
},
{
    "instruction": "Encapsulation is not a useful concept in modern object-oriented programming languages.",
    "input": "",
    "output": "False"
},
{
    "instruction": "Encapsulation is an object-oriented programming principle that involves combining data and methods into a single unit, called a class.",
    "input": "",
    "output": "True"
},
{
    "instruction": "Encapsulation ensures that the internal implementation details of a class are hidden from other classes, protecting the data from unauthorized access.",
    "input": "",
    "output": "True"
},
{
    "instruction": "Encapsulation eliminates the need for getter and setter methods in object-oriented programming.",
    "input": "",
    "output": "False"
},
{
    "instruction": "By applying encapsulation, a class can ensure that its internal data is protected and accessed in a controlled manner.",
    "input": "",
    "output": "True"
},
{
    "instruction": "Encapsulation requires that methods within a class are always public and accessible from any other class.",
    "input": "",
    "output": "False"
},
{
    "instruction": "Through encapsulation, a class's private data can only be accessed and modified by its public methods.",
    "input": "",
    "output": "True"
},
{
    "instruction": "Encapsulation enables external code to freely manipulate an object's private fields, as long as the correct methods are used.",
    "input": "",
    "output": "True"
},
{
    "instruction": "In encapsulation, public fields can be directly modified by external code.",
    "input": "",
    "output": "False"
},
{
    "instruction": "Encapsulation is important for achieving modularity and code reusability in object-oriented programming.",
    "input": "",
    "output": "True"
},
{
    "instruction": "Encapsulation involves keeping both the internal data and methods that modify the data visible and accessible from outside the class.",
    "input": "",
    "output": "False"
},
{
    "instruction": "What is the time complexity of binary search in a sorted array of n elements?",
    "input": "A) O(n)\nB) O(n log n)\nC) O(log n)\nD) O(1)",
    "output": "C) O(log n)"
},
{
    "instruction": "Which of the following algorithms has a time complexity of O(n^2) in its worst case?",
    "input": "A) Merge Sort\nB) Quick Sort\nC) Bubble Sort\nD) Counting Sort",
    "output": "C) Bubble Sort"
},
{
    "instruction": "What is the best-case time complexity of Quick Sort?",
    "input": "A) O(n^2)\nB) O(n log n)\nC) O(log n)\nD) O(n)",
    "output": "B) O(n log n)"
},
{
    "instruction": "What is the space complexity of a recursive algorithm with O(n) calls on the call stack?",
    "input": "A) O(n)\nB) O(log n)\nC) O(n^2)\nD) O(1)",
    "output": "A) O(n)"
},
{
    "instruction": "Which algorithm has a time complexity of O(1) for access operations?",
    "input": "A) Hash Table\nB) Linked List\nC) Binary Search Tree\nD) Array",
    "output": "A) Hash Table"
},
{
    "instruction": "What is the worst-case time complexity of Merge Sort?",
    "input": "A) O(n)\nB) O(log n)\nC) O(n log n)\nD) O(n^2)",
    "output": "C) O(n log n)"
},
{
    "instruction": "What is the space complexity of Merge Sort?",
    "input": "A) O(n)\nB) O(log n)\nC) O(n log n)\nD) O(n^2)",
    "output": "A) O(n)"
},
{
    "instruction": "Which algorithm has a worst-case time complexity of O(n^2)?",
    "input": "A) Merge Sort\nB) Quick Sort\nC) Heap Sort\nD) Insertion Sort",
    "output": "D) Insertion Sort"
},
{
    "instruction": "What is the space complexity of an iterative algorithm?",
    "input": "A) O(1)\nB) O(n)\nC) O(log n)\nD) O(n^2)",
    "output": "A) O(1)"
},
{
    "instruction": "Which algorithm has a time complexity of O(n log n) in all cases?",
    "input": "A) Merge Sort\nB) Bubble Sort\nC) Quick Sort\nD) Selection Sort",
    "output": "A) Merge Sort"
},
{
    "instruction": "What is the average-case time complexity of Quick Sort?",
    "input": "A) O(n^2)\nB) O(n log n)\nC) O(log n)\nD) O(n)",
    "output": "B) O(n log n)"
},
{
    "instruction": "Which of the following data structures has O(log n) insertion time complexity?",
    "input": "A) Array\nB) Binary Search Tree\nC) Linked List\nD) Hash Table",
    "output": "B) Binary Search Tree"
},
{
    "instruction": "What is the time complexity of accessing an element in an array?",
    "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n log n)",
    "output": "A) O(1)"
},
{
    "instruction": "Which sorting algorithm has a best-case time complexity of O(n)?",
    "input": "A) Selection Sort\nB) Insertion Sort\nC) Merge Sort\nD) Quick Sort",
    "output": "B) Insertion Sort"
},
{
    "instruction": "What is the worst-case time complexity of searching in a linked list?",
    "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n^2)",
    "output": "C) O(n)"
},
{
    "instruction": "What is the time complexity of linear search?",
    "input": "A) O(n)\nB) O(log n)\nC) O(n log n)\nD) O(1)",
    "output": "A) O(n)"
},
{
    "instruction": "Which data structure has a time complexity of O(log n) for search operations?",
    "input": "A) Stack\nB) Queue\nC) Binary Search Tree\nD) Array",
    "output": "C) Binary Search Tree"
},
{
    "instruction": "What is the space complexity of a stack implemented using an array of size n?",
    "input": "A) O(n)\nB) O(log n)\nC) O(n^2)\nD) O(1)",
    "output": "A) O(n)"
},
{
    "instruction": "Which algorithm has a time complexity of O(n) for traversal?",
    "input": "A) Binary Search\nB) Depth First Search\nC) Binary Search Tree\nD) Quick Sort",
    "output": "B) Depth First Search"
},
{
    "instruction": "What is the best-case time complexity of linear search?",
    "input": "A) O(n)\nB) O(1)\nC) O(log n)\nD) O(n^2)",
    "output": "B) O(1)"
},
{
    "instruction": "Which sorting algorithm has the worst-case time complexity of O(n^2)?",
    "input": "A) Quick Sort\nB) Merge Sort\nC) Heap Sort\nD) Bubble Sort",
    "output": "D) Bubble Sort"
},
{
    "instruction": "What is the time complexity of appending an item to an array?",
    "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n log n)",
    "output": "A) O(1)"
},
{
    "instruction": "Which algorithm has a space complexity of O(log n) due to recursive calls?",
    "input": "A) Bubble Sort\nB) Quick Sort\nC) Merge Sort\nD) Counting Sort",
    "output": "B) Quick Sort"
},
{
    "instruction": "What is the space complexity of depth-first search (DFS) using recursion?",
    "input": "A) O(1)\nB) O(n)\nC) O(log n)\nD) O(n^2)",
    "output": "B) O(n)"
},
{
    "instruction": "Which data structure supports both O(1) insertion and deletion?",
    "input": "A) Array\nB) Stack\nC) Queue\nD) Linked List",
    "output": "D) Linked List"
},
{
    "instruction": "What is the time complexity of removing an element from a linked list?",
    "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n log n)",
    "output": "A) O(1)"
},
{
    "instruction": "Which algorithm has an average-case time complexity of O(n log n)?",
    "input": "A) Bubble Sort\nB) Insertion Sort\nC) Quick Sort\nD) Counting Sort",
    "output": "C) Quick Sort"
},
{
    "instruction": "What is the time complexity of binary search in a balanced binary search tree?",
    "input": "A) O(1)\nB) O(n)\nC) O(log n)\nD) O(n log n)",
    "output": "C) O(log n)"
},
{
    "instruction": "Which data structure has an average-case time complexity of O(1) for insertion?",
    "input": "A) Array\nB) Stack\nC) Queue\nD) Hash Table",
    "output": "D) Hash Table"
},
{
    "instruction": "What is the best-case time complexity of bubble sort?",
    "input": "A) O(n)\nB) O(n log n)\nC) O(log n)\nD) O(n^2)",
    "output": "A) O(n)"
},
{
    "instruction": "Which data structure provides constant time complexity for search operations on average?",
    "input": "A) Stack\nB) Linked List\nC) Hash Table\nD) Binary Search Tree",
    "output": "C) Hash Table"
},
{
    "instruction": "What is the worst-case time complexity of insertion in a binary search tree?",
    "input": "A) O(n)\nB) O(log n)\nC) O(1)\nD) O(n^2)",
    "output": "A) O(n)"
},
{
    "instruction": "Which algorithms time complexity does not depend on the size of the input?",
    "input": "A) Constant-time algorithm\nB) Linear algorithm\nC) Quadratic algorithm\nD) Exponential algorithm",
    "output": "A) Constant-time algorithm"
},
{
    "instruction": "What is the time complexity of searching an unsorted array?",
    "input": "A) O(1)\nB) O(n)\nC) O(log n)\nD) O(n log n)",
    "output": "B) O(n)"
},
{
    "instruction": "What is the space complexity of an algorithm that only uses a fixed number of variables?",
    "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n^2)",
    "output": "A) O(1)"
},
{
    "instruction": "Which sorting algorithm has an average time complexity of O(n^2)?",
    "input": "A) Quick Sort\nB) Merge Sort\nC) Selection Sort\nD) Heap Sort",
    "output": "C) Selection Sort"
},
{
    "instruction": "What is the best-case time complexity of selection sort?",
    "input": "A) O(1)\nB) O(n)\nC) O(n log n)\nD) O(n^2)",
    "output": "D) O(n^2)"
},
{
    "instruction": "Which algorithm has O(n) space complexity due to storing an additional array?",
    "input": "A) Bubble Sort\nB) Merge Sort\nC) Quick Sort\nD) Selection Sort",
    "output": "B) Merge Sort"
},
{
    "instruction": "What is the average-case time complexity of searching in a hash table?",
    "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n log n)",
    "output": "A) O(1)"
},
{
    "instruction": "Which of the following has a logarithmic time complexity?",
    "input": "A) Linear search\nB) Binary search\nC) Bubble sort\nD) Selection sort",
    "output": "B) Binary search"
},
{
    "instruction": "What is the worst-case time complexity for searching an element in a sorted array using binary search?",
    "input": "A) O(1)\nB) O(n)\nC) O(log n)\nD) O(n^2)",
    "output": "C) O(log n)"
},
{
    "instruction": "Which sorting algorithm has a worst-case time complexity of O(n log n)?",
    "input": "A) Merge Sort\nB) Insertion Sort\nC) Selection Sort\nD) Bubble Sort",
    "output": "A) Merge Sort"
},
{
    "instruction": "What is the space complexity of Merge Sort?",
    "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n log n)",
    "output": "C) O(n)"
},
{
    "instruction": "Which data structure is known for its O(1) average time complexity for searching?",
    "input": "A) Binary Tree\nB) Linked List\nC) Hash Table\nD) Array",
    "output": "C) Hash Table"
},
{
    "instruction": "What is the best-case time complexity of quicksort?",
    "input": "A) O(n log n)\nB) O(n^2)\nC) O(n)\nD) O(log n)",
    "output": "A) O(n log n)"
},
{
    "instruction": "In a balanced binary search tree, what is the worst-case time complexity for search?",
    "input": "A) O(n)\nB) O(log n)\nC) O(n log n)\nD) O(1)",
    "output": "B) O(log n)"
},
{
    "instruction": "What is the time complexity of reversing a linked list?",
    "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n^2)",
    "output": "C) O(n)"
},
{
    "instruction": "Which of the following algorithms has a best-case time complexity of O(n)?",
    "input": "A) Merge Sort\nB) Quick Sort\nC) Bubble Sort\nD) Insertion Sort",
    "output": "D) Insertion Sort"
},
{
    "instruction": "What is the time complexity of finding the maximum element in an unsorted array?",
    "input": "A) O(1)\nB) O(n)\nC) O(log n)\nD) O(n^2)",
    "output": "B) O(n)"
},
{
    "instruction": "The time complexity of adding an element to a balanced binary search tree is:",
    "input": "A) O(1)\nB) O(n)\nC) O(log n)\nD) O(n log n)",
    "output": "C) O(log n)"
},
{
    "instruction": "What is the time complexity of accessing an element in an array by index?",
    "input": "A) O(1)\nB) O(n)\nC) O(log n)\nD) O(n^2)",
    "output": "A) O(1)"
},
{
    "instruction": "What is the worst-case time complexity for inserting an element into a linked list at the head?",
    "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n^2)",
    "output": "A) O(1)"
},
{
    "instruction": "What is the average-case time complexity of searching for an element in an unsorted linked list?",
    "input": "A) O(1)\nB) O(n)\nC) O(log n)\nD) O(n log n)",
    "output": "B) O(n)"
},
{
    "instruction": "What is the time complexity for merging two sorted arrays of size n?",
    "input": "A) O(1)\nB) O(n)\nC) O(n log n)\nD) O(2n)",
    "output": "B) O(n)"
},
{
    "instruction": "What is the time complexity of inserting an element at a specific index in an array?",
    "input": "A) O(1)\nB) O(n)\nC) O(log n)\nD) O(n^2)",
    "output": "B) O(n)"
},
{
    "instruction": "What is the space complexity of a recursive function that requires no additional data structures?",
    "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n^2)",
    "output": "C) O(n)"
},
{
    "instruction": "Which algorithm has the best-case time complexity of O(log n)?",
    "input": "A) Bubble Sort\nB) Quick Sort\nC) Binary Search\nD) Selection Sort",
    "output": "C) Binary Search"
},
{
    "instruction": "In Big-O notation, what does the 'O' represent?",
    "input": "A) Order of magnitude\nB) Original complexity\nC) Optimal complexity\nD) Objective complexity",
    "output": "A) Order of magnitude"
},
{
    "instruction": "What is the worst-case time complexity of searching in a hash table with chaining?",
    "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n log n)",
    "output": "C) O(n)"
},
{
    "instruction": "Which sorting algorithm has the worst-case time complexity of O(n^2) but a best-case of O(n)?",
    "input": "A) Insertion Sort\nB) Merge Sort\nC) Quick Sort\nD) Heap Sort",
    "output": "A) Insertion Sort"
},
{
    "instruction": "What is the time complexity of checking if an element exists in a binary search tree?",
    "input": "A) O(1)\nB) O(n)\nC) O(log n)\nD) O(n^2)",
    "output": "C) O(log n)"
},
{
    "instruction": "What is the space complexity of the Fibonacci sequence using memoization?",
    "input": "A) O(1)\nB) O(n)\nC) O(log n)\nD) O(n^2)",
    "output": "B) O(n)"
},
{
    "instruction": "Which of these algorithms has a worst-case time complexity of O(n^2)?",
    "input": "A) Quick Sort\nB) Merge Sort\nC) Heap Sort\nD) Bubble Sort",
    "output": "D) Bubble Sort"
},
{
    "instruction": "What is the time complexity of inserting an element in a dynamic array?",
    "input": "A) O(1) amortized\nB) O(n)\nC) O(log n)\nD) O(n^2)",
    "output": "A) O(1) amortized"
},
{
    "instruction": "In Big-O notation, which of the following denotes a constant time complexity?",
    "input": "A) O(n)\nB) O(log n)\nC) O(1)\nD) O(n^2)",
    "output": "C) O(1)"
},
{
    "instruction": "Which data structure has an average-case time complexity of O(log n) for insertion?",
    "input": "A) Linked List\nB) Array\nC) Binary Search Tree\nD) Hash Table",
    "output": "C) Binary Search Tree"
},
{
    "instruction": "What is the best-case time complexity of Bubble Sort?",
    "input": "A) O(1)\nB) O(n)\nC) O(log n)\nD) O(n^2)",
    "output": "B) O(n)"
},
{
    "instruction": "What is the time complexity of searching in a sorted linked list?",
    "input": "A) O(1)\nB) O(n)\nC) O(log n)\nD) O(n^2)",
    "output": "B) O(n)"
},
{
    "instruction": "The space complexity of a simple recursive function (no extra data structures) is typically:",
    "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n^2)",
    "output": "C) O(n)"
},
{
    "instruction": "In which case does Quick Sort perform the worst?",
    "input": "A) When the pivot divides the array into two equal halves\nB) When the pivot is always the smallest or largest element\nC) When the array is already sorted\nD) When the array has duplicate elements",
    "output": "B) When the pivot is always the smallest or largest element"
},
{
    "instruction": "What is the worst-case time complexity of an AVL tree search operation?",
    "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n log n)",
    "output": "B) O(log n)"
},
{
    "instruction": "Which sorting algorithm has an average-case time complexity of O(n log n)?",
    "input": "A) Quick Sort\nB) Bubble Sort\nC) Selection Sort\nD) Insertion Sort",
    "output": "A) Quick Sort"
},
{
    "instruction": "What is the time complexity of traversing a binary tree?",
    "input": "A) O(1)\nB) O(n)\nC) O(log n)\nD) O(n^2)",
    "output": "B) O(n)"
},
{
    "instruction": "What is the space complexity of Depth-First Search (DFS) in an undirected graph?",
    "input": "A) O(1)\nB) O(n)\nC) O(n + e)\nD) O(n^2)",
    "output": "C) O(n + e)"
},
{
    "instruction": "Which of these data structures has the best-case time complexity for deletion as O(1)?",
    "input": "A) Binary Search Tree\nB) Linked List (at the head)\nC) Array\nD) Stack",
    "output": "B) Linked List (at the head)"
},
{
    "instruction": "In which scenario does linear search outperform binary search?",
    "input": "A) When the list is sorted\nB) When the list is unsorted\nC) When the list has duplicate elements\nD) Binary search always outperforms linear search",
    "output": "B) When the list is unsorted"
},
{
    "instruction": "What is the average time complexity of accessing an element in a hash table?",
    "input": "A) O(1)\nB) O(log n)\nC) O(n)\nD) O(n log n)",
    "output": "A) O(1)"
},
{
    "instruction": "The space complexity of an algorithm refers to:",
    "input": "A) The amount of time taken by an algorithm\nB) The number of variables declared\nC) The amount of memory used by an algorithm\nD) The disk space required",
    "output": "C) The amount of memory used by an algorithm"
},
{
    "instruction": "What is the time complexity of finding the middle element in a linked list?",
    "input": "A) O(1)\nB) O(n)\nC) O(log n)\nD) O(n^2)",
    "output": "B) O(n)"
},
{
    "instruction": "Which data structure has a time complexity of O(1) for inserting at the end?",
    "input": "A) Array\nB) Linked List\nC) Stack\nD) Queue",
    "output": "B) Linked List"
},
{
    "instruction": "What is the time complexity of a binary search algorithm?",
    "input": "A) O(n)\nB) O(log n)\nC) O(n^2)\nD) O(1)",
    "output": "B"
},
{
    "instruction": "Which of the following is a characteristic of a greedy algorithm?",
    "input": "A) It always solves the problem optimally\nB) It looks for the best solution at each step without considering the global solution\nC) It needs backtracking\nD) It uses dynamic programming",
    "output": "B"
},
{
    "instruction": "Which sorting algorithm is considered the most efficient in the average case for large datasets?",
    "input": "A) Bubble Sort\nB) Merge Sort\nC) Quick Sort\nD) Selection Sort",
    "output": "C"
},
{
    "instruction": "What does the term 'divide and conquer' refer to in algorithm design?",
    "input": "A) Solving problems by dividing them into smaller sub-problems\nB) Using brute force to solve a problem\nC) Combining multiple algorithms to solve a problem\nD) Trying all possible solutions",
    "output": "A"
},
{
    "instruction": "Which algorithm is used for finding the shortest path in a weighted graph?",
    "input": "A) Prim's Algorithm\nB) Kruskal's Algorithm\nC) Dijkstra's Algorithm\nD) Floyd-Warshall Algorithm",
    "output": "C"
},
{
    "instruction": "Which data structure is typically used for implementing a breadth-first search algorithm?",
    "input": "A) Stack\nB) Queue\nC) Linked List\nD) Tree",
    "output": "B"
},
{
    "instruction": "Which algorithm is typically used to solve the knapsack problem?",
    "input": "A) Greedy Algorithm\nB) Dynamic Programming\nC) Backtracking\nD) Divide and Conquer",
    "output": "B"
},
{
    "instruction": "Which of the following is true about a bubble sort algorithm?",
    "input": "A) It has a time complexity of O(n^2) in the worst case\nB) It is the most efficient sorting algorithm\nC) It performs better than Quick Sort\nD) It uses a divide and conquer approach",
    "output": "A"
},
{
    "instruction": "What is the main idea behind the dynamic programming approach?",
    "input": "A) Reuse solutions to sub-problems\nB) Divide the problem into two equal parts\nC) Use greedy choices to find the optimal solution\nD) Try all possible solutions to find the best one",
    "output": "A"
},
{
    "instruction": "What is the time complexity of an insertion sort algorithm in the worst case?",
    "input": "A) O(n)\nB) O(n^2)\nC) O(log n)\nD) O(n log n)",
    "output": "B"
},
{
    "instruction": "Which of the following is the correct description of the merge sort algorithm?",
    "input": "A) It uses a divide and conquer strategy\nB) It works by repeatedly comparing and swapping adjacent elements\nC) It is a type of greedy algorithm\nD) It uses dynamic programming",
    "output": "A"
},
{
    "instruction": "In a depth-first search algorithm, which data structure is typically used?",
    "input": "A) Stack\nB) Queue\nC) Linked List\nD) Array",
    "output": "A"
},
{
    "instruction": "What is the worst-case time complexity of Quick Sort?",
    "input": "A) O(n)\nB) O(n log n)\nC) O(n^2)\nD) O(log n)",
    "output": "C"
},
{
    "instruction": "Which of the following algorithms is used for solving the traveling salesman problem?",
    "input": "A) Dynamic Programming\nB) Greedy Algorithm\nC) Branch and Bound\nD) All of the above",
    "output": "D"
},
{
    "instruction": "Which of the following is an example of a divide and conquer algorithm?",
    "input": "A) Merge Sort\nB) Bubble Sort\nC) Insertion Sort\nD) Selection Sort",
    "output": "A"
},
{
    "instruction": "Which of the following statements is true about the Dijkstra algorithm?",
    "input": "A) It works only with negative edge weights\nB) It finds the shortest path in a graph with positive edge weights\nC) It uses a greedy approach but not dynamic programming\nD) It finds the shortest path in a directed graph only",
    "output": "B"
},
{
    "instruction": "Which algorithm is used for finding the minimum spanning tree in a graph?",
    "input": "A) Dijkstra's Algorithm\nB) Kruskal's Algorithm\nC) Bellman-Ford Algorithm\nD) Floyd-Warshall Algorithm",
    "output": "B"
},
{
    "instruction": "Which of the following is a limitation of the greedy algorithm?",
    "input": "A) It does not guarantee an optimal solution\nB) It solves all problems efficiently\nC) It requires a lot of memory\nD) It always produces the optimal solution",
    "output": "A"
},
{
    "instruction": "Which sorting algorithm has a time complexity of O(n log n) in the worst case?",
    "input": "A) Merge Sort\nB) Quick Sort\nC) Heap Sort\nD) Both A and C",
    "output": "D"
},
{
    "instruction": "Which of the following algorithms is an example of a backtracking algorithm?",
    "input": "A) Merge Sort\nB) Dijkstra's Algorithm\nC) Knapsack Problem\nD) N-Queens Problem",
    "output": "D"
},
{
    "instruction": "What is the worst-case time complexity of the heap sort algorithm?",
    "input": "A) O(n log n)\nB) O(n^2)\nC) O(n)\nD) O(log n)",
    "output": "A"
},
{
    "instruction": "Which algorithm is primarily used for searching in a sorted array?",
    "input": "A) Linear Search\nB) Binary Search\nC) Bubble Sort\nD) Merge Sort",
    "output": "B"
},
{
    "instruction": "Which of the following algorithms is not considered an optimal sorting algorithm?",
    "input": "A) Quick Sort\nB) Merge Sort\nC) Bubble Sort\nD) Heap Sort",
    "output": "C"
},
{
    "instruction": "What is the primary characteristic of the merge sort algorithm?",
    "input": "A) It sorts the elements by dividing the array into two halves\nB) It uses a greedy approach to find the optimal solution\nC) It works by repeatedly swapping adjacent elements\nD) It has a time complexity of O(n^2)",
    "output": "A"
},
{
    "instruction": "Which of the following best describes a depth-first search (DFS) algorithm?",
    "input": "A) It explores the graph level by level\nB) It explores the graph by following the longest path first\nC) It explores the graph by traversing down each branch before backtracking\nD) It works by applying a greedy approach",
    "output": "C"
},
{
    "instruction": "Which algorithm is considered optimal for solving the single-source shortest path problem in graphs with non-negative edge weights?",
    "input": "A) Bellman-Ford\nB) Dijkstra's Algorithm\nC) Floyd-Warshall Algorithm\nD) Kruskal's Algorithm",
    "output": "B"
},
{
    "instruction": "In which case is the merge sort algorithm inefficient?",
    "input": "A) For large datasets\nB) For small datasets\nC) When the array is already sorted\nD) For arrays with a large number of duplicates",
    "output": "B"
},
{
    "instruction": "Which algorithm uses the divide and conquer technique to solve problems by dividing them into sub-problems that are easier to solve individually?",
    "input": "A) Merge Sort\nB) Selection Sort\nC) Heap Sort\nD) Bubble Sort",
    "output": "A"
},
{
    "instruction": "In a graph, what does a breadth-first search (BFS) algorithm explore?",
    "input": "A) Neighbors of the starting vertex first\nB) Neighbors of the last visited vertex\nC) The longest path first\nD) The shortest path first",
    "output": "A"
},
{
    "instruction": "Which of the following algorithms is not based on dynamic programming?",
    "input": "A) Knapsack Problem\nB) Fibonacci Sequence\nC) Dijkstra's Algorithm\nD) Longest Common Subsequence",
    "output": "C"
},
{
    "instruction": "Which sorting algorithm is considered an in-place sorting algorithm?",
    "input": "A) Merge Sort\nB) Quick Sort\nC) Heap Sort\nD) All of the above",
    "output": "B"
},
{
    "instruction": "Which of the following is a disadvantage of the quick sort algorithm?",
    "input": "A) It is not stable\nB) It has a high time complexity in the worst case\nC) It uses a lot of memory\nD) It cannot be used on large datasets",
    "output": "B"
},
{
    "instruction": "Which of the following is an example of a greedy algorithm?",
    "input": "A) Merge Sort\nB) Dijkstra's Algorithm\nC) Prim's Algorithm\nD) Knapsack Problem",
    "output": "C"
},
{
    "instruction": "Which of the following is a requirement for the binary search algorithm to work?",
    "input": "A) The array must be sorted\nB) The array must have distinct elements\nC) The array must have a length of 2\nD) The array must be unsorted",
    "output": "A"
},
{
    "instruction": "Which of the following algorithms is used to solve the minimum spanning tree problem?",
    "input": "A) Bellman-Ford\nB) Prim's Algorithm\nC) Dijkstra's Algorithm\nD) Floyd-Warshall Algorithm",
    "output": "B"
},
{
    "instruction": "What is the space complexity of the quick sort algorithm?",
    "input": "A) O(1)\nB) O(n)\nC) O(log n)\nD) O(n log n)",
    "output": "C"
},
{
    "instruction": "What is the time complexity of the binary search algorithm?",
    "input": "A) O(n)\nB) O(log n)\nC) O(n^2)\nD) O(1)",
    "output": "B"
},
{
    "instruction": "Which of the following algorithms is not based on the divide and conquer paradigm?",
    "input": "A) Merge Sort\nB) Quick Sort\nC) Heap Sort\nD) Binary Search",
    "output": "C"
},
{
    "instruction": "Which of the following sorting algorithms is stable?",
    "input": "A) Merge Sort\nB) Quick Sort\nC) Heap Sort\nD) Selection Sort",
    "output": "A"
},
{
    "instruction": "Which of the following problems can be solved using dynamic programming?",
    "input": "A) Fibonacci Sequence\nB) Longest Common Subsequence\nC) 0/1 Knapsack\nD) All of the above",
    "output": "D"
},
{
    "instruction": "What is the time complexity of the bubble sort algorithm in the worst case?",
    "input": "A) O(n^2)\nB) O(n log n)\nC) O(n)\nD) O(log n)",
    "output": "A"
},
{
    "instruction": "Which of the following algorithms is not used to find the shortest path in a graph?",
    "input": "A) Dijkstra's Algorithm\nB) Bellman-Ford Algorithm\nC) Prim's Algorithm\nD) Floyd-Warshall Algorithm",
    "output": "C"
},
{
    "instruction": "Which sorting algorithm divides the data into smaller chunks, sorts them and then merges them back together?",
    "input": "A) Quick Sort\nB) Merge Sort\nC) Heap Sort\nD) Insertion Sort",
    "output": "B"
},
{
    "instruction": "Which of the following algorithms is used to solve the traveling salesman problem?",
    "input": "A) Dijkstra's Algorithm\nB) Dynamic Programming\nC) Greedy Algorithm\nD) Nearest Neighbor Algorithm",
    "output": "B"
},
{
    "instruction": "Which of the following is a divide-and-conquer sorting algorithm?",
    "input": "A) Quick Sort\nB) Bubble Sort\nC) Insertion Sort\nD) Selection Sort",
    "output": "A"
},
{
    "instruction": "Which algorithm is most suitable for finding the shortest path in a weighted graph with negative weights?",
    "input": "A) Dijkstra's Algorithm\nB) Bellman-Ford Algorithm\nC) Floyd-Warshall Algorithm\nD) Kruskal's Algorithm",
    "output": "B"
},
{
    "instruction": "What is the time complexity of the insertion sort algorithm in the worst case?",
    "input": "A) O(n^2)\nB) O(n log n)\nC) O(n)\nD) O(log n)",
    "output": "A"
},
{
    "instruction": "Which of the following is the most efficient algorithm for finding the median of a list of numbers?",
    "input": "A) Quick Sort\nB) Merge Sort\nC) Median of Medians\nD) Heap Sort",
    "output": "C"
},
{
    "instruction": "Which algorithm finds the maximum flow in a flow network?",
    "input": "A) Dijkstra's Algorithm\nB) Ford-Fulkerson Algorithm\nC) Bellman-Ford Algorithm\nD) Prim's Algorithm",
    "output": "B"
},
{
    "instruction": "Which of the following best describes a greedy algorithm?",
    "input": "A) It solves the problem by breaking it into smaller sub-problems\nB) It makes the optimal choice at each step in hopes of finding the global optimum\nC) It explores all possible solutions before selecting the best one\nD) It requires dynamic programming to solve",
    "output": "B"
},
{
    "instruction": "In which case is the merge sort algorithm the most efficient?",
    "input": "A) For small datasets\nB) For datasets with a large number of duplicates\nC) For large datasets that need to be sorted in parallel\nD) For datasets with random access patterns",
    "output": "C"
},
{
    "instruction": "What is the space complexity of the merge sort algorithm?",
    "input": "A) O(1)\nB) O(n)\nC) O(log n)\nD) O(n log n)",
    "output": "B"
},
{
    "instruction": "Which algorithm is used to find the longest increasing subsequence in an array?",
    "input": "A) Quick Sort\nB) Merge Sort\nC) Dynamic Programming\nD) Binary Search",
    "output": "C"
},
{
    "instruction": "Which algorithm is used to find the most efficient path through a grid?",
    "input": "A) Dijkstra's Algorithm\nB) A* Algorithm\nC) Bellman-Ford Algorithm\nD) Floyd-Warshall Algorithm",
    "output": "B"
},
{
    "instruction": "Which of the following algorithms uses a priority queue to find the shortest path in a graph?",
    "input": "A) Dijkstra's Algorithm\nB) Kruskal's Algorithm\nC) Bellman-Ford Algorithm\nD) Floyd-Warshall Algorithm",
    "output": "A"
},
{
    "instruction": "Which of the following is true about the quick sort algorithm?",
    "input": "A) It always selects the median as the pivot element\nB) It has an average time complexity of O(n log n)\nC) It is a stable sorting algorithm\nD) It is not efficient on large datasets",
    "output": "B"
},
{
    "instruction": "Which algorithm is most efficient for finding the minimum spanning tree in a graph?",
    "input": "A) Kruskal's Algorithm\nB) Dijkstra's Algorithm\nC) Bellman-Ford Algorithm\nD) Floyd-Warshall Algorithm",
    "output": "A"
},
{
    "instruction": "Which of the following algorithms is used for the knapsack problem?",
    "input": "A) Greedy Algorithm\nB) Dynamic Programming\nC) Both A and B\nD) Neither A nor B",
    "output": "B"
},
{
    "instruction": "What is the time complexity of the heap sort algorithm?",
    "input": "A) O(n log n)\nB) O(n)\nC) O(n^2)\nD) O(log n)",
    "output": "A"
},
{
    "instruction": "What is the time complexity of the binary search algorithm in the worst case?",
    "input": "A) O(n^2)\nB) O(log n)\nC) O(n log n)\nD) O(n)",
    "output": "B"
},
{
    "instruction": "Which of the following is an example of a divide-and-conquer algorithm?",
    "input": "A) Merge Sort\nB) Insertion Sort\nC) Quick Sort\nD) Both A and C",
    "output": "D"
},
{
    "instruction": "Which algorithm is commonly used to solve the problem of finding the shortest path in a graph with positive edge weights?",
    "input": "A) Bellman-Ford Algorithm\nB) Dijkstra's Algorithm\nC) Kruskal's Algorithm\nD) Prim's Algorithm",
    "output": "B"
},
{
    "instruction": "What is the space complexity of the quicksort algorithm?",
    "input": "A) O(1)\nB) O(n)\nC) O(log n)\nD) O(n log n)",
    "output": "C"
},
{
    "instruction": "Which of the following algorithms is best suited for sorting a list of items with few elements?",
    "input": "A) Merge Sort\nB) Quick Sort\nC) Insertion Sort\nD) Heap Sort",
    "output": "C"
},
{
    "instruction": "Which of the following algorithms uses a recursive approach?",
    "input": "A) Quick Sort\nB) Merge Sort\nC) Binary Search\nD) All of the above",
    "output": "D"
},
{
    "instruction": "Which data structure is primarily used by Dijkstra's Algorithm?",
    "input": "A) Stack\nB) Queue\nC) Priority Queue\nD) Hash Map",
    "output": "C"
},
{
    "instruction": "Which of the following best describes the time complexity of an algorithm with O(n log n) time complexity?",
    "input": "A) The time taken increases linearly with the input size\nB) The time taken increases logarithmically with the input size\nC) The time taken increases logarithmically squared with the input size\nD) The time taken increases faster than linear but slower than quadratic",
    "output": "D"
},
{
    "instruction": "In the context of dynamic programming, what is memoization?",
    "input": "A) A technique used to reduce the space complexity\nB) A technique used to store intermediate results to avoid redundant computations\nC) A technique used to minimize the time complexity of recursive algorithms\nD) A technique used to improve the performance of a greedy algorithm",
    "output": "B"
},
{
    "instruction": "Which of the following best describes the A* algorithm?",
    "input": "A) It finds the shortest path from a starting point to a goal\nB) It uses a heuristic to improve its search performance\nC) It is used in graph-based pathfinding\nD) All of the above",
    "output": "D"
},
{
    "instruction": "Which sorting algorithm is known for being stable, meaning equal elements retain their relative order?",
    "input": "A) Quick Sort\nB) Merge Sort\nC) Heap Sort\nD) Selection Sort",
    "output": "B"
},
{
    "instruction": "Which of the following is a greedy algorithm used to solve the fractional knapsack problem?",
    "input": "A) Dijkstra's Algorithm\nB) Kruskal's Algorithm\nC) Prim's Algorithm\nD) Greedy Algorithm",
    "output": "D"
},
{
    "instruction": "Which of the following algorithms is efficient for finding the maximum subarray sum?",
    "input": "A) Dynamic Programming\nB) Divide and Conquer\nC) Greedy Algorithm\nD) Both A and B",
    "output": "D"
},
{
    "instruction": "In which algorithm is the pivot element chosen randomly?",
    "input": "A) Quick Sort\nB) Merge Sort\nC) Heap Sort\nD) Insertion Sort",
    "output": "A"
},
{
    "instruction": "Which of the following algorithms can be used to detect cycles in a directed graph?",
    "input": "A) Depth First Search\nB) Breadth First Search\nC) Dijkstra's Algorithm\nD) Bellman-Ford Algorithm",
    "output": "A"
},
{
    "instruction": "Which of the following is the best algorithm for solving the matrix chain multiplication problem?",
    "input": "A) Dynamic Programming\nB) Greedy Algorithm\nC) Divide and Conquer\nD) Backtracking",
    "output": "A"
},
{
    "instruction": "What is the time complexity of the breadth-first search (BFS) algorithm?",
    "input": "A) O(n^2)\nB) O(n + m)\nC) O(n log n)\nD) O(m log n)",
    "output": "B"
},
{
    "instruction": "Which of the following algorithms uses the concept of greedy choices to solve optimization problems?",
    "input": "A) Dijkstra's Algorithm\nB) Kruskal's Algorithm\nC) Prim's Algorithm\nD) All of the above",
    "output": "D"
},
{
    "instruction": "Which of the following is a characteristic of the merge sort algorithm?",
    "input": "A) It is an in-place algorithm\nB) It has a time complexity of O(n^2)\nC) It is a comparison-based algorithm\nD) It does not require additional space",
    "output": "C"
},
{
    "instruction": "Which algorithm is used to find the largest number in an array?",
    "input": "A) Merge Sort\nB) Quick Sort\nC) Linear Search\nD) Binary Search",
    "output": "C"
},
{
    "instruction": "Which algorithm is used to find the longest common subsequence (LCS) between two sequences?",
    "input": "A) Dynamic Programming\nB) Divide and Conquer\nC) Greedy Algorithm\nD) Brute Force",
    "output": "A"
},
{
    "instruction": "Which of the following algorithms is a non-comparison-based sorting algorithm?",
    "input": "A) Merge Sort\nB) Quick Sort\nC) Counting Sort\nD) Bubble Sort",
    "output": "C"
},
{
    "instruction": "What is the time complexity of the bubble sort algorithm in the worst case?",
    "input": "A) O(n^2)\nB) O(n log n)\nC) O(n)\nD) O(log n)",
    "output": "A"
},
{
    "instruction": "Which algorithm is based on the divide-and-conquer approach and is used to solve the closest pair of points problem?",
    "input": "A) Quick Sort\nB) Merge Sort\nC) Divide and Conquer\nD) Brute Force",
    "output": "C"
},
{
    "instruction": "What is the primary drawback of using the insertion sort algorithm for large datasets?",
    "input": "A) It is inefficient on nearly sorted data\nB) It has a worst-case time complexity of O(n^2)\nC) It requires extra space for sorting\nD) It is not stable",
    "output": "B"
},
{
    "instruction": "In the context of a graph, what does BFS stand for?",
    "input": "A) Best First Search\nB) Binary First Search\nC) Breadth First Search\nD) Bottom First Search",
    "output": "C"
},
{
    "instruction": "Which of the following algorithms is used to solve the minimum spanning tree (MST) problem?",
    "input": "A) Dijkstra's Algorithm\nB) Kruskal's Algorithm\nC) Bellman-Ford Algorithm\nD) Floyd-Warshall Algorithm",
    "output": "B"
},
{
    "instruction": "What is the main difference between the bubble sort and selection sort algorithms?",
    "input": "A) Bubble sort is faster than selection sort\nB) Selection sort performs fewer swaps than bubble sort\nC) Bubble sort requires less space than selection sort\nD) Selection sort is a stable algorithm",
    "output": "B"
},
{
    "instruction": "Which of the following is true for the quicksort algorithm?",
    "input": "A) It is always stable\nB) It is an in-place sorting algorithm\nC) It has a time complexity of O(n^2) in the best case\nD) It requires additional space for sorting",
    "output": "B"
},
{
    "instruction": "Which of the following algorithms is used to solve the traveling salesman problem?",
    "input": "A) Dynamic Programming\nB) Greedy Algorithm\nC) Backtracking\nD) None of the above",
    "output": "D"
},
{
    "instruction": "Which of the following best describes the time complexity of the quicksort algorithm in the best case?",
    "input": "A) O(n^2)\nB) O(n log n)\nC) O(n)\nD) O(log n)",
    "output": "B"
},
{
    "instruction": "Which of the following is true for the merge sort algorithm?",
    "input": "A) It is a comparison-based sorting algorithm\nB) It is not stable\nC) It has a worst-case time complexity of O(n)\nD) It is an in-place sorting algorithm",
    "output": "A"
},
{
    "instruction": "What is the time complexity of the merge operation in the merge sort algorithm?",
    "input": "A) O(n)\nB) O(n^2)\nC) O(log n)\nD) O(1)",
    "output": "A"
},
{
    "instruction": "Which algorithm is primarily used for finding the shortest path in an unweighted graph?",
    "input": "A) Dijkstra's Algorithm\nB) Bellman-Ford Algorithm\nC) Floyd-Warshall Algorithm\nD) Breadth-First Search",
    "output": "D"
},
{
    "instruction": "Which of the following algorithms uses a priority queue?",
    "input": "A) Merge Sort\nB) Dijkstra's Algorithm\nC) Quick Sort\nD) Selection Sort",
    "output": "B"
},
{
    "instruction": "Which algorithm is most appropriate for solving the knapsack problem with 0/1 items?",
    "input": "A) Greedy Algorithm\nB) Dynamic Programming\nC) Backtracking\nD) Brute Force",
    "output": "B"
},
{
    "instruction": "Which of the following sorting algorithms is not comparison-based?",
    "input": "A) Merge Sort\nB) Quick Sort\nC) Radix Sort\nD) Heap Sort",
    "output": "C"
},
{
    "instruction": "Which algorithm is most efficient for finding the shortest path in a weighted graph with negative edge weights?",
    "input": "A) Dijkstra's Algorithm\nB) Bellman-Ford Algorithm\nC) Floyd-Warshall Algorithm\nD) Prim's Algorithm",
    "output": "B"
},
{
    "instruction": "Which of the following is a feature of a stable sorting algorithm?",
    "input": "A) It always sorts in ascending order\nB) It preserves the relative order of equal elements\nC) It is faster than an unstable algorithm\nD) It requires no additional space",
    "output": "B"
},
{
    "instruction": "Which sorting algorithm is generally considered the fastest for large datasets?",
    "input": "A) Quick Sort\nB) Merge Sort\nC) Insertion Sort\nD) Heap Sort",
    "output": "A"
},
{
    "instruction": "In the quicksort algorithm, the element selected to partition the array is called the ________.",
    "input": "",
    "output": "pivot"
},
{
    "instruction": "In the merge sort algorithm, the array is recursively divided until the size of each subarray is ________.",
    "input": "",
    "output": "one"
},
{
    "instruction": "The time complexity of bubble sort in the worst case is ________.",
    "input": "",
    "output": "O(n^2)"
},
{
    "instruction": "In a binary search tree (BST), the left subtree of a node contains values ________ the node value.",
    "input": "",
    "output": "less than"
},
{
    "instruction": "The greedy algorithm is typically used in problems where the global optimum can be reached by selecting the ________ choice at each step.",
    "input": "",
    "output": "local"
},
{
    "instruction": "The Dijkstra algorithm is used to find the ________ path from a source node to all other nodes in a graph.",
    "input": "",
    "output": "shortest"
},
{
    "instruction": "In the selection sort algorithm, the smallest element is ________ with the element at the current position.",
    "input": "",
    "output": "swapped"
},
{
    "instruction": "The bubble sort algorithm is an example of a ________ sorting algorithm.",
    "input": "",
    "output": "comparison-based"
},
{
    "instruction": "In the quicksort algorithm, if the pivot is always chosen to be the middle element, the worst-case time complexity is ________.",
    "input": "",
    "output": "O(n^2)"
},
{
    "instruction": "The depth-first search (DFS) algorithm explores as far down a branch as possible before ________.",
    "input": "",
    "output": "backtracking"
},
{
    "instruction": "In a graph, an edge that connects two nodes with the smallest weight is part of the ________ spanning tree.",
    "input": "",
    "output": "minimum"
},
{
    "instruction": "A binary heap is a complete binary tree that satisfies the ________ property.",
    "input": "",
    "output": "heap"
},
{
    "instruction": "The Bellman-Ford algorithm is used for finding the shortest path in a graph with ________ weights.",
    "input": "",
    "output": "negative"
},
{
    "instruction": "In the merge sort algorithm, the merging process takes ________ time complexity.",
    "input": "",
    "output": "O(n)"
},
{
    "instruction": "A hash table uses a ________ to map keys to values.",
    "input": "",
    "output": "hash function"
},
{
    "instruction": "The Floyd-Warshall algorithm is used to find the ________ paths between all pairs of vertices in a graph.",
    "input": "",
    "output": "shortest"
},
{
    "instruction": "The time complexity of the insertion sort in the best case is ________.",
    "input": "",
    "output": "O(n)"
},
{
    "instruction": "In a depth-first search (DFS), if a node has already been visited, it is called a ________ node.",
    "input": "",
    "output": "visited"
},
{
    "instruction": "The complexity of a binary search operation is ________ in a balanced binary search tree.",
    "input": "",
    "output": "O(log n)"
},
{
    "instruction": "Bubble sort has a time complexity of O(n^2) in the best case.",
    "input": "",
    "output": "False"
},
{
    "instruction": "Dijkstra's algorithm works only on graphs with non-negative edge weights.",
    "input": "",
    "output": "True"
},
{
    "instruction": "Merge sort is a stable sorting algorithm.",
    "input": "",
    "output": "True"
},
{
    "instruction": "The time complexity of quicksort in the worst case is O(n log n).",
    "input": "",
    "output": "False"
},
{
    "instruction": "Heap sort is an unstable sorting algorithm.",
    "input": "",
    "output": "True"
},
{
    "instruction": "Depth-first search (DFS) can be implemented using recursion.",
    "input": "",
    "output": "True"
},
{
    "instruction": "Selection sort is faster than bubble sort in the worst case.",
    "input": "",
    "output": "True"
},
{
    "instruction": "In the BFS algorithm, nodes are explored level by level.",
    "input": "",
    "output": "True"
},
{
    "instruction": "Radix sort is a comparison-based sorting algorithm.",
    "input": "",
    "output": "False"
},
{
    "instruction": "The Bellman-Ford algorithm can detect negative weight cycles in a graph.",
    "input": "",
    "output": "True"
},
{
    "instruction": "Quick sort is an example of an in-place sorting algorithm.",
    "input": "",
    "output": "True"
},
{
    "instruction": "Merge sort uses a divide-and-conquer approach.",
    "input": "",
    "output": "True"
},
{
    "instruction": "Kruskals algorithm is used to find the shortest path in a graph.",
    "input": "",
    "output": "False"
},
{
    "instruction": "The complexity of insertion sort in the worst case is O(n log n).",
    "input": "",
    "output": "False"
},
{
    "instruction": "A binary search tree is always balanced.",
    "input": "",
    "output": "False"
},
{
    "instruction": "In the Fibonacci sequence, each number is the sum of the two preceding ones.",
    "input": "",
    "output": "True"
},
{
    "instruction": "The time complexity of the merge operation in merge sort is O(n^2).",
    "input": "",
    "output": "False"
},
{
    "instruction": "Quick sort can perform better than bubble sort for large datasets.",
    "input": "",
    "output": "True"
},
{
    "instruction": "In the traveling salesman problem, the goal is to find the shortest possible route that visits each city exactly once and returns to the origin city.",
    "input": "",
    "output": "True"
},
{
    "instruction": "In an algorithm, the part where a decision is made based on some condition is called a ________.",
    "input": "",
    "output": "branch"
},
{
    "instruction": "A ________ is a data structure that follows the Last In First Out (LIFO) principle.",
    "input": "",
    "output": "stack"
},
{
    "instruction": "In a breadth-first search (BFS) algorithm, nodes are visited level by ________.",
    "input": "",
    "output": "level"
},
{
    "instruction": "The time complexity of the binary search algorithm is ________.",
    "input": "",
    "output": "O(log n)"
},
{
    "instruction": "The main advantage of using a hash table is its ________ lookup time.",
    "input": "",
    "output": "constant"
},
{
    "instruction": "The ________ algorithm is used to find the shortest path between nodes in a graph when all edges have the same weight.",
    "input": "",
    "output": "Breadth-first search"
},
{
    "instruction": "The time complexity of the heapify operation in a binary heap is ________.",
    "input": "",
    "output": "O(log n)"
},
{
    "instruction": "The minimum spanning tree of a graph can be found using Prims or ________ algorithm.",
    "input": "",
    "output": "Kruskals"
},
{
    "instruction": "The traveling salesman problem is a classic example of a ________ problem.",
    "input": "",
    "output": "NP-hard"
},
{
    "instruction": "The time complexity of binary search in a sorted array is ________.",
    "input": "",
    "output": "O(log n)"
},
{
    "instruction": "The Merge Sort algorithm works by recursively dividing the array and then ________ them together.",
    "input": "",
    "output": "merging"
},
{
    "instruction": "A ________ search is often used in decision tree algorithms, where decisions are made based on previous conditions.",
    "input": "",
    "output": "recursive"
},
{
    "instruction": "In a directed acyclic graph (DAG), edges are directed and there are no ________ cycles.",
    "input": "",
    "output": "cyclic"
},
{
    "instruction": "In the worst case, the time complexity of the quicksort algorithm is ________.",
    "input": "",
    "output": "O(n^2)"
},
{
    "instruction": "Dijkstras algorithm is used for graphs with ________ edge weights.",
    "input": "",
    "output": "non-negative"
},
{
    "instruction": "A priority queue is implemented using a ________.",
    "input": "",
    "output": "heap"
},
{
    "instruction": "The Fibonacci sequence can be efficiently generated using ________ programming techniques.",
    "input": "",
    "output": "dynamic"
},
{
    "instruction": "In a binary search tree (BST), each left child node has a value ________ than its parent node.",
    "input": "",
    "output": "less"
},
{
    "instruction": "In the binary tree traversal, the pre-order traversal visits the root ________ its left and right subtrees.",
    "input": "",
    "output": "before"
},
{
    "instruction": "The selection sort algorithm is faster than bubble sort for large datasets.",
    "input": "",
    "output": "True"
},
{
    "instruction": "Prims algorithm is a greedy algorithm used to find the minimum spanning tree of a graph.",
    "input": "",
    "output": "True"
},
{
    "instruction": "The time complexity of merge sort is O(n^3) in the best case.",
    "input": "",
    "output": "False"
},
{
    "instruction": "Heap sort is a stable sorting algorithm.",
    "input": "",
    "output": "False"
},
{
    "instruction": "The greedy algorithm always finds the global optimum solution to a problem.",
    "input": "",
    "output": "False"
},
{
    "instruction": "Depth-first search (DFS) can be implemented using either a stack or recursion.",
    "input": "",
    "output": "True"
},
{
    "instruction": "The time complexity of quicksort in the best case is O(n log n).",
    "input": "",
    "output": "True"
},
{
    "instruction": "In Kruskals algorithm, edges are considered in increasing order of their ________.",
    "input": "",
    "output": "weight"
},
{
    "instruction": "Radix sort is not a comparison-based sorting algorithm.",
    "input": "",
    "output": "True"
},
{
    "instruction": "Dijkstras algorithm is a type of dynamic programming algorithm.",
    "input": "",
    "output": "False"
},
{
    "instruction": "Merge sort can be implemented using the divide-and-conquer approach.",
    "input": "",
    "output": "True"
},
{
    "instruction": "The time complexity of insertion sort is O(n log n) in the worst case.",
    "input": "",
    "output": "False"
},
{
    "instruction": "A binary search tree always maintains a balanced structure.",
    "input": "",
    "output": "False"
},
{
    "instruction": "The time complexity of finding the minimum element in a min-heap is O(1).",
    "input": "",
    "output": "True"
},
{
    "instruction": "Floyd-Warshall algorithm finds the shortest paths between all pairs of vertices in a graph.",
    "input": "",
    "output": "True"
},
{
    "instruction": "Quick sort is an example of a non-recursive sorting algorithm.",
    "input": "",
    "output": "False"
},
{
    "instruction": "A stack is an example of a first-in, first-out (FIFO) data structure.",
    "input": "",
    "output": "False"
},
{
    "instruction": "In binary search, the time complexity in the worst case is O(log n).",
    "input": "",
    "output": "True"
},
{
    "instruction": "The time complexity of the bubble sort algorithm in the worst case is ________.",
    "input": "",
    "output": "O(n^2)"
},
{
    "instruction": "In a dynamic programming algorithm, solutions to subproblems are ________ to avoid redundant calculations.",
    "input": "",
    "output": "memoized"
},
{
    "instruction": "The worst-case time complexity of the quicksort algorithm is ________.",
    "input": "",
    "output": "O(n^2)"
},
{
    "instruction": "The ________ algorithm is used to find the shortest path in a weighted graph with non-negative edge weights.",
    "input": "",
    "output": "Dijkstras"
},
{
    "instruction": "A ________ tree is a tree where each node has at most two children.",
    "input": "",
    "output": "binary"
},
{
    "instruction": "The ________ algorithm is used for sorting by dividing the array into smaller parts and recursively merging them.",
    "input": "",
    "output": "Merge Sort"
},
{
    "instruction": "A ________ sort is a comparison-based sorting algorithm that divides the input into two parts and recursively sorts them.",
    "input": "",
    "output": "quick"
},
{
    "instruction": "A ________ search is an efficient algorithm for finding an element in a sorted array.",
    "input": "",
    "output": "binary"
},
{
    "instruction": "The ________ algorithm is used for searching an element in a graph and it explores all vertices at the present depth level before moving on to nodes at the next depth level.",
    "input": "",
    "output": "breadth-first"
},
{
    "instruction": "The time complexity of the bubble sort algorithm in the best case is ________.",
    "input": "",
    "output": "O(n)"
},
{
    "instruction": "The ________ problem involves finding the shortest path between two vertices in a weighted graph.",
    "input": "",
    "output": "single-source shortest path"
},
{
    "instruction": "In a binary heap, the root node contains the ________ value.",
    "input": "",
    "output": "maximum"
},
{
    "instruction": "The time complexity of selection sort is ________.",
    "input": "",
    "output": "O(n^2)"
},
{
    "instruction": "The ________ algorithm is used to find the minimum spanning tree of a graph.",
    "input": "",
    "output": "Kruskals"
},
{
    "instruction": "A ________ search is a search technique that starts at the root and explores all branches before backtracking.",
    "input": "",
    "output": "depth-first"
},
{
    "instruction": "An ________ is a tree where every parent node has exactly two children, except possibly for the leaf nodes.",
    "input": "",
    "output": "binary search tree"
},
{
    "instruction": "The ________ is an algorithm for finding the shortest path in a graph that allows negative weights.",
    "input": "",
    "output": "Bellman-Ford"
},
{
    "instruction": "The time complexity of a linear search algorithm is ________.",
    "input": "",
    "output": "O(n)"
},
{
    "instruction": "A ________ queue is a queue in which elements are added and removed from the same end.",
    "input": "",
    "output": "stack"
},
{
    "instruction": "Insertion sort is an in-place sorting algorithm.",
    "input": "",
    "output": "True"
},
{
    "instruction": "A heap is a complete binary tree that satisfies the heap property.",
    "input": "",
    "output": "True"
},
{
    "instruction": "The time complexity of the merge sort algorithm is O(n^3).",
    "input": "",
    "output": "False"
},
{
    "instruction": "A binary search tree (BST) can have at most two children for each node.",
    "input": "",
    "output": "True"
},
{
    "instruction": "Depth-first search (DFS) uses a queue for node exploration.",
    "input": "",
    "output": "False"
},
{
    "instruction": "In Dijkstra's algorithm, the shortest path is determined based on the weight of the edges.",
    "input": "",
    "output": "True"
},
{
    "instruction": "The quicksort algorithm is a stable sorting algorithm.",
    "input": "",
    "output": "False"
},
{
    "instruction": "In a priority queue, elements with the highest priority are dequeued first.",
    "input": "",
    "output": "True"
},
{
    "instruction": "In dynamic programming, the solution is built from smaller subproblems.",
    "input": "",
    "output": "True"
},
{
    "instruction": "Merge sort can be implemented in-place.",
    "input": "",
    "output": "False"
},
{
    "instruction": "Bubble sort always runs in O(n^2) time.",
    "input": "",
    "output": "False"
},
{
    "instruction": "Quick sort is typically faster than merge sort for small arrays.",
    "input": "",
    "output": "True"
},
{
    "instruction": "The BFS algorithm explores nodes in a graph in a top-down manner.",
    "input": "",
    "output": "False"
},
{
    "instruction": "Prim's algorithm is used to find the shortest path in a graph.",
    "input": "",
    "output": "False"
},
{
    "instruction": "Dijkstras algorithm can handle negative edge weights.",
    "input": "",
    "output": "False"
},
{
    "instruction": "The Bellman-Ford algorithm can handle negative edge weights.",
    "input": "",
    "output": "True"
},
{
    "instruction": "The quicksort algorithm divides the array into partitions before sorting.",
    "input": "",
    "output": "True"
},
{
    "instruction": "Heap sort can be performed using a binary search tree.",
    "input": "",
    "output": "False"
},
{
    "instruction": "Fill in the blank: The Big-O notation for the worst-case time complexity of Quick Sort is ____.",
    "input": "",
    "output": "O(n^2)"
},
{
    "instruction": "Fill in the blank: The ____ complexity of an algorithm refers to the memory used by the algorithm.",
    "input": "",
    "output": "space"
},
{
    "instruction": "Fill in the blank: In a binary search tree, the average-case time complexity for searching an element is ____.",
    "input": "",
    "output": "O(log n)"
},
{
    "instruction": "Fill in the blank: ____ notation describes the upper bound of an algorithm's running time.",
    "input": "",
    "output": "Big-O"
},
{
    "instruction": "Fill in the blank: The worst-case time complexity for inserting an element in a sorted linked list is ____.",
    "input": "",
    "output": "O(n)"
},
{
    "instruction": "Fill in the blank: The space complexity of an algorithm that uses no extra memory is ____.",
    "input": "",
    "output": "O(1)"
},
{
    "instruction": "Fill in the blank: The ____ notation describes the best-case scenario for an algorithm's runtime.",
    "input": "",
    "output": "Omega ()"
},
{
    "instruction": "Fill in the blank: The average-case time complexity of a hash table lookup is ____.",
    "input": "",
    "output": "O(1)"
},
{
    "instruction": "Fill in the blank: For an algorithm with time complexity of O(n^2), doubling the input size roughly increases the runtime by a factor of ____.",
    "input": "",
    "output": "4"
},
{
    "instruction": "Fill in the blank: The time complexity of traversing all nodes in a balanced binary tree is ____.",
    "input": "",
    "output": "O(n)"
},
{
    "instruction": "Fill in the blank: The best-case time complexity for the Bubble Sort algorithm is ____.",
    "input": "",
    "output": "O(n)"
},
{
    "instruction": "Fill in the blank: When the pivot element divides the data evenly, Quick Sort has a time complexity of ____.",
    "input": "",
    "output": "O(n log n)"
},
{
    "instruction": "Fill in the blank: An algorithm that requires memory proportional to the input size has a space complexity of ____.",
    "input": "",
    "output": "O(n)"
},
{
    "instruction": "Fill in the blank: The ____ notation describes the tightest bound of an algorithm's runtime.",
    "input": "",
    "output": "Theta ()"
},
{
    "instruction": "Fill in the blank: The time complexity of finding the maximum element in an unsorted array is ____.",
    "input": "",
    "output": "O(n)"
},
{
    "instruction": "Fill in the blank: The space complexity of the Merge Sort algorithm is ____.",
    "input": "",
    "output": "O(n)"
},
{
    "instruction": "Fill in the blank: The recurrence relation for the time complexity of the Merge Sort algorithm is T(n) = 2T(n/2) + ____.",
    "input": "",
    "output": "O(n)"
},
{
    "instruction": "Fill in the blank: In a worst-case scenario, the insertion operation in a hash table with chaining has a time complexity of ____.",
    "input": "",
    "output": "O(n)"
},
{
    "instruction": "Fill in the blank: The ____ complexity of an algorithm refers to the minimum amount of time it takes to run.",
    "input": "",
    "output": "best-case"
},
{
    "instruction": "Fill in the blank: The Big-O notation for the worst-case time complexity of Heap Sort is ____.",
    "input": "",
    "output": "O(n log n)"
},
{
    "instruction": "Fill in the blank: The time complexity of accessing an element in an array is ____.",
    "input": "",
    "output": "O(1)"
},
{
    "instruction": "Fill in the blank: In the worst case, the time complexity of the insertion sort algorithm is ____.",
    "input": "",
    "output": "O(n^2)"
},
{
    "instruction": "Fill in the blank: The time complexity of a linear search algorithm is ____.",
    "input": "",
    "output": "O(n)"
},
{
    "instruction": "Fill in the blank: The space complexity of the Quick Sort algorithm is ____.",
    "input": "",
    "output": "O(log n)"
},
{
    "instruction": "Fill in the blank: An algorithm with a time complexity of O(n) will scale ____ with input size.",
    "input": "",
    "output": "linearly"
},
{
    "instruction": "Fill in the blank: The space complexity of an algorithm using only constant memory is ____.",
    "input": "",
    "output": "O(1)"
},
{
    "instruction": "Fill in the blank: The time complexity of an algorithm with a nested loop structure is typically ____.",
    "input": "",
    "output": "O(n^2)"
},
{
    "instruction": "Fill in the blank: A sorting algorithm that has a time complexity of O(n log n) in the average case is ____.",
    "input": "",
    "output": "Merge Sort"
},
{
    "instruction": "Fill in the blank: The space complexity of a recursive algorithm depends on the maximum depth of the recursion, which is ____.",
    "input": "",
    "output": "O(depth)"
},
{
    "instruction": "Fill in the blank: The time complexity of an algorithm performing binary search is ____.",
    "input": "",
    "output": "O(log n)"
},
{
    "instruction": "Fill in the blank: An algorithm with O(1) space complexity does not require additional memory as the input size ____.",
    "input": "",
    "output": "grows"
},
{
    "instruction": "Fill in the blank: The time complexity of multiplying two n  n matrices is ____.",
    "input": "",
    "output": "O(n^3)"
},
{
    "instruction": "Fill in the blank: The time complexity of adding an element to the end of a dynamically resizing array is ____.",
    "input": "",
    "output": "O(1)"
},
{
    "instruction": "Fill in the blank: An algorithm that visits every node in a binary tree has a time complexity of ____.",
    "input": "",
    "output": "O(n)"
},
{
    "instruction": "Fill in the blank: The time complexity of calculating the Fibonacci sequence using dynamic programming is ____.",
    "input": "",
    "output": "O(n)"
},
{
    "instruction": "Fill in the blank: In the best case, the time complexity of the Bubble Sort algorithm is ____.",
    "input": "",
    "output": "O(n)"
},
{
    "instruction": "Fill in the blank: An algorithm that performs operations in constant time has a time complexity of ____.",
    "input": "",
    "output": "O(1)"
},
{
    "instruction": "Fill in the blank: The space complexity of Depth-First Search (DFS) in a tree is ____.",
    "input": "",
    "output": "O(h)"
},
{
    "instruction": "Fill in the blank: The time complexity of the Selection Sort algorithm is ____.",
    "input": "",
    "output": "O(n^2)"
},
{
    "instruction": "Fill in the blank: An algorithm with time complexity of O(n^3) will take longer to execute as the input size increases ____ than an algorithm with O(n^2).",
    "input": "",
    "output": "faster"
},
{
    "instruction": "True or False: The time complexity of accessing an element in an array is O(1).",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: The space complexity of the Quick Sort algorithm is O(n).",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: The time complexity of a binary search is O(n).",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: An algorithm with time complexity O(n^2) will scale quadratically with input size.",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: The space complexity of an algorithm is always constant.",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: A sorting algorithm with a time complexity of O(n log n) is always faster than one with O(n^2).",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: A space complexity of O(1) means that the algorithm uses a constant amount of memory, regardless of input size.",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: The time complexity of the Merge Sort algorithm in the worst case is O(n log n).",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: An algorithm with O(log n) time complexity is always faster than one with O(n).",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: A linear search has a time complexity of O(log n).",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: An algorithm with O(n^2) space complexity uses more memory than one with O(n).",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: The space complexity of the Bubble Sort algorithm is O(n).",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: A recursive function that calls itself only once has a space complexity of O(log n).",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: The time complexity of matrix multiplication is O(n^2).",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: An algorithm with time complexity O(n log n) is more efficient than one with O(n^2) for large inputs.",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: The time complexity of finding the maximum element in an unsorted array is O(n).",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: The space complexity of an iterative algorithm is generally O(1).",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: The space complexity of Depth-First Search (DFS) in a graph is O(n).",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: The time complexity of a greedy algorithm is always optimal.",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: The time complexity of an algorithm can be expressed using Big-O notation.",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: Space complexity considers only the memory used by input data.",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: The time complexity of finding the minimum element in an unsorted array is O(n).",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: An algorithm with time complexity O(n) performs faster than one with O(log n) for large inputs.",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: The space complexity of the Insertion Sort algorithm is O(n).",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: The time complexity of a Binary Tree search operation is O(log n).",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: The space complexity of a non-recursive algorithm is typically O(1).",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: The space complexity of the Fibonacci sequence implementation using recursion is O(n).",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: The space complexity of Quick Sort is O(log n) on average.",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: An algorithm with a space complexity of O(n) always requires more memory than one with O(log n).",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: The time complexity of a Depth-First Search (DFS) in a graph is O(n).",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: The time complexity of Breadth-First Search (BFS) in a graph is O(n + m), where n is the number of nodes and m is the number of edges.",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: The time complexity of a merge operation in Merge Sort is O(n).",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: An algorithm with time complexity O(2^n) will always be faster than one with O(n!).",
    "input": "",
    "output": "False"
},
{
    "instruction": "True or False: An algorithm with space complexity O(n^2) uses quadratic memory.",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: An algorithm with O(log n) time complexity performs fewer operations as the input size increases.",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: A binary search algorithm is only efficient on sorted data.",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: A recursive algorithm's space complexity is affected by the maximum depth of the recursion stack.",
    "input": "",
    "output": "True"
},
{
    "instruction": "True or False: The time complexity of a greedy algorithm depends on the number of possible choices at each step.",
    "input": "",
    "output": "True"
},
 
{
    "instruction": "Which of the following is the time complexity for accessing an element in an array?",
    "input": "A. O(n)\nB. O(log n)\nC. O(1)\nD. O(n^2)",
    "output": "C. O(1)"
},
{
    "instruction": "Which of the following is true about arrays in most programming languages?",
    "input": "A. Arrays are dynamic in size\nB. Arrays are of fixed size\nC. Arrays cannot store multiple types of data\nD. Arrays can only store integers",
    "output": "B. Arrays are of fixed size"
},
{
    "instruction": "What happens when you access an array index that is out of bounds?",
    "input": "A. The program compiles successfully\nB. It throws an exception or error\nC. It returns null\nD. It automatically adjusts the array size",
    "output": "B. It throws an exception or error"
},
{
    "instruction": "What is the space complexity of an array?",
    "input": "A. O(1)\nB. O(n)\nC. O(log n)\nD. O(n^2)",
    "output": "B. O(n)"
},
{
    "instruction": "Which of the following operations has the worst time complexity in an array?",
    "input": "A. Accessing an element\nB. Inserting an element at the end\nC. Deleting an element at the end\nD. Inserting an element at the beginning",
    "output": "D. Inserting an element at the beginning"
},
{
    "instruction": "What is the main advantage of using a linked list over an array?",
    "input": "A. Faster access to elements\nB. Dynamic size\nC. Lower memory consumption\nD. Better for random access",
    "output": "B. Dynamic size"
},
{
    "instruction": "Which type of linked list has two pointers per node, one pointing to the next node and one pointing to the previous node?",
    "input": "A. Singly Linked List\nB. Doubly Linked List\nC. Circular Linked List\nD. None of the above",
    "output": "B. Doubly Linked List"
},
{
    "instruction": "Which operation is performed in O(1) time for both singly and doubly linked lists?",
    "input": "A. Accessing an element\nB. Inserting an element at the end\nC. Deleting an element at the beginning\nD. Searching for an element",
    "output": "C. Deleting an element at the beginning"
},
{
    "instruction": "In a circular linked list, the next pointer of the last node points to which node?",
    "input": "A. The first node\nB. The second node\nC. The last node\nD. Null",
    "output": "A. The first node"
},
{
    "instruction": "What is the time complexity of accessing an element in a doubly linked list?",
    "input": "A. O(1)\nB. O(n)\nC. O(log n)\nD. O(n^2)",
    "output": "B. O(n)"
},
{
    "instruction": "In a stack, which operation is performed in constant time?",
    "input": "A. Push\nB. Pop\nC. Peek\nD. All of the above",
    "output": "D. All of the above"
},
{
    "instruction": "Which of the following is a property of a queue?",
    "input": "A. LIFO (Last In First Out)\nB. FIFO (First In First Out)\nC. Random access\nD. None of the above",
    "output": "B. FIFO (First In First Out)"
},
{
    "instruction": "What is the main advantage of using a queue over a stack?",
    "input": "A. Faster access to elements\nB. FIFO ordering\nC. Easier to implement\nD. None of the above",
    "output": "B. FIFO ordering"
},
{
    "instruction": "In a binary tree, which of the following is true about the root node?",
    "input": "A. It has no parent\nB. It is the left child of the leftmost node\nC. It is the right child of the rightmost node\nD. It has two children",
    "output": "A. It has no parent"
},
{
    "instruction": "In a binary search tree (BST), the left child of a node is always greater than or equal to the right child.",
    "input": "A. True\nB. False",
    "output": "B. False"
},
{
    "instruction": "In a min-heap, the root node contains the smallest element.",
    "input": "A. True\nB. False",
    "output": "A. True"
},
{
    "instruction": "Which of the following operations is the most time-efficient in a heap?",
    "input": "A. Insertion\nB. Deletion\nC. Searching for an element\nD. Heapify",
    "output": "A. Insertion"
},
{
    "instruction": "What is the time complexity of searching for an element in a binary search tree (BST)?",
    "input": "A. O(1)\nB. O(log n)\nC. O(n)\nD. O(n^2)",
    "output": "B. O(log n)"
},
{
    "instruction": "What is the space complexity of a binary tree?",
    "input": "A. O(1)\nB. O(n)\nC. O(log n)\nD. O(n^2)",
    "output": "B. O(n)"
},
{
    "instruction": "In a graph, which of the following is true about an edge?",
    "input": "A. It connects two nodes\nB. It can have direction\nC. It can have a weight\nD. All of the above",
    "output": "D. All of the above"
},

    {
        "instruction": "Which of the following is a characteristic of a stack?",
        "input": "A. First In First Out (FIFO)\nB. Last In First Out (LIFO)\nC. Random access\nD. None of the above",
        "output": "B. Last In First Out (LIFO)"
    },
    {
        "instruction": "Which of the following operations is performed in constant time in a queue?",
        "input": "A. Enqueue\nB. Dequeue\nC. Peek\nD. All of the above",
        "output": "D. All of the above"
    },
    {
        "instruction": "In a doubly linked list, each node has two pointers: one to the next node and one to the previous node. This allows for traversal in what direction?",
        "input": "A. Only forward\nB. Only backward\nC. Both forward and backward\nD. None of the above",
        "output": "C. Both forward and backward"
    },
    {
        "instruction": "Which of the following data structures uses the 'First In First Out' (FIFO) principle?",
        "input": "A. Stack\nB. Queue\nC. Array\nD. Linked List",
        "output": "B. Queue"
    },
    {
        "instruction": "What is the primary difference between a stack and a queue?",
        "input": "A. Stack is FIFO, Queue is LIFO\nB. Stack is LIFO, Queue is FIFO\nC. Stack and Queue are the same\nD. None of the above",
        "output": "B. Stack is LIFO, Queue is FIFO"
    },
    {
        "instruction": "Which of the following operations is O(1) in a stack?",
        "input": "A. Push\nB. Pop\nC. Peek\nD. All of the above",
        "output": "D. All of the above"
    },
    {
        "instruction": "In a hash table, what is the term used for a situation where multiple keys hash to the same index?",
        "input": "A. Collision\nB. Overflow\nC. Underflow\nD. Bucket",
        "output": "A. Collision"
    },
    {
        "instruction": "What is the space complexity of a hash table in terms of the number of elements stored?",
        "input": "A. O(1)\nB. O(n)\nC. O(log n)\nD. O(n^2)",
        "output": "B. O(n)"
    },
    {
        "instruction": "In a binary search tree (BST), which traversal method visits nodes in ascending order?",
        "input": "A. Preorder\nB. Inorder\nC. Postorder\nD. Level order",
        "output": "B. Inorder"
    },
    {
        "instruction": "What is the time complexity of accessing an element in a hash table?",
        "input": "A. O(1)\nB. O(log n)\nC. O(n)\nD. O(n^2)",
        "output": "A. O(1)"
    },
    {
        "instruction": "Which data structure is used to implement recursive function calls?",
        "input": "A. Queue\nB. Stack\nC. Linked List\nD. Array",
        "output": "B. Stack"
    },
    {
        "instruction": "Which of the following is a non-linear data structure?",
        "input": "A. Array\nB. Linked List\nC. Binary Tree\nD. Stack",
        "output": "C. Binary Tree"
    },
    {
        "instruction": "Which of the following operations is O(log n) in a balanced binary search tree?",
        "input": "A. Insertion\nB. Deletion\nC. Search\nD. All of the above",
        "output": "D. All of the above"
    },
    {
        "instruction": "Which of the following is true for a priority queue?",
        "input": "A. It is a type of stack\nB. It is a type of queue where each element has a priority\nC. It follows the FIFO principle\nD. It is always implemented using an array",
        "output": "B. It is a type of queue where each element has a priority"
    },
    {
        "instruction": "In which of the following operations is the worst-case time complexity O(n) for a linked list?",
        "input": "A. Searching for an element\nB. Inserting at the end\nC. Inserting at the beginning\nD. Deleting the first element",
        "output": "A. Searching for an element"
    },
    {
        "instruction": "Which of the following is the best data structure to use for implementing a dynamic memory allocation system?",
        "input": "A. Stack\nB. Queue\nC. Linked List\nD. Hash Table",
        "output": "C. Linked List"
    },
    {
        "instruction": "Which of the following is a characteristic of a binary search tree (BST)?",
        "input": "A. The left subtree contains only nodes with keys smaller than the nodes key\nB. The right subtree contains only nodes with keys larger than the nodes key\nC. Both A and B\nD. None of the above",
        "output": "C. Both A and B"
    },
    {
        "instruction": "What is the worst-case time complexity of insertion in a binary search tree (BST) when the tree is unbalanced?",
        "input": "A. O(1)\nB. O(log n)\nC. O(n)\nD. O(n^2)",
        "output": "C. O(n)"
    },
    {
        "instruction": "Which of the following is a type of traversal for a binary tree?",
        "input": "A. Preorder\nB. Inorder\nC. Postorder\nD. All of the above",
        "output": "D. All of the above"
    },
    {
        "instruction": "What is the time complexity of deleting an element from a doubly linked list?",
        "input": "A. O(1)\nB. O(n)\nC. O(log n)\nD. O(n^2)",
        "output": "A. O(1)"
    },

        {
            "instruction": "Which of the following is not a characteristic of a binary search tree (BST)?",
            "input": "A. The left subtree contains only nodes with keys smaller than the nodes key\nB. The right subtree contains only nodes with keys larger than the nodes key\nC. The tree is unordered\nD. The left and right subtrees are binary search trees",
            "output": "C. The tree is unordered"
        },
        {
            "instruction": "Which data structure is used in breadth-first search (BFS)?",
            "input": "A. Stack\nB. Queue\nC. Linked List\nD. Priority Queue",
            "output": "B. Queue"
        },
        {
            "instruction": "Which of the following is the most appropriate for implementing a sparse matrix?",
            "input": "A. Array\nB. Linked List\nC. Hash Table\nD. Linked List of Arrays",
            "output": "D. Linked List of Arrays"
        },
        {
            "instruction": "What is the time complexity of searching for an element in a hash table, assuming uniform distribution of keys?",
            "input": "A. O(1)\nB. O(log n)\nC. O(n)\nD. O(n^2)",
            "output": "A. O(1)"
        },
        {
            "instruction": "Which of the following is an advantage of using a doubly linked list over a singly linked list?",
            "input": "A. It uses less memory\nB. It allows traversal in both directions\nC. It is easier to implement\nD. None of the above",
            "output": "B. It allows traversal in both directions"
        },
        {
            "instruction": "Which of the following data structures does not allow direct access to an element based on its index?",
            "input": "A. Array\nB. Linked List\nC. Stack\nD. Queue",
            "output": "B. Linked List"
        },
        {
            "instruction": "What is the time complexity for inserting a new element at the beginning of a singly linked list?",
            "input": "A. O(1)\nB. O(log n)\nC. O(n)\nD. O(n^2)",
            "output": "A. O(1)"
        },
        {
            "instruction": "Which of the following is true for a circular queue?",
            "input": "A. It is implemented using a linked list\nB. It allows insertion and deletion of elements from both ends\nC. It uses a fixed size array and operates in a circular manner\nD. It does not allow overflow",
            "output": "C. It uses a fixed size array and operates in a circular manner"
        },
        {
            "instruction": "In a binary tree, how many child nodes can a node have at most?",
            "input": "A. One\nB. Two\nC. Three\nD. Four",
            "output": "B. Two"
        },
        {
            "instruction": "What is the time complexity of finding the maximum element in a binary search tree (BST)?",
            "input": "A. O(1)\nB. O(log n)\nC. O(n)\nD. O(n^2)",
            "output": "B. O(log n)"
        },
        {
            "instruction": "Which of the following is the most efficient way to find the middle element of a linked list?",
            "input": "A. Traverse the entire list to count the number of elements\nB. Use two pointers, one moving at half the speed of the other\nC. Use recursion to divide the list in half\nD. None of the above",
            "output": "B. Use two pointers, one moving at half the speed of the other"
        },
        {
            "instruction": "Which of the following data structures is the best choice for implementing an undo functionality in an application?",
            "input": "A. Stack\nB. Queue\nC. Linked List\nD. Binary Search Tree",
            "output": "A. Stack"
        },
        {
            "instruction": "What is the time complexity for deleting an element from a priority queue implemented using a binary heap?",
            "input": "A. O(1)\nB. O(log n)\nC. O(n)\nD. O(n^2)",
            "output": "B. O(log n)"
        },
        {
            "instruction": "In a hash table, what is the term used for the array size being automatically adjusted when the load factor crosses a certain threshold?",
            "input": "A. Hashing\nB. Resizing\nC. Rehashing\nD. Rebalancing",
            "output": "C. Rehashing"
        },
        {
            "instruction": "Which of the following is true about a linked list?",
            "input": "A. It allows random access to elements\nB. It requires contiguous memory\nC. It uses pointers to link nodes\nD. It is always implemented using arrays",
            "output": "C. It uses pointers to link nodes"
        },
        {
            "instruction": "What is the primary advantage of using a hash table over an array?",
            "input": "A. Faster access time\nB. Lower memory usage\nC. Simpler implementation\nD. None of the above",
            "output": "A. Faster access time"
        },
        {
            "instruction": "What is the time complexity of deleting a node from a doubly linked list?",
            "input": "A. O(1)\nB. O(n)\nC. O(log n)\nD. O(n^2)",
            "output": "A. O(1)"
        },
        {
            "instruction": "Which data structure is best suited for implementing a breadth-first search (BFS) algorithm?",
            "input": "A. Stack\nB. Queue\nC. Priority Queue\nD. Deque",
            "output": "B. Queue"
        },
        {
            "instruction": "In a binary search tree (BST), what is the time complexity of deleting the root node?",
            "input": "A. O(1)\nB. O(log n)\nC. O(n)\nD. O(n^2)",
            "output": "C. O(n)"
        },
        {
            "instruction": "Which data structure is commonly used to implement a breadth-first search (BFS) in an unweighted graph?",
            "input": "A. Queue\nB. Stack\nC. Priority Queue\nD. Linked List",
            "output": "A. Queue"
        },
        {
            "instruction": "What is the time complexity of accessing an element in a doubly linked list?",
            "input": "A. O(1)\nB. O(log n)\nC. O(n)\nD. O(n^2)",
            "output": "C. O(n)"
        },
        {
            "instruction": "Which data structure is commonly used for implementing a depth-first search (DFS) algorithm?",
            "input": "A. Queue\nB. Stack\nC. Deque\nD. Linked List",
            "output": "B. Stack"
        },
        {
            "instruction": "In a circular linked list, what happens if the last node points to NULL?",
            "input": "A. The list is no longer circular\nB. It causes an infinite loop\nC. It does not affect the list structure\nD. The list becomes a doubly linked list",
            "output": "A. The list is no longer circular"
        },
        {
            "instruction": "Which data structure allows for fast insertion and deletion but does not allow for random access?",
            "input": "A. Array\nB. Linked List\nC. Stack\nD. Queue",
            "output": "B. Linked List"
        },
        {
            "instruction": "What is the main advantage of using a hash map over an array?",
            "input": "A. Faster access time\nB. Allows for duplicate elements\nC. Less memory usage\nD. It is easier to implement",
            "output": "A. Faster access time"
        },
        {
            "instruction": "Which of the following is a disadvantage of using a linked list?",
            "input": "A. It allows for fast access to elements\nB. It requires extra memory for pointers\nC. It supports random access\nD. It does not allow dynamic resizing",
            "output": "B. It requires extra memory for pointers"
        },
        {
            "instruction": "Which data structure would you use to implement a browsers back and forward functionality?",
            "input": "A. Stack\nB. Queue\nC. Array\nD. Linked List",
            "output": "A. Stack"
        },
        {
            "instruction": "What is the primary difference between a stack and a queue?",
            "input": "A. A stack follows the FIFO order\nB. A queue follows the LIFO order\nC. A stack follows the LIFO order\nD. Both are identical in behavior",
            "output": "C. A stack follows the LIFO order"
        },
        {
            "instruction": "In a priority queue, elements are dequeued in which order?",
            "input": "A. In the order they were inserted\nB. In random order\nC. In order of their priority\nD. In reverse order of priority",
            "output": "C. In order of their priority"
        },
        {
            "instruction": "Which data structure is commonly used to implement a recursive function?",
            "input": "A. Array\nB. Queue\nC. Stack\nD. Linked List",
            "output": "C. Stack"
        },
        {
            "instruction": "In a balanced binary search tree, what is the time complexity of searching for an element?",
            "input": "A. O(1)\nB. O(log n)\nC. O(n)\nD. O(n^2)",
            "output": "B. O(log n)"
        },
        {
            "instruction": "What is the time complexity of deleting the first element from a singly linked list?",
            "input": "A. O(1)\nB. O(n)\nC. O(log n)\nD. O(n^2)",
            "output": "A. O(1)"
        },
        {
            "instruction": "Which data structure is best suited for implementing a scheduling system?",
            "input": "A. Stack\nB. Queue\nC. Priority Queue\nD. Linked List",
            "output": "C. Priority Queue"
        },
        {
            "instruction": "What is the time complexity for inserting an element at the end of a doubly linked list?",
            "input": "A. O(1)\nB. O(n)\nC. O(log n)\nD. O(n^2)",
            "output": "A. O(1)"
        },
        {
            "instruction": "In a binary search tree (BST), what is the time complexity of searching for an element in the worst case?",
            "input": "A. O(1)\nB. O(log n)\nC. O(n)\nD. O(n^2)",
            "output": "C. O(n)"
        },
        {
            "instruction": "Which data structure can be used to efficiently implement a set of distinct elements?",
            "input": "A. Array\nB. Hash Table\nC. Linked List\nD. Stack",
            "output": "B. Hash Table"
        },
        {
            "instruction": "Which of the following is an advantage of using a heap over a binary search tree?",
            "input": "A. It allows for faster element deletion\nB. It allows for faster insertion\nC. It maintains a sorted order\nD. It allows for faster searching",
            "output": "A. It allows for faster element deletion"
        },
        {
            "instruction": "What is the time complexity for inserting an element in a binary search tree (BST) in the worst case?",
            "input": "A. O(1)\nB. O(log n)\nC. O(n)\nD. O(n^2)",
            "output": "C. O(n)"
        },
        {
            "instruction": "In a circular linked list, how is the last node connected to the first node?",
            "input": "A. It points to NULL\nB. It points to the first node\nC. It points to the previous node\nD. It points to itself",
            "output": "B. It points to the first node"
        },
        {
            "instruction": "What is the space complexity of a binary tree with n nodes?",
            "input": "A. O(1)\nB. O(log n)\nC. O(n)\nD. O(n^2)",
            "output": "C. O(n)"
        },
        {
            "instruction": "Which of the following is a characteristic of a hash table?",
            "input": "A. Elements are stored in a sorted order\nB. Elements are stored based on their hash value\nC. Elements are stored based on their insertion order\nD. It does not allow duplicate elements",
            "output": "B. Elements are stored based on their hash value"
        },
        {
            "instruction": "In which situation would you prefer using a doubly linked list over a singly linked list?",
            "input": "A. When you need to traverse only in one direction\nB. When you need to frequently insert or remove elements from both ends\nC. When memory usage is a concern\nD. When random access is required",
            "output": "B. When you need to frequently insert or remove elements from both ends"
        },
        {
            "instruction": "Which of the following data structures supports the operation 'peek'?",
            "input": "A. Stack\nB. Queue\nC. Priority Queue\nD. All of the above",
            "output": "D. All of the above"
        },
        {
            "instruction": "In a binary tree, the number of edges is always ____ the number of nodes.",
            "input": "A. equal to\nB. less than\nC. greater than\nD. one less than",
            "output": "D. one less than"
        },
        {
            "instruction": "In a hash table, which of the following techniques is commonly used to handle collisions?",
            "input": "A. Double hashing\nB. Linear probing\nC. Chaining\nD. All of the above",
            "output": "D. All of the above"
        },
        {
            "instruction": "Which of the following is true about a queue?",
            "input": "A. It follows the LIFO (Last In First Out) principle\nB. It follows the FIFO (First In First Out) principle\nC. Elements can be accessed in any order\nD. It does not allow dynamic resizing",
            "output": "B. It follows the FIFO (First In First Out) principle"
        },
        {
            "instruction": "In a binary search tree, the left child of a node contains values that are ____.",
            "input": "A. greater than the parent node\nB. less than the parent node\nC. equal to the parent node\nD. not related to the parent node",
            "output": "B. less than the parent node"
        },
        {
            "instruction": "What is the time complexity of searching for an element in a hash table with a good hash function?",
            "input": "A. O(1)\nB. O(log n)\nC. O(n)\nD. O(n^2)",
            "output": "A. O(1)"
        },
        {
            "instruction": "Which of the following is a disadvantage of using an array as a data structure?",
            "input": "A. It supports random access\nB. It allows dynamic resizing\nC. It requires a fixed amount of memory\nD. It allows for efficient insertion and deletion",
            "output": "C. It requires a fixed amount of memory"
        },
        {
            "instruction": "Which data structure is used for implementing a breadth-first search (BFS) algorithm?",
            "input": "A. Stack\nB. Queue\nC. Deque\nD. Linked List",
            "output": "B. Queue"
        },
        {
            "instruction": "What is the time complexity of inserting an element in a hash table?",
            "input": "A. O(1)\nB. O(log n)\nC. O(n)\nD. O(n^2)",
            "output": "A. O(1)"
        },
        {
            "instruction": "In a priority queue, how are elements prioritized?",
            "input": "A. Based on the order they were inserted\nB. Based on their value\nC. Based on their priority level\nD. Based on the time of insertion",
            "output": "C. Based on their priority level"
        },
        {
            "instruction": "What is the time complexity for accessing an element at a specific index in an array?",
            "input": "A. O(1)\nB. O(log n)\nC. O(n)\nD. O(n^2)",
            "output": "A. O(1)"
        },
        {
            "instruction": "What is the space complexity of a linked list with n elements?",
            "input": "A. O(1)\nB. O(log n)\nC. O(n)\nD. O(n^2)",
            "output": "C. O(n)"
        },
        {
            "instruction": "Which of the following is true for a doubly linked list?",
            "input": "A. Each node has two pointers, one to the next node and one to the previous node\nB. Each node has one pointer to the next node\nC. It requires extra memory for storing keys\nD. It cannot be traversed in reverse order",
            "output": "A. Each node has two pointers, one to the next node and one to the previous node"
        },
        {
            "instruction": "Which data structure would be most efficient for performing the union and intersection of sets?",
            "input": "A. Array\nB. Linked List\nC. Hash Table\nD. Stack",
            "output": "C. Hash Table"
        },
        {
            "instruction": "What is the time complexity of deleting the last node from a singly linked list?",
            "input": "A. O(1)\nB. O(n)\nC. O(log n)\nD. O(n^2)",
            "output": "B. O(n)"
        },
        {
            "instruction": "In a heap, what is the time complexity of deleting the root element?",
            "input": "A. O(1)\nB. O(log n)\nC. O(n)\nD. O(n^2)",
            "output": "B. O(log n)"
        },
        {
            "instruction": "Which of the following data structures supports fast insertion and removal of elements from both ends?",
            "input": "A. Queue\nB. Stack\nC. Deque\nD. Linked List",
            "output": "C. Deque"
        },
        {
            "instruction": "What is the time complexity of deleting an element from a doubly linked list when the pointer to the element is already given?",
            "input": "A. O(1)\nB. O(n)\nC. O(log n)\nD. O(n^2)",
            "output": "A. O(1)"
        },
        {
            "instruction": "Which data structure is used to implement recursive function calls?",
            "input": "A. Stack\nB. Queue\nC. Linked List\nD. Array",
            "output": "A. Stack"
        },
        {
            "instruction": "Which of the following is true about a queue implemented using a circular array?",
            "input": "A. The last element points to the first element\nB. It cannot be implemented efficiently\nC. It requires a fixed size\nD. It uses two pointers for traversal",
            "output": "A. The last element points to the first element"
        },
        {
            "instruction": "In a priority queue, what happens if two elements have the same priority?",
            "input": "A. They are processed in the order they were inserted\nB. They are processed randomly\nC. They are not processed\nD. One is removed and the other is kept in the queue",
            "output": "A. They are processed in the order they were inserted"
        },
        {
            "instruction": "In a binary search tree, the left child of a node contains values that are ____.",
            "input": "A. greater than the parent node\nB. less than the parent node\nC. equal to the parent node\nD. not related to the parent node",
            "output": "B. less than the parent node"
        },
        {
            "instruction": "Which of the following is a characteristic of a doubly linked list?",
            "input": "A. It uses one pointer for each node\nB. It allows traversal in both directions\nC. It can only be traversed forward\nD. It is implemented using a hash table",
            "output": "B. It allows traversal in both directions"
        },
        {
            "instruction": "In a binary heap, which of the following operations can be done in O(log n) time complexity?",
            "input": "A. Insertion\nB. Deletion\nC. Both insertion and deletion\nD. Searching",
            "output": "C. Both insertion and deletion"
        },
        {
            "instruction": "Which of the following operations has a time complexity of O(1) in a linked list?",
            "input": "A. Insertion at the end\nB. Insertion at the beginning\nC. Searching for an element\nD. Deletion from the middle",
            "output": "B. Insertion at the beginning"
        },
        {
            "instruction": "In which type of tree is the left child less than the parent node and the right child greater than the parent node?",
            "input": "A. AVL tree\nB. Binary Search Tree\nC. Binary Tree\nD. Red-Black Tree",
            "output": "B. Binary Search Tree"
        },
        {
            "instruction": "Which of the following is a limitation of a stack?",
            "input": "A. It cannot hold more than one data type\nB. It allows insertion and deletion at both ends\nC. It follows a FIFO principle\nD. It only allows insertion and deletion from one end",
            "output": "D. It only allows insertion and deletion from one end"
        },
        {
            "instruction": "Which of the following is true about a hash table?",
            "input": "A. It stores elements in a sorted order\nB. It allows for efficient retrieval of values using keys\nC. It uses linked lists for collision handling\nD. It supports only integer keys",
            "output": "B. It allows for efficient retrieval of values using keys"
        },
        {
            "instruction": "What is the time complexity of searching for an element in a binary search tree in the worst case?",
            "input": "A. O(1)\nB. O(log n)\nC. O(n)\nD. O(n^2)",
            "output": "C. O(n)"
        },
        {
            "instruction": "In a singly linked list, what is the time complexity of deleting the first node?",
            "input": "A. O(1)\nB. O(n)\nC. O(log n)\nD. O(n^2)",
            "output": "A. O(1)"
        },
        {
            "instruction": "Which of the following is true about a doubly linked list compared to a singly linked list?",
            "input": "A. It requires more memory\nB. It is faster for traversing in reverse order\nC. It allows for easier deletion of nodes\nD. All of the above",
            "output": "D. All of the above"
        },
        {
            "instruction": "What is the time complexity of accessing an element in a linked list?",
            "input": "A. O(1)\nB. O(n)\nC. O(log n)\nD. O(n^2)",
            "output": "B. O(n)"
        },
        {
            "instruction": "In which data structure is the head of the list the first node and the tail the last node?",
            "input": "A. Linked List\nB. Stack\nC. Queue\nD. Tree",
            "output": "A. Linked List"
        },
        {
            "instruction": "Which data structure is best suited for implementing depth-first search (DFS)?",
            "input": "A. Stack\nB. Queue\nC. Linked List\nD. Tree",
            "output": "A. Stack"
        },
        {
            "instruction": "Which operation is typically faster in a linked list compared to an array?",
            "input": "A. Accessing an element by index\nB. Inserting or deleting an element\nC. Sorting elements\nD. Searching for an element",
            "output": "B. Inserting or deleting an element"
        },
        {
            "instruction": "What is the time complexity of deleting an element from the middle of a doubly linked list?",
            "input": "A. O(1)\nB. O(log n)\nC. O(n)\nD. O(n^2)",
            "output": "A. O(1)"
        },
        {
            "instruction": "Which of the following operations has a time complexity of O(n) in an array?",
            "input": "A. Accessing an element by index\nB. Insertion at the end\nC. Searching for an element\nD. Deletion from the middle",
            "output": "C. Searching for an element"
        },
        {
            "instruction": "In a hash table, what is a collision?",
            "input": "A. When two keys hash to the same index\nB. When two elements are inserted into the table\nC. When a key is deleted\nD. When the hash table is full",
            "output": "A. When two keys hash to the same index"
        },
        {
            "instruction": "Which of the following is a disadvantage of using a linked list?",
            "input": "A. It requires less memory\nB. It allows random access to elements\nC. It has slower access to elements compared to an array\nD. It is slower for insertion and deletion compared to an array",
            "output": "C. It has slower access to elements compared to an array"
        },
        {
            "instruction": "Which of the following data structures is used in implementing function calls in recursion?",
            "input": "A. Stack\nB. Queue\nC. Linked List\nD. Binary Tree",
            "output": "A. Stack"
        },
        {
            "instruction": "In a binary search tree (BST), what is the time complexity of inserting an element in the worst case?",
            "input": "A. O(1)\nB. O(log n)\nC. O(n)\nD. O(n^2)",
            "output": "C. O(n)"
        },
        {
            "instruction": "Which data structure is used to implement a breadth-first search (BFS)?",
            "input": "A. Stack\nB. Queue\nC. Linked List\nD. Array",
            "output": "B. Queue"
        },
        {
            "instruction": "In a circular queue, what happens when the queue is full?",
            "input": "A. The queue overflows\nB. The first element is deleted\nC. The last element is deleted\nD. The rear pointer wraps around to the front",
            "output": "D. The rear pointer wraps around to the front"
        },
        {
            "instruction": "Which of the following is true about a hash table's time complexity for search operations?",
            "input": "A. It is always O(1)\nB. It is O(log n)\nC. It is O(n)\nD. It can be O(1) on average, but can be O(n) in the worst case",
            "output": "D. It can be O(1) on average, but can be O(n) in the worst case"
        },
        {
            "instruction": "In a linked list, what is the time complexity of deleting the last node?",
            "input": "A. O(1)\nB. O(log n)\nC. O(n)\nD. O(n^2)",
            "output": "C. O(n)"
        },
        {
            "instruction": "Which of the following is a characteristic of a queue?",
            "input": "A. It follows a FIFO (First In, First Out) principle\nB. It follows a LIFO (Last In, First Out) principle\nC. It is implemented using a stack\nD. It allows for random access",
            "output": "A. It follows a FIFO (First In, First Out) principle"
        },
        {
            "instruction": "What is the worst-case time complexity of inserting an element into a hash table using open addressing?",
            "input": "A. O(1)\nB. O(log n)\nC. O(n)\nD. O(n^2)",
            "output": "C. O(n)"
        },
        {
            "instruction": "Which of the following is true about a doubly linked list compared to a singly linked list?",
            "input": "A. It allows traversal in both directions\nB. It requires less memory\nC. It is slower for deletion of nodes\nD. It can only be used to implement stacks",
            "output": "A. It allows traversal in both directions"
        },
        {
            "instruction": "In a binary tree, which node has at most two children?",
            "input": "A. Root node\nB. Leaf node\nC. Internal node\nD. None of the above",
            "output": "C. Internal node"
        },
        {
            "instruction": "Which of the following operations can be done in O(1) time complexity in a hash table?",
            "input": "A. Insertion\nB. Deletion\nC. Search\nD. All of the above",
            "output": "D. All of the above"
        },
        {
            "instruction": "What is the time complexity of searching for an element in an unsorted array?",
            "input": "A. O(1)\nB. O(log n)\nC. O(n)\nD. O(n^2)",
            "output": "C. O(n)"
        },
        {
            "instruction": "What is the worst-case time complexity of searching for an element in a hash table with separate chaining?",
            "input": "A. O(1)\nB. O(log n)\nC. O(n)\nD. O(n^2)",
            "output": "C. O(n)"
        },
        {
            "instruction": "Which data structure is used to implement recursion in a computer program?",
            "input": "A. Queue\nB. Stack\nC. Linked List\nD. Array",
            "output": "B. Stack"
        },
        {
            "instruction": "Which of the following is true about a binary search tree?",
            "input": "A. The left subtree of a node contains values greater than the node\nB. The right subtree of a node contains values smaller than the node\nC. The left subtree of a node contains values smaller than the node\nD. The tree can have only one child for each node",
            "output": "C. The left subtree of a node contains values smaller than the node"
        },
        {
            "instruction": "Which data structure is best suited for implementing an undo operation in an application?",
            "input": "A. Stack\nB. Queue\nC. Linked List\nD. Binary Search Tree",
            "output": "A. Stack"
        },
        {
            "instruction": "What is the time complexity of deleting the first element from a doubly linked list?",
            "input": "A. O(1)\nB. O(log n)\nC. O(n)\nD. O(n^2)",
            "output": "A. O(1)"
        },
        {
            "instruction": "In which of the following data structures does the memory usage grow dynamically as the size increases?",
            "input": "A. Array\nB. Linked List\nC. Hash Table\nD. Queue",
            "output": "B. Linked List"
        },
        {
            "instruction": "What is the average time complexity for searching an element in a balanced binary search tree (BST)?",
            "input": "A. O(1)\nB. O(log n)\nC. O(n)\nD. O(n log n)",
            "output": "B. O(log n)"
        },
        {
            "instruction": "Which of the following is true about a priority queue?",
            "input": "A. It follows the FIFO principle\nB. It allows random access to elements\nC. The highest (or lowest) priority element is always removed first\nD. It is implemented using an array",
            "output": "C. The highest (or lowest) priority element is always removed first"
        },
        {
            "instruction": "What is the space complexity of a hash table with open addressing?",
            "input": "A. O(n)\nB. O(log n)\nC. O(1)\nD. O(n^2)",
            "output": "A. O(n)"
        },
        {
            "instruction": "What is the time complexity of searching for an element in a balanced binary search tree?",
            "input": "A. O(1)\nB. O(log n)\nC. O(n)\nD. O(n log n)",
            "output": "B. O(log n)"
        },
        {
            "instruction": "Which data structure is commonly used to implement a recursive function call?",
            "input": "A. Queue\nB. Stack\nC. Array\nD. Linked List",
            "output": "B. Stack"
        },
        {
            "instruction": "Which of the following is NOT a property of a binary tree?",
            "input": "A. Every node has at most two children\nB. The left child is smaller than the parent node\nC. The right child is always greater than the parent node\nD. It follows a hierarchical structure",
            "output": "B. The left child is smaller than the parent node"
        },
        {
            "instruction": "What is the time complexity for accessing an element at a specific index in an array?",
            "input": "A. O(1)\nB. O(log n)\nC. O(n)\nD. O(n^2)",
            "output": "A. O(1)"
        },
        {
            "instruction": "What type of linked list has a head and tail pointer?",
            "input": "A. Doubly Linked List\nB. Singly Linked List\nC. Circular Linked List\nD. None of the above",
            "output": "A. Doubly Linked List"
        },
        {
            "instruction": "What is the space complexity of a queue implemented using an array?",
            "input": "A. O(n)\nB. O(log n)\nC. O(1)\nD. O(n^2)",
            "output": "A. O(n)"
        },
        {
            "instruction": "Which of the following data structures uses the Last In, First Out (LIFO) principle?",
            "input": "A. Queue\nB. Stack\nC. Linked List\nD. Binary Search Tree",
            "output": "B. Stack"
        },
        {
            "instruction": "Which of the following is true about a binary heap?",
            "input": "A. It is always a complete binary tree\nB. It can only be used to implement a priority queue\nC. It is a type of balanced binary search tree\nD. It is a type of binary search tree",
            "output": "A. It is always a complete binary tree"
        },
        {
            "instruction": "In a hash table, what happens when the load factor exceeds a threshold?",
            "input": "A. The hash table shrinks\nB. A rehash is performed\nC. A linked list is used\nD. It becomes a queue",
            "output": "B. A rehash is performed"
        },
        {
            "instruction": "Which of the following operations is NOT supported in constant time (O(1)) in a stack?",
            "input": "A. Push\nB. Pop\nC. Peek\nD. Search",
            "output": "D. Search"
        },
        {
            "instruction": "Which data structure can be used to implement breadth-first search (BFS)?",
            "input": "A. Stack\nB. Queue\nC. Binary Search Tree\nD. Hash Table",
            "output": "B. Queue"
        },
        {
            "instruction": "What is the worst-case time complexity for insertion in a hash table with separate chaining?",
            "input": "A. O(1)\nB. O(log n)\nC. O(n)\nD. O(n^2)",
            "output": "C. O(n)"
        },
        {
            "instruction": "Which of the following is true about a doubly linked list?",
            "input": "A. Each node has pointers to both the next and previous nodes\nB. It requires less memory than a singly linked list\nC. It cannot be used to implement stacks\nD. It only allows traversal in one direction",
            "output": "A. Each node has pointers to both the next and previous nodes"
        },
        {
            "instruction": "What is the primary advantage of using a hash table over an array?",
            "input": "A. Faster searching\nB. Better memory usage\nC. Easier to implement\nD. Supports random access",
            "output": "A. Faster searching"
        },
        {
            "instruction": "The time complexity for searching in a binary search tree is ________.",
            "input": "O(log n)",
            "output": "O(log n)"
        },
        {
            "instruction": "In a doubly linked list, each node has ________ pointers.",
            "input": "two",
            "output": "two"
        },
        {
            "instruction": "A stack follows the ________ principle for element retrieval.",
            "input": "LIFO",
            "output": "LIFO"
        },
        {
            "instruction": "The space complexity for a queue implemented using an array is ________.",
            "input": "O(n)",
            "output": "O(n)"
        },
        {
            "instruction": "The worst-case time complexity of inserting an element into a hash table using separate chaining is ________.",
            "input": "O(n)",
            "output": "O(n)"
        },
        {
            "instruction": "In a priority queue, the highest (or lowest) priority element is always retrieved first, which is achieved using a ________ data structure.",
            "input": "heap",
            "output": "heap"
        },
        {
            "instruction": "The time complexity for deleting the last element from a doubly linked list is ________.",
            "input": "O(1)",
            "output": "O(1)"
        },
        {
            "instruction": "A ________ is a linear data structure that follows the First In, First Out (FIFO) principle.",
            "input": "queue",
            "output": "queue"
        },
        {
            "instruction": "The space complexity for a singly linked list is ________.",
            "input": "O(n)",
            "output": "O(n)"
        },
        {
            "instruction": "In a hash table, the load factor is defined as the ratio of ________.",
            "input": "number of elements to table size",
            "output": "number of elements to table size"
        },
        {
            "instruction": "A doubly linked list is more memory-efficient than a singly linked list due to the ________ pointers in each node.",
            "input": "previous",
            "output": "previous"
        },
        {
            "instruction": "A binary search tree is a type of ________ tree, where each node has at most two children.",
            "input": "binary",
            "output": "binary"
        },
        {
            "instruction": "In a circular linked list, the last node points to the ________ node.",
            "input": "first",
            "output": "first"
        },
        {
            "instruction": "The time complexity for accessing an element in an array by index is ________.",
            "input": "O(1)",
            "output": "O(1)"
        },
        {
            "instruction": "The worst-case time complexity for searching an element in an unsorted array is ________.",
            "input": "O(n)",
            "output": "O(n)"
        },
        {
            "instruction": "The insertion and deletion operations in a stack are done in ________ time.",
            "input": "O(1)",
            "output": "O(1)"
        },
        {
            "instruction": "In a hash table, a good hash function helps to avoid ________.",
            "input": "collisions",
            "output": "collisions"
        },
        {
            "instruction": "A stack can be implemented using a ________ data structure.",
            "input": "linked list",
            "output": "linked list"
        },
        {
            "instruction": "In a binary heap, the smallest (or largest) element is always at the ________ of the heap.",
            "input": "root",
            "output": "root"
        },
        {
            "instruction": "A ________ is an unordered collection of elements that allows for fast access and retrieval.",
            "input": "hash set",
            "output": "hash set"
        },
        {
            "instruction": "A queue is typically implemented using a ________ data structure.",
            "input": "linked list",
            "output": "linked list"
        },
        {
            "instruction": "In a doubly linked list, traversal can be done in ________ direction(s).",
            "input": "two",
            "output": "two"
        },
        {
            "instruction": "The time complexity for inserting an element at the end of an array is ________.",
            "input": "O(1)",
            "output": "O(1)"
        },
        {
            "instruction": "A hash table is typically used to implement ________.",
            "input": "maps",
            "output": "maps"
        },
        {
            "instruction": "The space complexity for a binary search tree is ________.",
            "input": "O(n)",
            "output": "O(n)"
        },
        {
            "instruction": "In a priority queue, elements are sorted based on their ________.",
            "input": "priority",
            "output": "priority"
        },
        {
            "instruction": "A hash table with open addressing requires ________ space than one with separate chaining.",
            "input": "less",
            "output": "less"
        },
        {
            "instruction": "A binary search tree is considered balanced if the height of the left and right subtrees differ by at most ________.",
            "input": "one",
            "output": "one"
        },
        {
            "instruction": "The time complexity for finding the minimum element in a binary search tree is ________.",
            "input": "O(log n)",
            "output": "O(log n)"
        },
        {
            "instruction": "A doubly linked list requires ________ memory than a singly linked list due to extra pointers.",
            "input": "more",
            "output": "more"
        },
        {
            "instruction": "In a hash table, the time complexity for searching is generally ________.",
            "input": "O(1)",
            "output": "O(1)"
        },
        {
            "instruction": "A circular linked list can be used to implement a ________.",
            "input": "queue",
            "output": "queue"
        },
        {
            "instruction": "The time complexity for deleting an element from the middle of an array is ________.",
            "input": "O(n)",
            "output": "O(n)"
        },
        {
            "instruction": "A ________ is a data structure where the last element added is the first to be removed.",
            "input": "stack",
            "output": "stack"
        },
        {
            "instruction": "In a binary search tree, the left child of a node is always ________ the parent node.",
            "input": "less than",
            "output": "less than"
        },
        {
            "instruction": "The worst-case time complexity for searching an element in a binary search tree is ________.",
            "input": "O(n)",
            "output": "O(n)"
        },
        {
            "instruction": "In a priority queue, elements with higher priority are removed ________.",
            "input": "first",
            "output": "first"
        },
        {
            "instruction": "In a hash table with open addressing, when the table is full, you must ________ the table.",
            "input": "resize",
            "output": "resize"
        },
        {
            "instruction": "In a doubly linked list, each node contains ________ pointers.",
            "input": "two",
            "output": "two"
        },
        {
            "instruction": "In a circular linked list, the last node points to the ________ node.",
            "input": "first",
            "output": "first"
        },
        {
            "instruction": "In an array, the time complexity for searching an element is ________.",
            "input": "O(n)",
            "output": "O(n)"
        },
        {
            "instruction": "In a queue, elements are added from the ________ and removed from the ________.",
            "input": "rear, front",
            "output": "rear, front"
        },
        {
            "instruction": "A ________ is a type of tree where each node has at most two children.",
            "input": "binary",
            "output": "binary"
        },
        {
            "instruction": "A stack is commonly used to implement ________ in programming.",
            "input": "recursion",
            "output": "recursion"
        },
        {
            "instruction": "In a binary search tree, the time complexity for insertion is typically ________.",
            "input": "O(log n)",
            "output": "O(log n)"
        },
        {
            "instruction": "In a doubly linked list, you can traverse the list in ________ direction(s).",
            "input": "two",
            "output": "two"
        },
        {
            "instruction": "A priority queue can be implemented using a ________.",
            "input": "heap",
            "output": "heap"
        },
        {
            "instruction": "In a hash table, a collision occurs when two keys map to the same ________.",
            "input": "index",
            "output": "index"
        },
        {
            "instruction": "The time complexity of accessing an element in an array by index is ________.",
            "input": "O(1)",
            "output": "O(1)"
        },
        {
            "instruction": "In a binary heap, the largest (or smallest) element is always at the ________ of the heap.",
            "input": "root",
            "output": "root"
        },
        {
            "instruction": "In a linked list, each node contains a ________ to the next node.",
            "input": "pointer",
            "output": "pointer"
        },
        {
            "instruction": "In a binary search tree, the in-order traversal produces the ________ order of elements.",
            "input": "sorted",
            "output": "sorted"
        },
        {
            "instruction": "In a doubly linked list, the time complexity for inserting an element at the beginning is ________.",
            "input": "O(1)",
            "output": "O(1)"
        },
        {
            "instruction": "A hash set is an unordered collection that only contains ________ elements.",
            "input": "unique",
            "output": "unique"
        },
        {
            "instruction": "A hash table is typically implemented using an array and a ________ function.",
            "input": "hash",
            "output": "hash"
        },
        {
            "instruction": "A binary search tree is considered balanced when the height of the left and right subtrees differ by at most ________.",
            "input": "one",
            "output": "one"
        },
        {
            "instruction": "In a doubly linked list, removing an element from the middle of the list has a time complexity of ________.",
            "input": "O(1)",
            "output": "O(1)"
        },
        {
            "instruction": "A circular linked list can be used to implement a ________.",
            "input": "queue",
            "output": "queue"
        },
        {
            "instruction": "In a binary search tree, the time complexity for finding the maximum element is ________.",
            "input": "O(log n)",
            "output": "O(log n)"
        },
        {
            "instruction": "In a stack, the time complexity for pushing and popping elements is ________.",
            "input": "O(1)",
            "output": "O(1)"
        },
        {
            "instruction": "In a queue, the time complexity for enqueue and dequeue operations is ________.",
            "input": "O(1)",
            "output": "O(1)"
        },
        {
            "instruction": "The space complexity for a singly linked list is ________.",
            "input": "O(n)",
            "output": "O(n)"
        },
        {
            "instruction": "A stack data structure can be implemented using an array or a ________.",
            "input": "linked list",
            "output": "linked list"
        },
        {
            "instruction": "In a binary search tree, the left child of a node is always ________ than the parent node.",
            "input": "smaller",
            "output": "smaller"
        },
        {
            "instruction": "In a heap, the parent node is always ________ its children.",
            "input": "larger or smaller",
            "output": "larger or smaller"
        },
        {
            "instruction": "In a hash table, the time complexity for inserting an element is ________ in the best case.",
            "input": "O(1)",
            "output": "O(1)"
        },
        {
            "instruction": "A priority queue is typically implemented using a ________ data structure.",
            "input": "heap",
            "output": "heap"
        },
        {
            "instruction": "In a binary search tree, the time complexity for deleting an element is ________.",
            "input": "O(log n)",
            "output": "O(log n)"
        },
        {
            "instruction": "A stack follows the Last In First Out (LIFO) principle.",
            "input": "True",
            "output": "True"
        },
        {
            "instruction": "A queue follows the Last In First Out (LIFO) principle.",
            "input": "False",
            "output": "False"
        },
        {
            "instruction": "In a binary search tree, the left child of a node must be greater than the parent node.",
            "input": "False",
            "output": "False"
        },
        {
            "instruction": "In a priority queue, elements with lower priority are dequeued first.",
            "input": "False",
            "output": "False"
        },
        {
            "instruction": "In a doubly linked list, each node contains two pointers: one to the next node and one to the previous node.",
            "input": "True",
            "output": "True"
        },
        {
            "instruction": "In a hash table, a collision occurs when two keys have the same hash value.",
            "input": "True",
            "output": "True"
        },
        {
            "instruction": "A binary heap is a complete binary tree that satisfies the heap property.",
            "input": "True",
            "output": "True"
        },
        {
            "instruction": "In a singly linked list, the last node points to null.",
            "input": "True",
            "output": "True"
        },
        {
            "instruction": "In a circular linked list, the last node points to the first node.",
            "input": "True",
            "output": "True"
        },
        {
            "instruction": "A stack is typically used to implement a breadth-first search.",
            "input": "False",
            "output": "False"
        },
        {
            "instruction": "A queue is typically used to implement a depth-first search.",
            "input": "False",
            "output": "False"
        },
        {
            "instruction": "In a doubly linked list, we can traverse both forwards and backwards.",
            "input": "True",
            "output": "True"
        },
        {
            "instruction": "A hash table with chaining can store multiple values at the same index.",
            "input": "True",
            "output": "True"
        },
        {
            "instruction": "The worst-case time complexity of searching in a binary search tree is O(n).",
            "input": "True",
            "output": "True"
        },
        {
            "instruction": "In a balanced binary search tree, the height of the tree is always O(log n).",
            "input": "True",
            "output": "True"
        },
        {
            "instruction": "In a linked list, we can access an element by its index in O(1) time.",
            "input": "False",
            "output": "False"
        },
        {
            "instruction": "A binary search tree can have at most two children for each node.",
            "input": "True",
            "output": "True"
        },
        {
            "instruction": "In a binary heap, the parent node must always be smaller than its children.",
            "input": "False",
            "output": "False"
        },
        {
            "instruction": "The space complexity of a singly linked list is O(n).",
            "input": "True",
            "output": "True"
        },
        {
            "instruction": "In a doubly linked list, each node contains one pointer to the next node and another to the previous node.",
            "input": "True",
            "output": "True"
        },
        {
            "instruction": "The time complexity of deleting the last element from a singly linked list is O(1).",
            "input": "False",
            "output": "False"
        },
        {
            "instruction": "A binary search tree can be used to efficiently find the minimum or maximum element.",
            "input": "True",
            "output": "True"
        },
        {
            "instruction": "In a circular linked list, there is no notion of a 'null' node.",
            "input": "True",
            "output": "True"
        },
        {
            "instruction": "A stack can be implemented using both arrays and linked lists.",
            "input": "True",
            "output": "True"
        },
        {
            "instruction": "In a queue, elements are inserted from the front and removed from the back.",
            "input": "False",
            "output": "False"
        },
        {
            "instruction": "A priority queue is implemented using a max-heap or min-heap.",
            "input": "True",
            "output": "True"
        },
        {
            "instruction": "In a binary search tree, the time complexity for insertion is O(log n) in the worst case.",
            "input": "False",
            "output": "False"
        },
        {
            "instruction": "In a hash table, the time complexity for searching is always O(1).",
            "input": "False",
            "output": "False"
        },
        {
            "instruction": "The time complexity for inserting an element in a queue is O(1).",
            "input": "True",
            "output": "True"
        },
        {
            "instruction": "The time complexity for deleting an element from a stack is O(1).",
            "input": "True",
            "output": "True"
        },
        {
            "instruction": "A circular linked list is used in applications where we need to cycle through elements repeatedly.",
            "input": "True",
            "output": "True"
        },
        {
            "instruction": "The time complexity for finding the maximum element in a binary search tree is O(log n).",
            "input": "True",
            "output": "True"
        },
        {
            "instruction": "A heap is a binary tree that satisfies the heap property, but it does not need to be a complete binary tree.",
            "input": "False",
            "output": "False"
        },
        {
            "instruction": "The worst-case time complexity for inserting an element in a hash table is O(n).",
            "input": "True",
            "output": "True"
        },
        {
            "instruction": "A binary heap is an example of a priority queue.",
            "input": "True",
            "output": "True"
        },
        {
            "instruction": "In a binary search tree, the time complexity for finding an element is O(n) in the best case.",
            "input": "False",
            "output": "False"
        },
        {
            "instruction": "Which of the following is the time complexity for searching an element in a balanced binary search tree?",
            "input": "a) O(1) \nb) O(log n) \nc) O(n) \nd) O(n log n)",
            "output": "b) O(log n)"
        },
        {
            "instruction": "Which of the following data structures is most efficient for implementing a queue?",
            "input": "a) Array \nb) Stack \nc) Linked List \nd) Tree",
            "output": "c) Linked List"
        },
        {
            "instruction": "Which of the following operations on a linked list takes O(1) time complexity?",
            "input": "a) Accessing an element at index \nb) Inserting a node at the end \nc) Inserting a node at the beginning \nd) Deleting an element at a given index",
            "output": "c) Inserting a node at the beginning"
        },
        {
            "instruction": "What is the time complexity of inserting an element into a binary heap?",
            "input": "a) O(1) \nb) O(log n) \nc) O(n) \nd) O(n log n)",
            "output": "b) O(log n)"
        },
        {
            "instruction": "Which of the following is a characteristic of a binary search tree?",
            "input": "a) Each node has two children at maximum \nb) Nodes are inserted in a sorted order \nc) Left childs value is less than its parent \nd) All of the above",
            "output": "d) All of the above"
        },
        {
            "instruction": "Which of the following is not true about a doubly linked list?",
            "input": "a) It has a previous pointer \nb) It has a next pointer \nc) It allows traversal in both directions \nd) It requires extra space compared to singly linked list",
            "output": "d) It requires extra space compared to singly linked list"
        },
        {
            "instruction": "Which of the following data structures allows you to efficiently implement the Breadth-First Search (BFS) algorithm?",
            "input": "a) Stack \nb) Queue \nc) Tree \nd) Graph",
            "output": "b) Queue"
        },
        {
            "instruction": "What is the time complexity of accessing an element in an array at a specific index?",
            "input": "a) O(1) \nb) O(log n) \nc) O(n) \nd) O(n^2)",
            "output": "a) O(1)"
        },
        {
            "instruction": "Which of the following is true about a circular linked list?",
            "input": "a) The first node is connected to the last node \nb) The last node points to the first node \nc) It can be traversed in a circular manner \nd) All of the above",
            "output": "d) All of the above"
        },
        {
            "instruction": "In a hash table, what happens when a collision occurs?",
            "input": "a) The element is inserted at a random index \nb) The element is discarded \nc) The element is inserted in the next available index \nd) The element is inserted using chaining or open addressing",
            "output": "d) The element is inserted using chaining or open addressing"
        },
        {
            "instruction": "What is the time complexity for deleting an element from a queue implemented using a linked list?",
            "input": "a) O(1) \nb) O(log n) \nc) O(n) \nd) O(n^2)",
            "output": "a) O(1)"
        },
        {
            "instruction": "What is the main advantage of using a linked list over an array?",
            "input": "a) Faster access to elements \nb) Dynamic size \nc) Easier to sort \nd) Allows duplicate elements",
            "output": "b) Dynamic size"
        },
        {
            "instruction": "Which of the following is a type of tree where nodes have at most two children?",
            "input": "a) Binary Tree \nb) AVL Tree \nc) Binary Search Tree \nd) All of the above",
            "output": "d) All of the above"
        },
        {
            "instruction": "What is the worst-case time complexity for inserting an element into a hash table?",
            "input": "a) O(1) \nb) O(log n) \nc) O(n) \nd) O(n^2)",
            "output": "c) O(n)"
        },
        {
            "instruction": "In which of the following scenarios, a doubly linked list would be preferred over a singly linked list?",
            "input": "a) When you need to traverse in both directions \nb) When you need less memory usage \nc) When you need faster insertion at the end \nd) None of the above",
            "output": "a) When you need to traverse in both directions"
        },
        {
            "instruction": "What is the time complexity of deleting the first element from a singly linked list?",
            "input": "a) O(1) \nb) O(log n) \nc) O(n) \nd) O(n^2)",
            "output": "a) O(1)"
        },
        {
            "instruction": "Which of the following is the key benefit of a heap over an unsorted array?",
            "input": "a) It allows you to find the maximum or minimum element in O(1) time \nb) It allows you to find the maximum or minimum element in O(log n) time \nc) It allows insertion in O(1) time \nd) It allows searching in O(1) time",
            "output": "a) It allows you to find the maximum or minimum element in O(1) time"
        },
        {
            "instruction": "Which of the following algorithms uses a queue?",
            "input": "a) Dijkstras algorithm \nb) Depth First Search \nc) Breadth First Search \nd) QuickSort",
            "output": "c) Breadth First Search"
        },
        {
            "instruction": "Which of the following data structures is used to implement recursion?",
            "input": "a) Stack \nb) Queue \nc) Linked List \nd) Array",
            "output": "a) Stack"
        },
        {
            "instruction": "In a binary heap, the parent node must be larger than or equal to the children for a max heap.",
            "input": "True",
            "output": "True"
        },
        {
            "instruction": "What is the key idea behind dynamic programming?",
            "input": "A. Divide the problem into smaller subproblems\nB. Solve the problem using a greedy approach\nC. Store the solutions to subproblems for later use\nD. Solve the problem recursively without memoization",
            "output": "C. Store the solutions to subproblems for later use"
        },
        {
            "instruction": "Which of the following problems can be solved using dynamic programming?",
            "input": "A. Knapsack problem\nB. Fibonacci sequence\nC. Longest common subsequence\nD. All of the above",
            "output": "D. All of the above"
        },
        {
            "instruction": "Which of the following is NOT a property of problems suitable for dynamic programming?",
            "input": "A. Overlapping subproblems\nB. Optimal substructure\nC. Greedy approach\nD. Subproblem independence",
            "output": "C. Greedy approach"
        },
        {
            "instruction": "In dynamic programming, the technique of storing previously computed values is known as ________.",
            "input": "A. Memoization\nB. Recursion\nC. Iteration\nD. Greedy approach",
            "output": "A. Memoization"
        },
        {
            "instruction": "Which of the following is the time complexity of solving the Fibonacci number using dynamic programming?",
            "input": "A. O(2^n)\nB. O(n)\nC. O(n^2)\nD. O(nlogn)",
            "output": "B. O(n)"
        },
        {
            "instruction": "What is the space complexity of the dynamic programming approach for the 0/1 knapsack problem?",
            "input": "A. O(n)\nB. O(n^2)\nC. O(W)\nD. O(W*n)",
            "output": "D. O(W*n)"
        },
        {
            "instruction": "The dynamic programming approach for solving the longest common subsequence (LCS) problem has a time complexity of ________.",
            "input": "A. O(n^2)\nB. O(n*m)\nC. O(nlogn)\nD. O(n^3)",
            "output": "B. O(n*m)"
        },
        {
            "instruction": "Which of the following problems is solved using a bottom-up dynamic programming approach?",
            "input": "A. Fibonacci sequence\nB. Coin change problem\nC. Matrix chain multiplication\nD. All of the above",
            "output": "D. All of the above"
        },
        {
            "instruction": "In dynamic programming, the 'state' refers to ________.",
            "input": "A. The initial conditions\nB. The final solution\nC. The set of decisions or subproblems at a given point\nD. The recursion tree",
            "output": "C. The set of decisions or subproblems at a given point"
        },
        {
            "instruction": "Which of the following is the optimal substructure property in dynamic programming?",
            "input": "A. The problem can be broken down into smaller subproblems\nB. The problem can be solved using a greedy approach\nC. The problem has overlapping subproblems\nD. The solution to the problem is derived from optimal solutions to subproblems",
            "output": "D. The solution to the problem is derived from optimal solutions to subproblems"
        },
        {
            "instruction": "What is the approach used in the knapsack problem with dynamic programming?",
            "input": "A. Greedy approach\nB. Brute force\nC. Bottom-up dynamic programming\nD. Divide and conquer",
            "output": "C. Bottom-up dynamic programming"
        },
        {
            "instruction": "Which of the following is an example of a problem that can be solved with dynamic programming?",
            "input": "A. Finding the shortest path in a graph\nB. Solving the traveling salesman problem\nC. Solving the longest increasing subsequence problem\nD. Sorting an array of numbers",
            "output": "C. Solving the longest increasing subsequence problem"
        },
        {
            "instruction": "The time complexity of the matrix chain multiplication problem using dynamic programming is ________.",
            "input": "A. O(n^3)\nB. O(n^2)\nC. O(nlogn)\nD. O(n^4)",
            "output": "A. O(n^3)"
        },
        {
            "instruction": "Which technique is used in dynamic programming to solve overlapping subproblems?",
            "input": "A. Greedy approach\nB. Memoization\nC. Backtracking\nD. Randomization",
            "output": "B. Memoization"
        },
        {
            "instruction": "Which of the following is an example of a problem that is not suitable for dynamic programming?",
            "input": "A. Fibonacci sequence\nB. 0/1 knapsack problem\nC. Quick sort\nD. Matrix chain multiplication",
            "output": "C. Quick sort"
        },
        {
            "instruction": "In dynamic programming, the final solution is obtained by combining the solutions to the ________.",
            "input": "A. Base case\nB. Subproblems\nC. Overlapping subproblems\nD. Recursive calls",
            "output": "B. Subproblems"
        },
        {
            "instruction": "What is the key difference between dynamic programming and divide-and-conquer?",
            "input": "A. Divide-and-conquer solves subproblems independently, while dynamic programming solves overlapping subproblems\nB. Divide-and-conquer solves overlapping subproblems, while dynamic programming solves subproblems independently\nC. Dynamic programming is always slower than divide-and-conquer\nD. There is no difference",
            "output": "A. Divide-and-conquer solves subproblems independently, while dynamic programming solves overlapping subproblems"
        },
        {
            "instruction": "In the dynamic programming approach to the coin change problem, what is the objective?",
            "input": "A. To find the maximum number of coins needed to make a change\nB. To find the minimum number of coins needed to make a change\nC. To find the number of combinations of coins that sum to the target\nD. To find the total number of coin denominations",
            "output": "B. To find the minimum number of coins needed to make a change"
        },
        {
            "instruction": "Dynamic programming can be used to solve problems that have ________.",
            "input": "A. Optimal substructure\nB. Overlapping subproblems\nC. Both A and B\nD. Neither A nor B",
            "output": "C. Both A and B"
        },
        {
            "instruction": "The time complexity of the 0/1 knapsack problem using dynamic programming is ________.",
            "input": "A. O(W*n)\nB. O(n^2)\nC. O(nlogn)\nD. O(W^2)",
            "output": "A. O(W*n)"
        },
        {
            "instruction": "Which of the following techniques can be used to optimize dynamic programming?",
            "input": "A. Memoization\nB. Bottom-up approach\nC. Both A and B\nD. Divide and conquer",
            "output": "C. Both A and B"
        },
        {
            "instruction": "In dynamic programming, the optimal solution is obtained by solving each subproblem ________.",
            "input": "A. Independently\nB. Recursively\nC. Simultaneously\nD. Iteratively",
            "output": "B. Recursively"
        },
        {
            "instruction": "What does the term 'memoization' refer to in dynamic programming?",
            "input": "A. Storing the result of a subproblem to avoid redundant calculations\nB. Iteratively solving subproblems\nC. Dividing the problem into smaller subproblems\nD. Using a greedy approach to solve the problem",
            "output": "A. Storing the result of a subproblem to avoid redundant calculations"
        },
        {
            "instruction": "What is the primary benefit of using dynamic programming?",
            "input": "A. It reduces the time complexity of recursive algorithms\nB. It always guarantees the optimal solution\nC. It eliminates the need for recursion\nD. It simplifies the algorithm by removing unnecessary subproblems",
            "output": "A. It reduces the time complexity of recursive algorithms"
        },
        {
            "instruction": "In dynamic programming, a problem is said to have 'optimal substructure' if ________.",
            "input": "A. The problem can be broken down into smaller subproblems that can be solved independently\nB. The problem can be divided into non-overlapping subproblems\nC. The problem's solution can be derived from the optimal solutions of its subproblems\nD. The problem does not have overlapping subproblems",
            "output": "C. The problem's solution can be derived from the optimal solutions of its subproblems"
        },
        {
            "instruction": "In dynamic programming, the process of solving problems in a bottom-up fashion means ________.",
            "input": "A. Solving the problem recursively\nB. Solving the problem from the base case and building up to the final solution\nC. Solving subproblems as needed, without pre-computing them\nD. Solving the problem from the largest subproblem down to the smallest",
            "output": "B. Solving the problem from the base case and building up to the final solution"
        },
        {
            "instruction": "Which of the following is a common dynamic programming problem?",
            "input": "A. Dijkstra's shortest path\nB. Longest increasing subsequence\nC. QuickSort\nD. MergeSort",
            "output": "B. Longest increasing subsequence"
        },
        {
            "instruction": "Which of the following is the correct formula for the Fibonacci sequence using dynamic programming?",
            "input": "A. F(n) = F(n-1) + F(n-2)\nB. F(n) = F(n-1) + F(n-2) + F(n-3)\nC. F(n) = F(n-2) + F(n-3)\nD. F(n) = F(n-1) * F(n-2)",
            "output": "A. F(n) = F(n-1) + F(n-2)"
        },
        {
            "instruction": "The space complexity of the dynamic programming approach to the Fibonacci sequence is ________.",
            "input": "A. O(1)\nB. O(n)\nC. O(n^2)\nD. O(logn)",
            "output": "B. O(n)"
        },
        {
            "instruction": "Which of the following is the main advantage of dynamic programming over recursion?",
            "input": "A. Dynamic programming uses recursion, whereas recursion does not use dynamic programming\nB. Dynamic programming can solve problems with overlapping subproblems more efficiently by avoiding recomputation\nC. Dynamic programming does not use recursion\nD. Dynamic programming always provides faster solutions than recursion",
            "output": "B. Dynamic programming can solve problems with overlapping subproblems more efficiently by avoiding recomputation"
        },
        {
            "instruction": "Which of the following is a well-known dynamic programming problem for string matching?",
            "input": "A. Longest common subsequence\nB. Dijkstra's algorithm\nC. Knapsack problem\nD. Coin change problem",
            "output": "A. Longest common subsequence"
        },
        {
            "instruction": "The time complexity of the matrix chain multiplication problem using dynamic programming is ________.",
            "input": "A. O(n^2)\nB. O(n^3)\nC. O(nlogn)\nD. O(n^4)",
            "output": "B. O(n^3)"
        },
        {
            "instruction": "Which of the following is a greedy algorithm that cannot be solved using dynamic programming?",
            "input": "A. Fibonacci sequence\nB. 0/1 knapsack problem\nC. Coin change problem\nD. Activity selection problem",
            "output": "D. Activity selection problem"
        },
        {
            "instruction": "The time complexity of solving the 0/1 knapsack problem with dynamic programming is ________.",
            "input": "A. O(W*n)\nB. O(n^2)\nC. O(nlogn)\nD. O(W^2)",
            "output": "A. O(W*n)"
        },
        {
            "instruction": "In dynamic programming, which of the following problems is typically solved using the 'bottom-up' approach?",
            "input": "A. Longest common subsequence\nB. Matrix chain multiplication\nC. 0/1 knapsack\nD. All of the above",
            "output": "D. All of the above"
        },
        {
            "instruction": "Which of the following is NOT a characteristic of dynamic programming?",
            "input": "A. Overlapping subproblems\nB. Optimal substructure\nC. Divide and conquer\nD. Greedy approach",
            "output": "D. Greedy approach"
        },
        {
            "instruction": "Which of the following is the solution to the 'Rod Cutting Problem' using dynamic programming?",
            "input": "A. Recursion\nB. Iteration\nC. Bottom-up dynamic programming\nD. Divide and conquer",
            "output": "C. Bottom-up dynamic programming"
        },
        {
            "instruction": "In dynamic programming, a subproblem is ________.",
            "input": "A. A small, recursive instance of the original problem\nB. A problem that can be solved independently of other subproblems\nC. A problem that does not overlap with other subproblems\nD. A solution to the entire problem",
            "output": "A. A small, recursive instance of the original problem"
        },
        {
            "instruction": "Which of the following is the main disadvantage of dynamic programming?",
            "input": "A. It requires a lot of memory\nB. It does not guarantee optimal solutions\nC. It is slower than recursion\nD. It cannot solve overlapping subproblems",
            "output": "A. It requires a lot of memory"
        },
        {
            "instruction": "Which of the following is a valid application of dynamic programming?",
            "input": "A. Sorting an array\nB. Finding the minimum spanning tree\nC. Finding the longest common subsequence\nD. All of the above",
            "output": "C. Finding the longest common subsequence"
        },
        {
            "instruction": "Which of the following algorithms can be solved using dynamic programming?",
            "input": "A. QuickSort\nB. MergeSort\nC. Bellman-Ford algorithm\nD. Binary search",
            "output": "C. Bellman-Ford algorithm"
        },
        {
            "instruction": "Dynamic programming can be used to solve problems with ________.",
            "input": "A. Optimal substructure\nB. Overlapping subproblems\nC. Both A and B\nD. None of the above",
            "output": "C. Both A and B"
        },
        {
            "instruction": "The 0/1 knapsack problem is typically solved using ________.",
            "input": "A. Greedy algorithm\nB. Dynamic programming\nC. Divide and conquer\nD. Backtracking",
            "output": "B. Dynamic programming"
        },
        {
            "instruction": "Which of the following is an example of a problem that does NOT require dynamic programming?",
            "input": "A. Fibonacci sequence\nB. Matrix chain multiplication\nC. Coin change problem\nD. Binary search",
            "output": "D. Binary search"
        },
        {
            "instruction": "Which approach is used in dynamic programming to store the results of overlapping subproblems?",
            "input": "A. Top-down approach\nB. Bottom-up approach\nC. Greedy approach\nD. Divide and conquer approach",
            "output": "A. Top-down approach"
        },
        {
            "instruction": "What is the space complexity of the dynamic programming solution for the Fibonacci sequence?",
            "input": "A. O(1)\nB. O(n)\nC. O(n^2)\nD. O(logn)",
            "output": "B. O(n)"
        },
        {
            "instruction": "In dynamic programming, the 'memoization' technique is also known as ________.",
            "input": "A. Bottom-up computation\nB. Top-down recursion\nC. Divide and conquer\nD. Storing results to avoid recomputation",
            "output": "D. Storing results to avoid recomputation"
        },
        {
            "instruction": "Which of the following problems can be solved using the dynamic programming approach of solving subproblems in a bottom-up manner?",
            "input": "A. Longest common subsequence\nB. 0/1 knapsack\nC. Matrix chain multiplication\nD. All of the above",
            "output": "D. All of the above"
        },
        {
            "instruction": "Dynamic programming is particularly useful when subproblems ________.",
            "input": "A. Are independent of each other\nB. Overlap with each other\nC. Do not require optimal solutions\nD. Can be solved in constant time",
            "output": "B. Overlap with each other"
        },
        {
            "instruction": "Which of the following dynamic programming problems can be solved using the 'knapsack' problem?",
            "input": "A. Longest common subsequence\nB. Rod cutting problem\nC. Coin change problem\nD. Matrix chain multiplication",
            "output": "B. Rod cutting problem"
        },
        {
            "instruction": "In dynamic programming, which of the following is used to avoid redundant work when solving overlapping subproblems?",
            "input": "A. Greedy algorithm\nB. Memoization\nC. Divide and conquer\nD. Backtracking",
            "output": "B. Memoization"
        },
        {
            "instruction": "Which of the following is a common technique used to reduce the space complexity of dynamic programming algorithms?",
            "input": "A. Using a recursive approach\nB. Using a hash table\nC. Using a sliding window\nD. Using divide and conquer",
            "output": "C. Using a sliding window"
        },
        {
            "instruction": "The optimal substructure property of dynamic programming means that ________.",
            "input": "A. The problem cannot be broken into smaller subproblems\nB. The solution to the problem can be constructed from solutions to smaller subproblems\nC. The problem has no solution\nD. The subproblems cannot overlap",
            "output": "B. The solution to the problem can be constructed from solutions to smaller subproblems"
        },
        {
            "instruction": "Which of the following problems involves solving a series of subproblems with an optimal substructure property in dynamic programming?",
            "input": "A. Longest common subsequence\nB. Dijkstra's algorithm\nC. Activity selection problem\nD. QuickSort",
            "output": "A. Longest common subsequence"
        },
        {
            "instruction": "Which of the following dynamic programming problems is used to find the shortest path between two nodes in a graph?",
            "input": "A. Floyd-Warshall algorithm\nB. Bellman-Ford algorithm\nC. Knapsack problem\nD. Matrix chain multiplication",
            "output": "B. Bellman-Ford algorithm"
        },
        {
            "instruction": "In the matrix chain multiplication problem, dynamic programming is used to ________.",
            "input": "A. Find the order of matrix multiplications that minimizes the number of operations\nB. Multiply the matrices in a greedy manner\nC. Solve the problem recursively\nD. Use divide and conquer to break the problem down",
            "output": "A. Find the order of matrix multiplications that minimizes the number of operations"
        },
        {
            "instruction": "Which of the following algorithms is an example of using dynamic programming to solve an optimization problem?",
            "input": "A. Bellman-Ford algorithm\nB. Binary search\nC. Depth-first search\nD. Merge sort",
            "output": "A. Bellman-Ford algorithm"
        },
        {
            "instruction": "Which of the following problems is commonly used to demonstrate the concept of dynamic programming?",
            "input": "A. Longest increasing subsequence\nB. Binary search\nC. Depth-first search\nD. QuickSort",
            "output": "A. Longest increasing subsequence"
        },
        {
            "instruction": "In dynamic programming, a subproblem is solved ________.",
            "input": "A. Only once and stored for future use\nB. Multiple times for each recursive call\nC. By brute force calculation\nD. In a greedy manner",
            "output": "A. Only once and stored for future use"
        },
        {
            "instruction": "Which of the following is an example of a dynamic programming problem where the solution involves a combination of both recursive and iterative steps?",
            "input": "A. Fibonacci sequence\nB. Coin change problem\nC. 0/1 knapsack problem\nD. All of the above",
            "output": "D. All of the above"
        },
        {
            "instruction": "Which of the following is an example of a greedy algorithm that cannot be solved using dynamic programming?",
            "input": "A. 0/1 Knapsack\nB. Coin Change Problem\nC. Activity Selection Problem\nD. Longest Common Subsequence",
            "output": "C. Activity Selection Problem"
        },
        {
            "instruction": "Which of the following dynamic programming problems is used to solve the problem of finding the longest increasing subsequence?",
            "input": "A. 0/1 Knapsack\nB. Fibonacci Sequence\nC. Longest Common Subsequence\nD. Longest Increasing Subsequence",
            "output": "D. Longest Increasing Subsequence"
        },
        {
            "instruction": "In dynamic programming, a 'state' typically refers to ________.",
            "input": "A. A solution to the subproblem\nB. A recursive call\nC. The size of the problem\nD. The set of subproblems being solved",
            "output": "A. A solution to the subproblem"
        },
        {
            "instruction": "Dynamic programming typically involves breaking down a problem into smaller, manageable subproblems, which are then solved ________.",
            "input": "A. In a bottom-up manner\nB. Using brute force\nC. By divide and conquer\nD. Using recursion without optimization",
            "output": "A. In a bottom-up manner"
        },
        {
            "instruction": "In dynamic programming, the subproblem solutions are stored in a ________ to avoid recomputation.",
            "input": "A. Hash table\nB. Lookup table\nC. Recursion stack\nD. Queue",
            "output": "B. Lookup table"
        },
        {
            "instruction": "What is the main advantage of using dynamic programming over a simple recursive approach?",
            "input": "A. Faster computation by avoiding redundant work\nB. More memory usage\nC. Requires fewer steps\nD. Solves only small problems",
            "output": "A. Faster computation by avoiding redundant work"
        },
        {
            "instruction": "Which of the following is NOT a characteristic of problems solvable by dynamic programming?",
            "input": "A. Overlapping subproblems\nB. Optimal substructure\nC. Greedy choices\nD. Repeated subproblem structure",
            "output": "C. Greedy choices"
        },
        {
            "instruction": "In dynamic programming, which of the following methods can be used to store solutions to subproblems?",
            "input": "A. Memoization\nB. Recursion\nC. Stacks\nD. Loops",
            "output": "A. Memoization"
        },
        {
            "instruction": "What is the time complexity of the dynamic programming solution to the Fibonacci sequence problem?",
            "input": "A. O(1)\nB. O(n)\nC. O(n^2)\nD. O(2^n)",
            "output": "B. O(n)"
        },
        {
            "instruction": "Which of the following techniques can be used to optimize a dynamic programming solution in terms of space complexity?",
            "input": "A. Reducing the recursion depth\nB. Using a sliding window\nC. Converting recursive calls into iterative loops\nD. Using a hash table",
            "output": "B. Using a sliding window"
        },
        {
            "instruction": "The 'Knapsack Problem' is a classic example of a dynamic programming problem. What is the primary challenge in solving this problem?",
            "input": "A. Minimizing the weight\nB. Maximizing the value within a given weight limit\nC. Maximizing the number of items\nD. Finding the most optimal sorting order",
            "output": "B. Maximizing the value within a given weight limit"
        },
        {
            "instruction": "The term 'memoization' refers to the technique of ________.",
            "input": "A. Storing computed values for future use\nB. Recursively dividing the problem\nC. Breaking the problem into smaller pieces\nD. Solving the problem using greedy choices",
            "output": "A. Storing computed values for future use"
        },
        {
            "instruction": "The 'Rod Cutting Problem' is an example of a dynamic programming problem that uses ________.",
            "input": "A. Greedy algorithm\nB. Divide and conquer\nC. Optimal substructure\nD. Backtracking",
            "output": "C. Optimal substructure"
        },
        {
            "instruction": "Which of the following problems can be efficiently solved using dynamic programming?",
            "input": "A. Traveling Salesman Problem\nB. Matrix Chain Multiplication\nC. Sorting algorithms\nD. Binary search",
            "output": "B. Matrix Chain Multiplication"
        },
        {
            "instruction": "Dynamic programming can be used to solve which of the following problems optimally?",
            "input": "A. Longest common subsequence\nB. Knapsack problem\nC. Coin change problem\nD. All of the above",
            "output": "D. All of the above"
        },
        {
            "instruction": "Which of the following is true about dynamic programming?",
            "input": "A. It always uses recursive techniques\nB. It always uses greedy algorithms\nC. It reduces the time complexity by storing results of subproblems\nD. It is only useful for problems with no overlapping subproblems",
            "output": "C. It reduces the time complexity by storing results of subproblems"
        },
        {
            "instruction": "The 'Fibonacci Sequence' is an example of a problem that can be solved using dynamic programming because it has ________.",
            "input": "A. Optimal substructure\nB. No overlapping subproblems\nC. Repeated subproblems\nD. Both A and C",
            "output": "D. Both A and C"
        },
        {
            "instruction": "Which of the following is a dynamic programming approach used to solve the 0/1 Knapsack Problem?",
            "input": "A. Backtracking\nB. Greedy algorithms\nC. Bottom-up approach\nD. Divide and conquer",
            "output": "C. Bottom-up approach"
        },
        {
            "instruction": "In the 'Longest Common Subsequence' problem, dynamic programming is used to avoid recomputing solutions to overlapping subproblems by ________.",
            "input": "A. Storing previously computed results\nB. Using recursive calls\nC. Sorting the input sequences\nD. Using divide and conquer",
            "output": "A. Storing previously computed results"
        },
        {
            "instruction": "Dynamic programming is especially useful for optimization problems where the solution involves ________.",
            "input": "A. Randomized choices\nB. Storing intermediate results\nC. Making greedy decisions\nD. Recursive decomposition into subproblems",
            "output": "D. Recursive decomposition into subproblems"
        },
        {
            "instruction": "Which of the following is an example of an optimization problem that can be solved using dynamic programming?",
            "input": "A. Longest increasing subsequence\nB. QuickSort\nC. Binary search\nD. Merge sort",
            "output": "A. Longest increasing subsequence"
        },
        {
            "instruction": "Which of the following is an advantage of using dynamic programming over a simple recursive approach?",
            "input": "A. Lower time complexity\nB. Simpler code\nC. Reduced memory usage\nD. More complicated code",
            "output": "A. Lower time complexity"
        },
        {
            "instruction": "Which of the following problems can be solved using dynamic programming?",
            "input": "A. Finding the shortest path in a graph\nB. Finding the largest prime factor\nC. Calculating the nth Fibonacci number\nD. Sorting a list of elements",
            "output": "C. Calculating the nth Fibonacci number"
        },
        {
            "instruction": "What is the space complexity of a bottom-up dynamic programming solution to the Fibonacci problem?",
            "input": "A. O(1)\nB. O(n)\nC. O(n^2)\nD. O(log n)",
            "output": "B. O(n)"
        },
        {
            "instruction": "Which of the following is a correct approach for implementing a dynamic programming solution?",
            "input": "A. Divide the problem into subproblems, solve them recursively, and combine their results\nB. Use a greedy algorithm to make local decisions\nC. Solve the problem iteratively using a stack\nD. All of the above",
            "output": "A. Divide the problem into subproblems, solve them recursively, and combine their results"
        },
        {
            "instruction": "Which problem is commonly solved using dynamic programming by calculating the minimum number of operations required to convert one string into another?",
            "input": "A. Longest Common Subsequence\nB. Edit Distance\nC. Matrix Chain Multiplication\nD. Subset Sum",
            "output": "B. Edit Distance"
        },
        {
            "instruction": "In dynamic programming, 'optimal substructure' means that ________.",
            "input": "A. The solution to the problem can be obtained by solving subproblems optimally\nB. The problem cannot be solved recursively\nC. The problem must be solved using a greedy approach\nD. The solution requires no intermediate steps",
            "output": "A. The solution to the problem can be obtained by solving subproblems optimally"
        },
        {
            "instruction": "The time complexity of solving the 0/1 knapsack problem using dynamic programming is ________.",
            "input": "A. O(n)\nB. O(n^2)\nC. O(n * W)\nD. O(W)",
            "output": "C. O(n * W)"
        },
        {
            "instruction": "In the dynamic programming solution to the 'Coin Change Problem,' what is the primary task?",
            "input": "A. Minimizing the number of coins used\nB. Finding the largest number of coins\nC. Maximizing the total value of coins\nD. Finding the fewest number of coins that add up to a given value",
            "output": "D. Finding the fewest number of coins that add up to a given value"
        },
        {
            "instruction": "Which dynamic programming problem involves finding the number of ways to climb a staircase with n steps, where at each step, you can take either 1 or 2 steps?",
            "input": "A. Fibonacci Sequence\nB. Coin Change Problem\nC. Stairs Problem\nD. Matrix Chain Multiplication",
            "output": "C. Stairs Problem"
        },
        {
            "instruction": "What is the key difference between a greedy algorithm and dynamic programming?",
            "input": "A. Dynamic programming makes a choice based on the current state, while greedy algorithms make local optimal choices\nB. Greedy algorithms store subproblem solutions while dynamic programming does not\nC. Dynamic programming solves problems in a single pass, while greedy algorithms require multiple passes\nD. None of the above",
            "output": "A. Dynamic programming makes a choice based on the current state, while greedy algorithms make local optimal choices"
        },
        {
            "instruction": "What is the primary goal of dynamic programming?",
            "input": "A. To solve optimization problems\nB. To break down a problem into smaller subproblems\nC. To find an optimal solution\nD. All of the above",
            "output": "D. All of the above"
        },
        {
            "instruction": "The Matrix Chain Multiplication problem involves finding the optimal way to multiply a sequence of matrices in order to ________.",
            "input": "A. Maximize the number of operations\nB. Minimize the total number of scalar multiplications\nC. Minimize the number of matrices\nD. Maximize the number of matrices",
            "output": "B. Minimize the total number of scalar multiplications"
        },
        {
            "instruction": "Dynamic programming is not suitable for problems with ________.",
            "input": "A. Overlapping subproblems\nB. Optimal substructure\nC. No optimal substructure\nD. High computational requirements",
            "output": "C. No optimal substructure"
        },
        {
            "instruction": "Which dynamic programming algorithm can be used to solve the problem of finding the longest common subsequence between two sequences?",
            "input": "A. Longest Common Subsequence (LCS)\nB. Fibonacci Sequence\nC. Matrix Chain Multiplication\nD. Coin Change Problem",
            "output": "A. Longest Common Subsequence (LCS)"
        },
        {
            "instruction": "What type of dynamic programming technique is used in the 0/1 knapsack problem to avoid recomputation of subproblems?",
            "input": "A. Memoization\nB. Greedy strategy\nC. Recursion\nD. Tabulation",
            "output": "D. Tabulation"
        },
        {
            "instruction": "The Bellman-Ford algorithm, which is used to find the shortest path in a graph, is an example of ________.",
            "input": "A. A greedy algorithm\nB. A dynamic programming algorithm\nC. A divide-and-conquer algorithm\nD. A depth-first search algorithm",
            "output": "B. A dynamic programming algorithm"
        },
        {
            "instruction": "The time complexity of the 'Longest Common Subsequence' problem when solved using dynamic programming is ________.",
            "input": "A. O(n^2)\nB. O(n * m)\nC. O(n^3)\nD. O(2^n)",
            "output": "B. O(n * m)"
        },
        {
            "instruction": "Dynamic programming can be applied to the problem of finding the maximum sum of non-adjacent elements in an array by using ________.",
            "input": "A. The greedy strategy\nB. Recursion without memoization\nC. A bottom-up approach\nD. A top-down approach",
            "output": "C. A bottom-up approach"
        },
        {
            "instruction": "Which of the following dynamic programming algorithms solves the problem of finding the shortest path between two nodes in a graph with positive edge weights?",
            "input": "A. Dijkstra's Algorithm\nB. Bellman-Ford Algorithm\nC. Floyd-Warshall Algorithm\nD. All of the above",
            "output": "D. All of the above"
        },
        {
            "instruction": "The time complexity of the 'Longest Increasing Subsequence' problem using dynamic programming is ________.",
            "input": "A. O(n)\nB. O(n^2)\nC. O(n^3)\nD. O(2^n)",
            "output": "B. O(n^2)"
        },
        {
            "instruction": "In the 'Rod Cutting Problem' using dynamic programming, the objective is to maximize ________.",
            "input": "A. The number of pieces\nB. The total length of the rod\nC. The total value obtained by cutting the rod\nD. The number of cuts needed",
            "output": "C. The total value obtained by cutting the rod"
        },
        {
            "instruction": "In the 0/1 Knapsack problem, if the weight capacity of the knapsack is W and the number of items is n, the time complexity of solving it using dynamic programming is ________.",
            "input": "A. O(n)\nB. O(W)\nC. O(n * W)\nD. O(W^2)",
            "output": "C. O(n * W)"
        },
        {
            "instruction": "Which of the following is a characteristic of dynamic programming algorithms?",
            "input": "A. Greedy decisions\nB. Overlapping subproblems\nC. Divide and conquer approach\nD. Constant time complexity",
            "output": "B. Overlapping subproblems"
        },
        {
            "instruction": "The time complexity of the Fibonacci sequence when solved using dynamic programming is ________.",
            "input": "A. O(n)\nB. O(n^2)\nC. O(2^n)\nD. O(n log n)",
            "output": "A. O(n)"
        },
        {
            "instruction": "Which of the following problems is best solved using dynamic programming due to overlapping subproblems?",
            "input": "A. Longest Common Subsequence\nB. Binary Search\nC. Sorting algorithms\nD. Depth-First Search",
            "output": "A. Longest Common Subsequence"
        },
        {
            "instruction": "Which problem is a classic example of the use of dynamic programming to optimize the solution by considering subproblems in a bottom-up manner?",
            "input": "A. Coin Change Problem\nB. Binary Search Problem\nC. Maximum Subarray Sum\nD. Breadth-First Search",
            "output": "A. Coin Change Problem"
        },
        {
            "instruction": "What is the space complexity of solving the Longest Common Subsequence problem using dynamic programming?",
            "input": "A. O(1)\nB. O(n^2)\nC. O(n * m)\nD. O(log n)",
            "output": "C. O(n * m)"
        },
        {
            "instruction": "Which of the following problems is most suited for dynamic programming?",
            "input": "A. Fibonacci Sequence\nB. Linear Search\nC. Depth-First Search\nD. Binary Search",
            "output": "A. Fibonacci Sequence"
        },
        {
            "instruction": "In the dynamic programming solution for the 'Matrix Chain Multiplication' problem, what is being minimized?",
            "input": "A. The number of multiplications\nB. The number of matrices\nC. The total number of computations\nD. The size of the matrix",
            "output": "A. The number of multiplications"
        },
        {
            "instruction": "Dynamic programming helps to avoid recomputation by using ________.",
            "input": "A. Recursion\nB. Memoization\nC. Greedy choice\nD. Binary search",
            "output": "B. Memoization"
        },
        {
            "instruction": "The time complexity of the dynamic programming approach for solving the 'Longest Palindromic Subsequence' problem is ________.",
            "input": "A. O(n^2)\nB. O(n^3)\nC. O(2^n)\nD. O(n log n)",
            "output": "A. O(n^2)"
        },
        {
            "instruction": "The Knapsack problem can be solved efficiently by dynamic programming if the problem has ________.",
            "input": "A. No optimal substructure\nB. Multiple subproblems with overlapping results\nC. A greedy approach can be applied\nD. A simple recursive solution",
            "output": "B. Multiple subproblems with overlapping results"
        },
        {
            "instruction": "In dynamic programming, the process of solving problems is typically done by ________.",
            "input": "A. Breaking the problem into subproblems and solving them recursively\nB. Searching for the best possible solution from the start\nC. Dividing the problem into equal-sized subproblems\nD. Using a divide-and-conquer approach",
            "output": "A. Breaking the problem into subproblems and solving them recursively"
        },
        {
            "instruction": "In dynamic programming, the 'Tabulation' technique is also known as ________.",
            "input": "A. Top-down approach\nB. Bottom-up approach\nC. Divide and conquer\nD. Greedy approach",
            "output": "B. Bottom-up approach"
        },
        {
            "instruction": "The time complexity of solving the 'Longest Common Substring' problem using dynamic programming is ________.",
            "input": "A. O(n^2)\nB. O(n * m)\nC. O(n^3)\nD. O(n log n)",
            "output": "B. O(n * m)"
        },
        {
            "instruction": "Which dynamic programming problem involves finding the maximum sum of elements in a subsequence, where no two elements are adjacent?",
            "input": "A. Longest Common Subsequence\nB. Maximum Subarray Sum\nC. House Robber Problem\nD. Coin Change Problem",
            "output": "C. House Robber Problem"
        },
        {
            "instruction": "Dynamic programming is particularly useful for solving optimization problems because it ________.",
            "input": "A. Focuses on greedy solutions\nB. Minimizes the number of recursive calls\nC. Maximizes the computational efficiency\nD. Breaks down the problem into smaller, overlapping subproblems",
            "output": "D. Breaks down the problem into smaller, overlapping subproblems"
        },
        {
            "instruction": "Which of the following problems can be solved by dynamic programming to find the minimum number of coins needed to make change for a given amount?",
            "input": "A. Longest Common Subsequence\nB. Fibonacci Sequence\nC. Coin Change Problem\nD. Matrix Chain Multiplication",
            "output": "C. Coin Change Problem"
        },
        {
            "instruction": "Which of the following algorithms is used to find the longest common subsequence between two sequences?",
            "input": "A. Bellman-Ford Algorithm\nB. Dynamic Programming Approach\nC. Kruskal's Algorithm\nD. Floyd-Warshall Algorithm",
            "output": "B. Dynamic Programming Approach"
        },
        {
            "instruction": "The minimum number of operations required to convert one string into another is calculated using ________ in dynamic programming.",
            "input": "A. Fibonacci Sequence\nB. Edit Distance\nC. Longest Common Subsequence\nD. Matrix Chain Multiplication",
            "output": "B. Edit Distance"
        },
        {
            "instruction": "In dynamic programming, the approach of solving subproblems and storing their results for future use is called ________.",
            "input": "",
            "output": "memoization"
        },
        {
            "instruction": "The technique used in dynamic programming where subproblems are solved iteratively, starting with the smallest subproblem, is called ________.",
            "input": "",
            "output": "tabulation"
        },
        {
            "instruction": "The time complexity of the 0/1 Knapsack problem using dynamic programming is O(n * ________).",
            "input": "",
            "output": "W"
        },
        {
            "instruction": "In the 'Rod Cutting Problem', the goal is to maximize the ________ obtained from cutting the rod into smaller lengths.",
            "input": "",
            "output": "profit"
        },
        {
            "instruction": "The dynamic programming solution for the Longest Common Subsequence problem typically uses a 2D ________ to store intermediate results.",
            "input": "",
            "output": "array"
        },
        {
            "instruction": "The space complexity of solving the Longest Common Subsequence problem using dynamic programming is O(n * ________).",
            "input": "",
            "output": "m"
        },
        {
            "instruction": "In dynamic programming, when we solve a problem by breaking it into subproblems, each subproblem is solved ________.",
            "input": "",
            "output": "once"
        },
        {
            "instruction": "The dynamic programming approach to the 'Coin Change Problem' aims to minimize the ________ required to make a given amount of change.",
            "input": "",
            "output": "coins"
        },
        {
            "instruction": "In the dynamic programming approach for the 'Fibonacci Sequence', the values of previous Fibonacci numbers are stored in a ________ to avoid recomputation.",
            "input": "",
            "output": "table"
        },
        {
            "instruction": "The space complexity of the 'Knapsack Problem' when solved using dynamic programming is O(n * ________).",
            "input": "",
            "output": "W"
        },
        {
            "instruction": "In dynamic programming, the idea of solving the problem by solving smaller subproblems is known as ________.",
            "input": "",
            "output": "optimal substructure"
        },
        {
            "instruction": "The Longest Increasing Subsequence problem is a classic example of a problem that can be solved using ________.",
            "input": "",
            "output": "dynamic programming"
        },
        {
            "instruction": "The dynamic programming solution for the 'Edit Distance' problem computes the minimum number of ________ required to transform one string into another.",
            "input": "",
            "output": "operations"
        },
        {
            "instruction": "The 'Matrix Chain Multiplication' problem seeks to minimize the total number of ________ performed to multiply a chain of matrices.",
            "input": "",
            "output": "multiplications"
        },
        {
            "instruction": "The optimal substructure property in dynamic programming means that the solution to a problem can be constructed from ________.",
            "input": "",
            "output": "solutions to subproblems"
        },
        {
            "instruction": "The 'Longest Palindromic Subsequence' problem is typically solved using ________ to store intermediate results and avoid recomputation.",
            "input": "",
            "output": "dynamic programming"
        },
        {
            "instruction": "In dynamic programming, overlapping subproblems occur when the same subproblem is solved ________ during the computation process.",
            "input": "",
            "output": "multiple times"
        },
        {
            "instruction": "The time complexity of solving the 'Longest Common Substring' problem using dynamic programming is O(n * ________).",
            "input": "",
            "output": "m"
        },
        {
            "instruction": "In the 'House Robber Problem', the goal is to maximize the ________ that can be stolen without robbing two adjacent houses.",
            "input": "",
            "output": "profit"
        },
        {
            "instruction": "The dynamic programming solution for the '0/1 Knapsack Problem' builds a table where each entry represents the maximum ________ for a given weight capacity.",
            "input": "",
            "output": "value"
        },
        {
            "instruction": "Dynamic programming is an optimization technique used to solve problems by breaking them down into smaller subproblems.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "Dynamic programming always results in faster algorithms than divide-and-conquer.",
            "input": "",
            "output": "False"
        },
        {
            "instruction": "In dynamic programming, the technique of memoization involves solving subproblems recursively and storing their results.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "Tabulation is the bottom-up approach in dynamic programming where we start from the smallest subproblem and iteratively build up to the solution.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "In dynamic programming, the 'Coin Change Problem' aims to minimize the number of coins needed to make change for a given amount.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "The space complexity of the dynamic programming solution for the Fibonacci sequence is O(n).",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "In dynamic programming, we only solve each subproblem once and store its result for future reference.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "Dynamic programming is not applicable to problems that do not exhibit optimal substructure.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "The 'Longest Common Subsequence' problem can be solved using dynamic programming to find the longest sequence that appears in both strings.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "In the 'Rod Cutting Problem', dynamic programming helps to find the maximum revenue obtainable from cutting a rod into smaller pieces.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "Dynamic programming can only be used for problems with a single optimal solution.",
            "input": "",
            "output": "False"
        },
        {
            "instruction": "In dynamic programming, the 'Knapsack Problem' aims to maximize the total value of items that can be included in the knapsack without exceeding the weight capacity.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "In the 'Longest Increasing Subsequence' problem, dynamic programming helps to find the longest subsequence in a sequence of numbers that is strictly increasing.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "Dynamic programming can be used to solve problems that involve making decisions at multiple stages, where each decision affects future decisions.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "The space complexity of the dynamic programming solution for the '0/1 Knapsack Problem' is proportional to the number of items.",
            "input": "",
            "output": "False"
        },
        {
            "instruction": "In dynamic programming, the 'Matrix Chain Multiplication' problem is solved by determining the most efficient order of matrix multiplication.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "Dynamic programming guarantees an optimal solution for problems with overlapping subproblems.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "The time complexity of the 'Fibonacci Sequence' problem solved using dynamic programming is O(2^n).",
            "input": "",
            "output": "False"
        },
        {
            "instruction": "Dynamic programming can be used to solve problems that require finding an optimal solution by considering all possible solutions.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "Dynamic programming is generally slower than a greedy algorithm for solving optimization problems.",
            "input": "",
            "output": "False"
        },
        {
            "instruction": "In dynamic programming, we solve the subproblems in a random order without worrying about their dependencies.",
            "input": "",
            "output": "False"
        },
        {
            "instruction": "Memoization is an optimization technique where we store the results of expensive function calls to avoid redundant calculations.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "The optimal substructure property means that the problem can be solved by combining the solutions to subproblems.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "In the 'Edit Distance' problem, dynamic programming is used to find the minimum number of insertions, deletions, or substitutions required to transform one string into another.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "The space complexity of dynamic programming algorithms is always O(n) or less.",
            "input": "",
            "output": "False"
        },
        {
            "instruction": "Dynamic programming always requires storing results for all possible subproblems.",
            "input": "",
            "output": "False"
        },
        {
            "instruction": "The 'Longest Palindromic Subsequence' problem is an example of a problem that can be solved using dynamic programming.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "Dynamic programming is less efficient than a brute force approach in all cases.",
            "input": "",
            "output": "False"
        },
        {
            "instruction": "Dynamic programming can be used to solve optimization problems where decisions must be made sequentially over time.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "The space complexity of dynamic programming can be reduced using techniques such as space optimization or rolling arrays.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "Dynamic programming is a technique suitable for problems where solutions involve a sequence of decisions with interdependencies.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "The time complexity of dynamic programming solutions is often exponential, especially when subproblems are not stored.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "Dynamic programming is used only for problems that do not have overlapping subproblems.",
            "input": "",
            "output": "False"
        },
        {
            "instruction": "In dynamic programming, once a subproblem is solved, its result is never revisited or recomputed.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "The 'Traveling Salesman Problem' can be solved using dynamic programming.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "The number of subproblems in dynamic programming depends only on the input size, not on the specific problem being solved.",
            "input": "",
            "output": "False"
        },
        {
            "instruction": "Dynamic programming is useful for solving problems with both optimal substructure and overlapping subproblems.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "Dynamic programming can always solve problems faster than brute force algorithms, regardless of the problem.",
            "input": "",
            "output": "False"
        },
        {
            "instruction": "In dynamic programming, a problem is solved by breaking it down into smaller overlapping subproblems that are solved and stored for future use.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "Dynamic programming is used to solve problems that have __________ subproblems.",
            "input": "overlapping",
            "output": "overlapping"
        },
        {
            "instruction": "The process of solving subproblems and storing their results to avoid recomputation is called __________.",
            "input": "memoization",
            "output": "memoization"
        },
        {
            "instruction": "In dynamic programming, the __________ approach builds the solution to the problem by solving smaller subproblems.",
            "input": "bottom-up",
            "output": "bottom-up"
        },
        {
            "instruction": "Dynamic programming is often used to solve problems that exhibit __________ substructure.",
            "input": "optimal",
            "output": "optimal"
        },
        {
            "instruction": "The time complexity of dynamic programming solutions is often reduced from __________ to a polynomial time complexity.",
            "input": "exponential",
            "output": "exponential"
        },
        {
            "instruction": "In the __________ problem, dynamic programming is used to find the maximum revenue from cutting a rod into smaller pieces.",
            "input": "Rod Cutting",
            "output": "Rod Cutting"
        },
        {
            "instruction": "In the __________ problem, dynamic programming is used to find the longest sequence that can be derived from two sequences of numbers.",
            "input": "Longest Common Subsequence",
            "output": "Longest Common Subsequence"
        },
        {
            "instruction": "The __________ problem involves finding the shortest path between two points in a graph using dynamic programming.",
            "input": "Shortest Path",
            "output": "Shortest Path"
        },
        {
            "instruction": "The __________ problem is a classic dynamic programming problem where the goal is to find the optimal way to pack items into a knapsack without exceeding its capacity.",
            "input": "0/1 Knapsack",
            "output": "0/1 Knapsack"
        },
        {
            "instruction": "Dynamic programming helps solve problems by reducing the number of __________ that need to be solved.",
            "input": "subproblems",
            "output": "subproblems"
        },
        {
            "instruction": "In the __________ problem, dynamic programming is used to calculate the minimum number of insertions, deletions, or substitutions to transform one string into another.",
            "input": "Edit Distance",
            "output": "Edit Distance"
        },
        {
            "instruction": "The __________ problem is a dynamic programming problem where the goal is to calculate the longest subsequence of a sequence that is strictly increasing.",
            "input": "Longest Increasing Subsequence",
            "output": "Longest Increasing Subsequence"
        },
        {
            "instruction": "The __________ problem is solved using dynamic programming by optimizing the selection of the best combination of items based on value and weight.",
            "input": "Knapsack",
            "output": "Knapsack"
        },
        {
            "instruction": "Dynamic programming can be used to find solutions to optimization problems that have __________ decisions.",
            "input": "sequential",
            "output": "sequential"
        },
        {
            "instruction": "In the __________ problem, dynamic programming helps find the number of ways to climb a set of stairs where you can take one or two steps at a time.",
            "input": "Climbing Stairs",
            "output": "Climbing Stairs"
        },
        {
            "instruction": "In dynamic programming, the __________ technique builds the solution starting from the smallest subproblem and moves toward the final solution.",
            "input": "tabulation",
            "output": "tabulation"
        },
        {
            "instruction": "The __________ problem is a classic dynamic programming problem that involves finding the most efficient way to multiply a chain of matrices.",
            "input": "Matrix Chain Multiplication",
            "output": "Matrix Chain Multiplication"
        },
        {
            "instruction": "Dynamic programming problems often involve finding the optimal solution by considering all possible __________.",
            "input": "decisions",
            "output": "decisions"
        },
        {
            "instruction": "The __________ problem is an example where dynamic programming can be applied to find the longest palindromic subsequence.",
            "input": "Longest Palindromic Subsequence",
            "output": "Longest Palindromic Subsequence"
        },
        {
            "instruction": "Dynamic programming helps solve problems by breaking them into __________ that can be solved independently and then combining their results.",
            "input": "subproblems",
            "output": "subproblems"
        },
        {
            "instruction": "The __________ problem is solved by dynamic programming to find the maximum sum of non-adjacent numbers from a sequence.",
            "input": "House Robber",
            "output": "House Robber"
        },
        {
            "instruction": "In dynamic programming, the __________ technique involves solving problems by solving the subproblems recursively and then storing their results for reuse.",
            "input": "memoization",
            "output": "memoization"
        },
        {
            "instruction": "In Python, the method used to add an element to the end of a list is ______.",
            "input": "",
            "output": "append()"
        },
        {
            "instruction": "In Java, strings are immutable, meaning that any modification creates a new ______.",
            "input": "",
            "output": "string"
        },
        {
            "instruction": "In JavaScript, to find the length of an array, you can use the ______ property.",
            "input": "",
            "output": "length"
        },
        {
            "instruction": "In C++, arrays are initialized with a size that is ______ during runtime.",
            "input": "",
            "output": "fixed"
        },
        {
            "instruction": "In Java, the ______ method is used to compare two strings for equality.",
            "input": "",
            "output": "equals()"
        },
        {
            "instruction": "In C, strings are represented as arrays of characters ending with a ______ character.",
            "input": "",
            "output": "null ('\\0')"
        },
        {
            "instruction": "In Python, a string can be converted into a list of its characters using the ______ function.",
            "input": "",
            "output": "list()"
        },
        {
            "instruction": "In JavaScript, ______ notation is used to access array elements by their index.",
            "input": "",
            "output": "bracket"
        },
        {
            "instruction": "In Java, the ______ keyword is used to declare an array with a specific data type.",
            "input": "",
            "output": "new"
        },
        {
            "instruction": "In Python, ______ indexing allows access to elements from the end of a list.",
            "input": "",
            "output": "negative"
        },
        {
            "instruction": "In C++, the ______ method is used to get the size of a vector, which is a dynamic array.",
            "input": "",
            "output": "size()"
        },
        {
            "instruction": "In JavaScript, the ______ method removes the last element from an array.",
            "input": "",
            "output": "pop()"
        },
        {
            "instruction": "In Java, the ______ method is used to split a string into an array based on a specified delimiter.",
            "input": "",
            "output": "split()"
        },
        {
            "instruction": "In Python, the ______ function can be used to find the length of an array or string.",
            "input": "",
            "output": "len()"
        },
        {
            "instruction": "In C, the standard library function ______ is used to copy one string to another.",
            "input": "",
            "output": "strcpy"
        },
        {
            "instruction": "In JavaScript, the ______ method joins all elements of an array into a single string.",
            "input": "",
            "output": "join()"
        },
        {
            "instruction": "In C++, strings are part of the ______ library, which allows for dynamic string manipulation.",
            "input": "",
            "output": "<string>"
        },
        {
            "instruction": "In Python, the ______ operator can be used to concatenate two strings.",
            "input": "",
            "output": "+"
        },
        {
            "instruction": "In Java, the index of the first element in an array is always ______.",
            "input": "",
            "output": "0"
        },
        {
            "instruction": "In JavaScript, the ______ method adds one or more elements to the end of an array.",
            "input": "",
            "output": "push()"
        },
        {
            "instruction": "In Python, the method used to add an element to the end of a list is ______.",
            "input": "",
            "output": "append()"
        },
        {
            "instruction": "In Java, strings are immutable, meaning that any modification creates a new ______.",
            "input": "",
            "output": "string"
        },
        {
            "instruction": "In JavaScript, to find the length of an array, you can use the ______ property.",
            "input": "",
            "output": "length"
        },
        {
            "instruction": "In C++, arrays are initialized with a size that is ______ during runtime.",
            "input": "",
            "output": "fixed"
        },
        {
            "instruction": "In Java, the ______ method is used to compare two strings for equality.",
            "input": "",
            "output": "equals()"
        },
        {
            "instruction": "In C, strings are represented as arrays of characters ending with a ______ character.",
            "input": "",
            "output": "null ('\\0')"
        },
        {
            "instruction": "In Python, a string can be converted into a list of its characters using the ______ function.",
            "input": "",
            "output": "list()"
        },
        {
            "instruction": "In JavaScript, ______ notation is used to access array elements by their index.",
            "input": "",
            "output": "bracket"
        },
        {
            "instruction": "In Java, the ______ keyword is used to declare an array with a specific data type.",
            "input": "",
            "output": "new"
        },
        {
            "instruction": "In Python, ______ indexing allows access to elements from the end of a list.",
            "input": "",
            "output": "negative"
        },
        {
            "instruction": "In C++, the ______ method is used to get the size of a vector, which is a dynamic array.",
            "input": "",
            "output": "size()"
        },
        {
            "instruction": "In JavaScript, the ______ method removes the last element from an array.",
            "input": "",
            "output": "pop()"
        },
        {
            "instruction": "In Java, the ______ method is used to split a string into an array based on a specified delimiter.",
            "input": "",
            "output": "split()"
        },
        {
            "instruction": "In Python, the ______ function can be used to find the length of an array or string.",
            "input": "",
            "output": "len()"
        },
        {
            "instruction": "In C, the standard library function ______ is used to copy one string to another.",
            "input": "",
            "output": "strcpy"
        },
        {
            "instruction": "In JavaScript, the ______ method joins all elements of an array into a single string.",
            "input": "",
            "output": "join()"
        },
        {
            "instruction": "In C++, strings are part of the ______ library, which allows for dynamic string manipulation.",
            "input": "",
            "output": "<string>"
        },
        {
            "instruction": "In Python, the ______ operator can be used to concatenate two strings.",
            "input": "",
            "output": "+"
        },
        {
            "instruction": "In Java, the index of the first element in an array is always ______.",
            "input": "",
            "output": "0"
        },
        {
            "instruction": "In JavaScript, the ______ method adds one or more elements to the end of an array.",
            "input": "",
            "output": "push()"
        },
        {
            "instruction": "In Java, the toCharArray() method converts a string into an array of characters.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "In Python, strings are immutable, so any modification creates a new string.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "In C, arrays passed to functions do not carry information about their size.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "In JavaScript, the concat() method can join two arrays and return a new array.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "In C++, the string class provides the length() method to get the number of characters in a string.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "In JavaScript, array elements can be accessed using dot notation (e.g., array.0).",
            "input": "",
            "output": "False"
        },
        {
            "instruction": "In Python, the append() method adds an element to the end of a list, which can function as an array.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "In Java, arrays are objects, and their size is specified using the length attribute.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "In JavaScript, strings and arrays share the same methods and properties.",
            "input": "",
            "output": "False"
        },
        {
            "instruction": "In Python, the range() function generates a list when used in loops by default.",
            "input": "",
            "output": "False"
        },
        {
            "instruction": "In JavaScript, the length property of a string counts the number of characters, including spaces.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "In Python, you can concatenate strings using the '+' operator.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "In Java, the length of an array is determined at runtime and cannot be changed.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "In C, the last character of a string must be a null terminator '\\0'.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "In most programming languages, accessing an array index out of bounds will cause a runtime error.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "A multi-dimensional array can have varying row lengths in Java.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "In JavaScript, array methods like push() and pop() modify the original array.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "In Python, attempting to access a non-existent array index returns None.",
            "input": "",
            "output": "False"
        },
        {
            "instruction": "In Java, the split() method can divide a string into an array of substrings based on a specified delimiter.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "Concatenating strings in Java creates a new string each time, as strings are immutable.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "In C#, strings are stored as an array of characters and are mutable.",
            "input": "",
            "output": "False"
        },
        {
            "instruction": "In Python, the len() function can be used to get the length of a string or an array.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "In JavaScript, the shift() method removes the first element of an array.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "In most languages, arrays have a fixed size and cannot grow or shrink after initialization.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "A string in C++ is terminated with a semicolon by default.",
            "input": "",
            "output": "False"
        },
        {
            "instruction": "In JavaScript, the slice() method on a string extracts a section and returns it as a new string.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "In Java, strings are created with double quotes, while characters are created with single quotes.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "In Python, lists can be used as an alternative to arrays, and they can hold multiple data types.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "In most programming languages, strings and arrays can be compared using the '==' operator to check for equality.",
            "input": "",
            "output": "False"
        },
        {
            "instruction": "In Java, the equals() method should be used to compare two strings.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "Is the index of an array in most programming languages zero-based?",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "In a string, the character at index 5 is always the 5th character in the string.",
            "input": "",
            "output": "False"
        },
        {
            "instruction": "In some programming languages, arrays are immutable by default.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "In a 2D array, you can access the element at row 2, column 3 with the syntax array[2][3].",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "Arrays in Java can only store elements of the same data type.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "Strings are mutable in Python by default.",
            "input": "",
            "output": "False"
        },
        {
            "instruction": "You can directly change the value of an array element in most programming languages.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "The length of an array is always equal to the number of elements in the array.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "Arrays in C++ can dynamically change their size during runtime.",
            "input": "",
            "output": "False"
        },
        {
            "instruction": "In an array, negative indices always refer to elements at the end of the array.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "Strings in Java are mutable by default.",
            "input": "",
            "output": "False"
        },
        {
            "instruction": "An array in JavaScript can hold multiple data types.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "Arrays in most languages are contiguous blocks of memory.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "In Python, an array can contain both numbers and strings simultaneously.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "You can append elements to a string in C++ without converting it to a character array.",
            "input": "",
            "output": "False"
        },
        {
            "instruction": "In most programming languages, arrays are reference types.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "You can store null values in a string array.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "Strings in most programming languages are treated as a sequence of characters.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "In C++, a string is a collection of characters, but it is not an array.",
            "input": "",
            "output": "False"
        },
        {
            "instruction": "A string can be represented as an array of characters in most programming languages.",
            "input": "",
            "output": "True"
        },
        {
            "instruction": "In Python, what does the expression 'len(\"hello\")' return?",
            "input": "A. 4\nB. 5\nC. 6\nD. None",
            "output": "B"
        },
        {
            "instruction": "In Java, which of these correctly checks if an array 'arr' of integers is empty?",
            "input": "A. arr.isEmpty()\nB. arr == null\nC. arr.length == 0\nD. arr.size() == 0",
            "output": "C"
        },
        {
            "instruction": "In JavaScript, what is the purpose of 'Array.prototype.splice()'?",
            "input": "A. Add or remove elements from an array\nB. Create a new array with elements from another array\nC. Sort elements\nD. Merge arrays",
            "output": "A"
        },
        {
            "instruction": "What is the output of '\"Python\".lower()' in Python?",
            "input": "A. python\nB. PYTHON\nC. Python\nD. None of the above",
            "output": "A"
        },
        {
            "instruction": "In C++, how can you find the size of an array declared as 'int arr[10]'?",
            "input": "A. arr.size()\nB. sizeof(arr)/sizeof(arr[0])\nC. arr.length\nD. arr.count()",
            "output": "B"
        },
        {
            "instruction": "What does 'str1 + str2' do in Python when 'str1' and 'str2' are strings?",
            "input": "A. Multiplies the strings\nB. Adds the ASCII values of the characters\nC. Concatenates the strings\nD. None of the above",
            "output": "C"
        },
        {
            "instruction": "In JavaScript, what is the index of 'c' in the string \"abcdef\"?",
            "input": "A. 1\nB. 2\nC. 3\nD. None",
            "output": "B"
        },
        {
            "instruction": "In Java, which method converts an integer array to a list?",
            "input": "A. Arrays.toArray(arr)\nB. Arrays.asList(arr)\nC. List.toArray(arr)\nD. arr.toList()",
            "output": "B"
        },
        {
            "instruction": "In C, which function would you use to copy one string to another?",
            "input": "A. strcpy()\nB. stradd()\nC. strcp()\nD. strmove()",
            "output": "A"
        },
        {
            "instruction": "What is the result of 'str.split(',')' in Python if 'str' is \"apple,banana,cherry\"?",
            "input": "A. ['apple', 'banana', 'cherry']\nB. ['apple banana cherry']\nC. ['apple', 'banana cherry']\nD. Throws an error",
            "output": "A"
        },
        {
            "instruction": "In JavaScript, which of these methods removes the last element from an array?",
            "input": "A. remove()\nB. delete()\nC. pop()\nD. shift()",
            "output": "C"
        },
        {
            "instruction": "In Python, what does 'arr.count(3)' return if 'arr' is [1, 3, 3, 4]?",
            "input": "A. 1\nB. 2\nC. 3\nD. 0",
            "output": "B"
        },
        {
            "instruction": "In C++, what will 'arr.begin()' return if 'arr' is a non-empty vector?",
            "input": "A. An iterator to the first element\nB. An iterator to the last element\nC. The first element itself\nD. The last element itself",
            "output": "A"
        },
        {
            "instruction": "In Java, what does 'str.charAt(0)' return if 'str' is \"Hello\"?",
            "input": "A. 'H'\nB. \"Hello\"\nC. 'e'\nD. 'o'",
            "output": "A"
        },
        {
            "instruction": "In JavaScript, what is the output of 'arr.reverse()' if 'arr' is [1, 2, 3]?",
            "input": "A. [1, 2, 3]\nB. [3, 2, 1]\nC. [1, 3, 2]\nD. Throws an error",
            "output": "B"
        },
        {
            "instruction": "Which function in Python removes whitespace from both ends of a string?",
            "input": "A. strip()\nB. trim()\nC. whitespace()\nD. clear()",
            "output": "A"
        },
        {
            "instruction": "In C, which of the following will concatenate two strings?",
            "input": "A. strcat()\nB. append()\nC. stradd()\nD. concat()",
            "output": "A"
        },
        {
            "instruction": "In Python, what does 'str.find(\"z\")' return if 'str' is \"hello\"?",
            "input": "A. -1\nB. 0\nC. 4\nD. Throws an error",
            "output": "A"
        },
        {
            "instruction": "In Java, which method checks if a string starts with a specific prefix?",
            "input": "A. startsWith()\nB. beginsWith()\nC. initWith()\nD. prefix()",
            "output": "A"
        },
        {
            "instruction": "In JavaScript, what does 'arr.includes(2)' return if 'arr' is [1, 2, 3]?",
            "input": "A. true\nB. false\nC. 2\nD. Throws an error",
            "output": "A"
        },
        {
            "instruction": "In Python, what will 'str.upper()' return if 'str' is 'hello world'?",
            "input": "A. HELLO WORLD\nB. Hello World\nC. hello world\nD. None of the above",
            "output": "A"
        },
        {
            "instruction": "In C++, how can you access the first element of a vector 'arr'?",
            "input": "A. arr[0]\nB. arr.first()\nC. arr.at(1)\nD. arr.begin()",
            "output": "A"
        },
        {
            "instruction": "What does 'strcat()' do in C when used with two character arrays?",
            "input": "A. Copies one string to another\nB. Concatenates two strings\nC. Splits the string\nD. None of the above",
            "output": "B"
        },
        {
            "instruction": "In JavaScript, what is returned by 'arr.length' if 'arr' is ['apple', 'banana', 'cherry']?",
            "input": "A. 2\nB. 3\nC. 4\nD. Undefined",
            "output": "B"
        },
        {
            "instruction": "In Python, what does 'str.strip()' do to the string ' str '?",
            "input": "A. Removes only spaces at the beginning\nB. Removes spaces at the beginning and end\nC. Removes all spaces in the string\nD. Adds spaces to the string",
            "output": "B"
        },
        {
            "instruction": "How do you declare an array of integers in JavaScript?",
            "input": "A. int[] arr;\nB. var arr = [];\nC. Array arr[];\nD. var arr = new Array();",
            "output": "B"
        },
        {
            "instruction": "In Python, what does 's[::-1]' do if 's' is a string?",
            "input": "A. Repeats the string\nB. Reverses the string\nC. Removes spaces\nD. Converts to uppercase",
            "output": "B"
        },
        {
            "instruction": "Which of the following is true about arrays in C?",
            "input": "A. Array size can change during execution\nB. Array indices start at 1\nC. Arrays are fixed in size\nD. Arrays can store different data types",
            "output": "C"
        },
        {
            "instruction": "In C++, what is the result of 'arr.front()' if 'arr' is a non-empty vector?",
            "input": "A. The last element\nB. The first element\nC. The middle element\nD. None of the above",
            "output": "B"
        },
        {
            "instruction": "What will be the output of 'str.split(\"\")' in Python if 'str' is \"hello\"?",
            "input": "A. ['hello']\nB. ['h', 'e', 'l', 'l', 'o']\nC. ['he', 'llo']\nD. None of the above",
            "output": "B"
        },
        {
            "instruction": "In Java, how would you initialize an array of 10 integers?",
            "input": "A. int arr(10);\nB. int[] arr = new int[10];\nC. arr = new int[10];\nD. int arr[] = new Array(10);",
            "output": "B"
        },
        {
            "instruction": "What is the result of 'len(arr)' in Python if 'arr' is [1, 2, 3, 4]?",
            "input": "A. 2\nB. 4\nC. 5\nD. 3",
            "output": "B"
        },
        {
            "instruction": "In JavaScript, what does 'str.indexOf(\"a\")' return if 'str' is \"banana\"?",
            "input": "A. -1\nB. 1\nC. 0\nD. 3",
            "output": "B"
        },
        {
            "instruction": "What will 'str.replace(\"world\", \"everyone\")' do in Python if 'str' is \"Hello world\"?",
            "input": "A. Returns \"Hello everyone\"\nB. Changes 'str' to \"Hello everyone\"\nC. Returns \"world everyone\"\nD. Throws an error",
            "output": "A"
        },
        {
            "instruction": "In C++, which method is used to add an element to the end of a vector?",
            "input": "A. push_back()\nB. append()\nC. insert()\nD. add()",
            "output": "A"
        },
        {
            "instruction": "In JavaScript, what is the output of 'str.toUpperCase()' if 'str' is \"goodbye\"?",
            "input": "A. goodbye\nB. GOODBYE\nC. goodBYE\nD. Goodbye",
            "output": "B"
        },
        {
            "instruction": "In Python, what does 'str[1:3]' return if 'str' is \"Python\"?",
            "input": "A. Pyt\nB. Py\nC. th\nD. yt",
            "output": "D"
        },
        {
            "instruction": "What is the output of 'arr.reverse()' in Python if 'arr' is [1, 2, 3, 4]?",
            "input": "A. [4, 3, 2, 1]\nB. [1, 2, 3, 4]\nC. [4]\nD. Throws an error",
            "output": "A"
        },
        {
            "instruction": "In Java, what does 'Arrays.sort(arr)' do to 'arr' if 'arr' is an integer array?",
            "input": "A. Reverses 'arr'\nB. Sorts 'arr' in ascending order\nC. Removes duplicates\nD. Sorts 'arr' in descending order",
            "output": "B"
        },
        {
            "instruction": "Which function in Python returns the last index of a substring in a string?",
            "input": "A. find()\nB. rfind()\nC. index()\nD. lastIndex()",
            "output": "B"
        },
        {
            "instruction": "In Python, what will 'str.upper()' return if 'str' is 'hello world'?",
            "input": "A. HELLO WORLD\nB. Hello World\nC. hello world\nD. None of the above",
            "output": "A"
        },
        {
            "instruction": "In C++, how can you access the first element of a vector 'arr'?",
            "input": "A. arr[0]\nB. arr.first()\nC. arr.at(1)\nD. arr.begin()",
            "output": "A"
        },
        {
            "instruction": "What does 'strcat()' do in C when used with two character arrays?",
            "input": "A. Copies one string to another\nB. Concatenates two strings\nC. Splits the string\nD. None of the above",
            "output": "B"
        },
        {
            "instruction": "In JavaScript, what is returned by 'arr.length' if 'arr' is ['apple', 'banana', 'cherry']?",
            "input": "A. 2\nB. 3\nC. 4\nD. Undefined",
            "output": "B"
        },
        {
            "instruction": "In Python, what does 'str.strip()' do to the string ' str '?",
            "input": "A. Removes only spaces at the beginning\nB. Removes spaces at the beginning and end\nC. Removes all spaces in the string\nD. Adds spaces to the string",
            "output": "B"
        },
        {
            "instruction": "How do you declare an array of integers in JavaScript?",
            "input": "A. int[] arr;\nB. var arr = [];\nC. Array arr[];\nD. var arr = new Array();",
            "output": "B"
        },
        {
            "instruction": "In Python, what does 's[::-1]' do if 's' is a string?",
            "input": "A. Repeats the string\nB. Reverses the string\nC. Removes spaces\nD. Converts to uppercase",
            "output": "B"
        },
        {
            "instruction": "Which of the following is true about arrays in C?",
            "input": "A. Array size can change during execution\nB. Array indices start at 1\nC. Arrays are fixed in size\nD. Arrays can store different data types",
            "output": "C"
        },
        {
            "instruction": "In C++, what is the result of 'arr.front()' if 'arr' is a non-empty vector?",
            "input": "A. The last element\nB. The first element\nC. The middle element\nD. None of the above",
            "output": "B"
        },
        {
            "instruction": "What will be the output of 'str.split(\"\")' in Python if 'str' is \"hello\"?",
            "input": "A. ['hello']\nB. ['h', 'e', 'l', 'l', 'o']\nC. ['he', 'llo']\nD. None of the above",
            "output": "B"
        },
        {
            "instruction": "In Java, how would you initialize an array of 10 integers?",
            "input": "A. int arr(10);\nB. int[] arr = new int[10];\nC. arr = new int[10];\nD. int arr[] = new Array(10);",
            "output": "B"
        },
        {
            "instruction": "What is the result of 'len(arr)' in Python if 'arr' is [1, 2, 3, 4]?",
            "input": "A. 2\nB. 4\nC. 5\nD. 3",
            "output": "B"
        },
        {
            "instruction": "In JavaScript, what does 'str.indexOf(\"a\")' return if 'str' is \"banana\"?",
            "input": "A. -1\nB. 1\nC. 0\nD. 3",
            "output": "B"
        },
        {
            "instruction": "What will 'str.replace(\"world\", \"everyone\")' do in Python if 'str' is \"Hello world\"?",
            "input": "A. Returns \"Hello everyone\"\nB. Changes 'str' to \"Hello everyone\"\nC. Returns \"world everyone\"\nD. Throws an error",
            "output": "A"
        },
        {
            "instruction": "In C++, which method is used to add an element to the end of a vector?",
            "input": "A. push_back()\nB. append()\nC. insert()\nD. add()",
            "output": "A"
        },
        {
            "instruction": "In JavaScript, what is the output of 'str.toUpperCase()' if 'str' is \"goodbye\"?",
            "input": "A. goodbye\nB. GOODBYE\nC. goodBYE\nD. Goodbye",
            "output": "B"
        },
        {
            "instruction": "In Python, what does 'str[1:3]' return if 'str' is \"Python\"?",
            "input": "A. Pyt\nB. Py\nC. th\nD. yt",
            "output": "D"
        },
        {
            "instruction": "What is the output of 'arr.reverse()' in Python if 'arr' is [1, 2, 3, 4]?",
            "input": "A. [4, 3, 2, 1]\nB. [1, 2, 3, 4]\nC. [4]\nD. Throws an error",
            "output": "A"
        },
        {
            "instruction": "In Java, what does 'Arrays.sort(arr)' do to 'arr' if 'arr' is an integer array?",
            "input": "A. Reverses 'arr'\nB. Sorts 'arr' in ascending order\nC. Removes duplicates\nD. Sorts 'arr' in descending order",
            "output": "B"
        },
        {
            "instruction": "Which function in Python returns the last index of a substring in a string?",
            "input": "A. find()\nB. rfind()\nC. index()\nD. lastIndex()",
            "output": "B"
        },
        {
            "instruction": "In Python, what does the expression 'len(arr)' return?",
            "input": "A. The size of each element in 'arr'\nB. The length of 'arr'\nC. The last index in 'arr'\nD. An error",
            "output": "B"
        },
        {
            "instruction": "Which of these C++ STL containers would be best for dynamically resizing an array?",
            "input": "A. vector\nB. array\nC. list\nD. map",
            "output": "A"
        },
        {
            "instruction": "In Python, what will 'str.find(\"a\")' return if 'str' is \"banana\"?",
            "input": "A. 0\nB. 1\nC. 3\nD. -1",
            "output": "1"
        },
        {
            "instruction": "What does 'array.length' represent in JavaScript?",
            "input": "A. The size of each element\nB. The total number of elements\nC. The maximum index\nD. Undefined behavior",
            "output": "B"
        },
        {
            "instruction": "In C++, how can you declare a fixed-size array of 10 integers?",
            "input": "A. int arr(10);\nB. int arr[10];\nC. arr = new int[10];\nD. int arr<10>;",
            "output": "B"
        },
        {
            "instruction": "In Python, what does 'arr.append(5)' do if 'arr' is a list?",
            "input": "A. Adds 5 at the start\nB. Adds 5 at the end\nC. Replaces all elements with 5\nD. Inserts 5 at a random position",
            "output": "B"
        },
        {
            "instruction": "In JavaScript, what does 'str.split(\" \")' return if 'str' is \"hello world\"?",
            "input": "A. ['hello', 'world']\nB. 'hello world'\nC. 'world hello'\nD. Throws an error",
            "output": "A"
        },
        {
            "instruction": "How do you convert a string to lowercase in Python?",
            "input": "A. str.lowercase()\nB. str.toLowerCase()\nC. str.lower()\nD. lowercase(str)",
            "output": "C"
        },
        {
            "instruction": "In C, what is the output of 'printf(\"%d\", arr[2])' if 'arr' is an array with less than 3 elements?",
            "input": "A. 0\nB. The third element\nC. Undefined behavior\nD. Throws a compile error",
            "output": "C"
        },
        {
            "instruction": "In C++, what does 'arr.size()' return if 'arr' is a vector?",
            "input": "A. Size of each element\nB. Total number of elements\nC. Last index\nD. Throws an error",
            "output": "B"
        },
        {
            "instruction": "Which method is used to reverse a list in Python?",
            "input": "A. reverseList()\nB. reverse()\nC. reversed()\nD. list.reverse()",
            "output": "D"
        },
        {
            "instruction": "What does 'arr.pop()' do in JavaScript if 'arr' is an array?",
            "input": "A. Removes the first element\nB. Removes the last element\nC. Clears the entire array\nD. Adds an element to the start",
            "output": "B"
        },
        {
            "instruction": "In Python, which operator would you use to concatenate two strings 's1' and 's2'?",
            "input": "A. s1 + s2\nB. s1 * s2\nC. s1 & s2\nD. concat(s1, s2)",
            "output": "A"
        },
        {
            "instruction": "How would you declare a string array with 5 elements in C?",
            "input": "A. char arr[] = \"hello\";\nB. char* arr[5];\nC. String arr[5];\nD. char arr[5];",
            "output": "B"
        },
        {
            "instruction": "In JavaScript, what does 'Array.isArray(arr)' check?",
            "input": "A. If arr is empty\nB. If arr has only integers\nC. If arr is an array\nD. If arr contains null values",
            "output": "C"
        },
        {
            "instruction": "What does 'arr.unshift(3)' do in JavaScript if 'arr' is an array?",
            "input": "A. Adds 3 at the end\nB. Removes 3 from the start\nC. Adds 3 at the start\nD. Shifts 3 to the right",
            "output": "C"
        },
        {
            "instruction": "In Python, what will 'str.count(\"a\")' return if 'str' is \"banana\"?",
            "input": "A. 1\nB. 2\nC. 3\nD. 0",
            "output": "C"
        },
        {
            "instruction": "What is the function of 'arr.sort()' in JavaScript?",
            "input": "A. Reverses the array\nB. Sorts the array in ascending order\nC. Clears the array\nD. Adds an element to the array",
            "output": "B"
        },
        {
            "instruction": "Which method would you use to check if a character exists in a string in Python?",
            "input": "A. check()\nB. in\nC. has()\nD. contains()",
            "output": "B"
        },
        {
            "instruction": "In Java, what does 'str.replace(\"a\", \"e\")' do if 'str' is \"banana\"?",
            "input": "A. Returns 'benene'\nB. Replaces the first 'a' with 'e'\nC. Replaces all 'a' with 'e'\nD. Throws an error",
            "output": "C"
        },
        {
            "instruction": "Which of these methods will convert a string to an array of characters in Java?",
            "input": "A. toArray()\nB. charAt()\nC. toCharArray()\nD. parseArray()",
            "output": "C"
        },
        {
            "instruction": "What will 'Arrays.binarySearch(arr, key)' return if the key is not present in the array?",
            "input": "A. -1\nB. The position it would be inserted\nC. 0\nD. Throws an error",
            "output": "B"
        },
        {
            "instruction": "Which method can be used to join elements of an array into a single string in Java?",
            "input": "A. join()\nB. concat()\nC. toString()\nD. toCharArray()",
            "output": "A"
        },
        {
            "instruction": "What is the result of 'str.substring(2, 5)' if 'str' is \"abcdef\"?",
            "input": "A. \"cde\"\nB. \"bcd\"\nC. \"c\"\nD. \"bcde\"",
            "output": "A"
        },
        {
            "instruction": "How do you initialize an array of strings in Java?",
            "input": "A. String[] arr = {\"A\", \"B\"};\nB. String arr = {\"A\", \"B\"};\nC. String arr = new String[2];\nD. String arr[2];",
            "output": "A"
        },
        {
            "instruction": "What will 'System.out.println(arr[3])' display if 'arr' is an array of 3 elements?",
            "input": "A. The third element\nB. The fourth element\nC. Null\nD. Throws an ArrayIndexOutOfBoundsException",
            "output": "D"
        },
        {
            "instruction": "How does the 'trim()' method modify a string in Java?",
            "input": "A. Removes all spaces\nB. Removes leading and trailing spaces\nC. Converts to lowercase\nD. Converts to uppercase",
            "output": "B"
        },
        {
            "instruction": "What will 'Arrays.fill(arr, 5)' do to an integer array in Java?",
            "input": "A. Fill the array with the value 5\nB. Set the size of the array to 5\nC. Sort the array in ascending order\nD. Set all elements to 0",
            "output": "A"
        },
        {
            "instruction": "What does 'str.compareTo(\"test\")' return if 'str' is \"apple\"?",
            "input": "A. -1\nB. 0\nC. A positive or negative integer\nD. An error",
            "output": "C"
        },
        {
            "instruction": "Which method is used to concatenate strings in Java?",
            "input": "A. add()\nB. concat()\nC. append()\nD. merge()",
            "output": "B"
        },
        {
            "instruction": "What does 'String[] arr = new String[3];' initialize in Java?",
            "input": "A. An array of 3 null strings\nB. An array of 3 empty strings\nC. An array with random strings\nD. An array with 3 default strings",
            "output": "A"
        },
        {
            "instruction": "What does 'str.toUpperCase()' return?",
            "input": "A. String in lowercase\nB. String in uppercase\nC. First letter capitalized\nD. Removes spaces",
            "output": "B"
        },
        {
            "instruction": "What is the result of 'Arrays.toString(arr)' in Java?",
            "input": "A. Converts array to a single string\nB. Converts array to an int\nC. Adds elements of array\nD. Throws an error",
            "output": "A"
        },
        {
            "instruction": "What will 'str.contains(\"abc\")' return if 'str' is \"abcdef\"?",
            "input": "A. true\nB. false\nC. Throws an error\nD. The index of \"abc\"",
            "output": "A"
        },
        {
            "instruction": "How do you declare a multi-dimensional array in Java?",
            "input": "A. int[][] arr\nB. int arr[][]\nC. Both A and B\nD. Java does not support multi-dimensional arrays",
            "output": "C"
        },
        {
            "instruction": "What is the default value of elements in an integer array in Java?",
            "input": "A. null\nB. 0\nC. Undefined\nD. 1",
            "output": "B"
        },
        {
            "instruction": "What will 'str.startsWith(\"abc\")' return if 'str' is \"abcdef\"?",
            "input": "A. true\nB. false\nC. Throws an error\nD. The index of \"abc\"",
            "output": "A"
        },
        {
            "instruction": "Which method checks if two strings have the same content?",
            "input": "A. equals()\nB. compareTo()\nC. contains()\nD. substring()",
            "output": "A"
        },
        {
            "instruction": "In Java, what does 'str.endsWith(\"xyz\")' return if 'str' is \"helloxyz\"?",
            "input": "A. true\nB. false\nC. Throws an error\nD. The length of the string",
            "output": "A"
        },
        {
            "instruction": "What is returned by 'str.substring(0)' if 'str' is \"hello\"?",
            "input": "A. \"h\"\nB. \"hello\"\nC. An empty string\nD. Throws an error",
            "output": "B"
        },
        {
            "instruction": "What does 'str.length()' return in Java if str is a string?",
            "input": "A. Number of characters in str\nB. The length of the array\nC. Index of last character\nD. Sum of ASCII values",
            "output": "A"
        },
        {
            "instruction": "What will 'Arrays.sort(arr)' do to an integer array in Java?",
            "input": "A. Sorts the array in ascending order\nB. Sorts the array in descending order\nC. Leaves the array unsorted\nD. Reverses the array",
            "output": "A"
        },
        {
            "instruction": "In Java, which of these returns the character at index 3 in a string 'str'?",
            "input": "A. str.charAt(2)\nB. str.charAt(3)\nC. str[3]\nD. str.indexOf(3)",
            "output": "B"
        },
        {
            "instruction": "What is an immutable object in Java?",
            "input": "A. An object that can change\nB. An object that cannot change\nC. An array\nD. A list",
            "output": "B"
        },
        {
            "instruction": "How is the end of a string indicated in Java?",
            "input": "A. With a null character\nB. Automatically managed\nC. With a period (.)\nD. With a newline",
            "output": "B"
        },
        {
            "instruction": "What happens when you try to access an array element at a negative index in Java?",
            "input": "A. It returns the first element\nB. Throws an ArrayIndexOutOfBoundsException\nC. It returns null\nD. It returns -1",
            "output": "B"
        },
        {
            "instruction": "Which method splits a string into an array based on a given delimiter?",
            "input": "A. split()\nB. parse()\nC. separate()\nD. divide()",
            "output": "A"
        },
        {
            "instruction": "What will 'String.valueOf(123)' return?",
            "input": "A. 123 as an integer\nB. 123 as a string\nC. 'one hundred twenty-three'\nD. Throws an error",
            "output": "B"
        },
        {
            "instruction": "In Java, what does 'Arrays.equals(arr1, arr2)' check?",
            "input": "A. If arr1 and arr2 are sorted\nB. If arr1 and arr2 are identical objects\nC. If arr1 and arr2 have the same elements\nD. If arr1 is null",
            "output": "C"
        },
        {
            "instruction": "What does 'str.replace('a', 'b')' do?",
            "input": "A. Replaces all 'b' with 'a' in str\nB. Replaces all 'a' with 'b' in str\nC. Removes 'a' from str\nD. Removes 'b' from str",
            "output": "B"
        },
        {
            "instruction": "Which statement about array copying in Java is true?",
            "input": "A. Arrays can only be copied using loops\nB. Arrays.copyOf() can be used to copy arrays\nC. Arrays can't be copied\nD. Only single-dimensional arrays can be copied",
            "output": "B"
        },
        {
            "instruction": "What will 'String.join(\"-\", \"A\", \"B\", \"C\")' return?",
            "input": "A. \"ABC\"\nB. \"A-B-C\"\nC. \"-A-B-C-\"\nD. \"A-B-C-\"",
            "output": "B"
        },
        {
            "instruction": "What will 'int[] arr = new int[5]' do?",
            "input": "A. Create an empty array\nB. Create an array of 5 integers, all set to 0\nC. Throw an error\nD. Create an array with 5 random integers",
            "output": "B"
        },
        {
            "instruction": "How do you check if an array is empty in Java?",
            "input": "A. arr == null\nB. arr.isEmpty()\nC. arr.length == 0\nD. arr.equals(\"\")",
            "output": "C"
        },
        {
            "instruction": "Which function allows for replacing a portion of a string?",
            "input": "A. replace()\nB. subString()\nC. charAt()\nD. split()",
            "output": "A"
        },
        {
            "instruction": "How are arrays in Java initialized by default?",
            "input": "A. With null\nB. With random values\nC. With zero values (for numbers)\nD. With 1 for integers",
            "output": "C"
        },
        {
            "instruction": "In Java, what does the method 'contains()' do in a string?",
            "input": "A. Checks if the string contains a specific character or substring\nB. Converts the string to uppercase\nC. Finds the length of the string\nD. Converts the string to lowercase",
            "output": "A"
        },
        {
            "instruction": "Which data type cannot be used in a Java array?",
            "input": "A. int\nB. String\nC. boolean\nD. void",
            "output": "D"
        },
        {
            "instruction": "What will 'arr[arr.length]' result in if 'arr' is an array in Java?",
            "input": "A. The last element of arr\nB. The first element of arr\nC. Throws an ArrayIndexOutOfBoundsException\nD. Returns null",
            "output": "C"
        },
        {
            "instruction": "What will 'str.indexOf(\"z\")' return if 'z' is not in the string 'str'?",
            "input": "A. -1\nB. 0\nC. null\nD. Throws an error",
            "output": "A"
        },
        {
            "instruction": "What is the default value of elements in an integer array in Java?",
            "input": "A. 1\nB. 0\nC. null\nD. -1",
            "output": "B"
        },
        {
            "instruction": "Which method can convert an array to a string representation in Java?",
            "input": "A. toString()\nB. Arrays.toString()\nC. stringify()\nD. arrayToString()",
            "output": "B"
        },
        {
            "instruction": "What will 'arr[0] = 10;' do if 'arr' is an integer array in Java?",
            "input": "A. Set the first element to 10\nB. Set the last element to 10\nC. Set all elements to 10\nD. Throw an error",
            "output": "A"
        },
        {
            "instruction": "In Java, which method is used to get a substring from a string?",
            "input": "A. getString()\nB. substring()\nC. subStringAt()\nD. splitString()",
            "output": "B"
        },
        {
            "instruction": "What is the purpose of 'indexOf()' in strings?",
            "input": "A. Finds the length of a string\nB. Finds the index of a character or substring\nC. Replaces a character\nD. Converts to uppercase",
            "output": "B"
        },
        {
            "instruction": "Which statement about arrays in Java is correct?",
            "input": "A. Arrays are dynamic in size\nB. Array indices start from 1\nC. Arrays are fixed in size\nD. Arrays can store only strings",
            "output": "C"
        },
        {
            "instruction": "How can you initialize a string in Java?",
            "input": "A. String s = new String();\nB. String s = \"\";\nC. String s = null;\nD. All of the above",
            "output": "D"
        },
        {
            "instruction": "What does 'str.trim()' do in Java?",
            "input": "A. Removes characters from a string\nB. Converts a string to lowercase\nC. Removes whitespace from the beginning and end of a string\nD. Finds the length of a string",
            "output": "C"
        },
        {
            "instruction": "What will happen if an index out of bounds is accessed in an array?",
            "input": "A. The program will run normally\nB. It will print 'null'\nC. It will throw an ArrayIndexOutOfBoundsException\nD. It will return -1",
            "output": "C"
        },
        {
            "instruction": "Which of these is not a valid string method in Java?",
            "input": "A. length()\nB. charAt()\nC. toInt()\nD. substring()",
            "output": "C"
        },
        {
            "instruction": "Which of the following describes a jagged array?",
            "input": "A. An array with rows of different lengths\nB. An array with identical elements\nC. An array that can store different data types\nD. An array with only one row",
            "output": "A"
        },
        {
            "instruction": "What does the following code return?\n\nString str = \"Java\";\nstr.substring(1, 3);",
            "input": "A. Jav\nB. Ja\nC. av\nD. va",
            "output": "C"
        },
        {
            "instruction": "Which method would you use to convert a string to uppercase in Java?",
            "input": "A. upperCase()\nB. toUpperCase()\nC. convertToUpper()\nD. setUpper()",
            "output": "B"
        },
        {
            "instruction": "What does the 'Arrays.fill(arr, 5)' method do?",
            "input": "A. Fills the array with zeros\nB. Fills the array with ones\nC. Fills the array with the value 5\nD. Leaves the array unchanged",
            "output": "C"
        },
        {
            "instruction": "In Java, how are characters stored in a string?",
            "input": "A. As an array of characters\nB. As integers\nC. As bytes\nD. As ASCII values",
            "output": "A"
        },
        {
            "instruction": "Which function checks if a string starts with a specific prefix?",
            "input": "A. startsWith()\nB. beginsWith()\nC. prefix()\nD. isPrefix()",
            "output": "A"
        },
        {
            "instruction": "How do you find the last occurrence of a character in a string?",
            "input": "A. lastIndexOf()\nB. findLast()\nC. indexOf()\nD. charAt()",
            "output": "A"
        },
        {
            "instruction": "Which data type can be used to declare an array of strings?",
            "input": "A. String[]\nB. StringArray\nC. arrayString\nD. ArrayOfString",
            "output": "A"
        },
        {
            "instruction": "Which array operation is not allowed in Java?",
            "input": "A. Retrieving an element by index\nB. Modifying an element by index\nC. Resizing the array\nD. Initializing the array",
            "output": "C"
        },
        {
            "instruction": "Which method is used to compare two strings ignoring case in Java?",
            "input": "A. compare()\nB. equals()\nC. equalsIgnoreCase()\nD. compareToIgnoreCase()",
            "output": "C"
        },
        {
            "instruction": "Which method is used to find a character at a specific index in a Java string?",
            "input": "A. getCharAt()\nB. charAt()\nC. indexOf()\nD. getIndex()",
            "output": "B"
        },
        {
            "instruction": "What is the index of the last element in an array with 10 elements?",
            "input": "A. 10\nB. 9\nC. 8\nD. Depends on array type",
            "output": "B"
        },
        {
            "instruction": "Which of the following methods is used to get the length of a string in Java?",
            "input": "A. string.size()\nB. string.length()\nC. string.getLength()\nD. string.len()",
            "output": "B"
        },
        {
            "instruction": "Which function combines two strings in Java?",
            "input": "A. add()\nB. join()\nC. concat()\nD. merge()",
            "output": "C"
        },
        {
            "instruction": "What does the following code output?\n\nString str = \"hello\";\nSystem.out.println(str.charAt(0));",
            "input": "A. h\nB. e\nC. o\nD. Error",
            "output": "A"
        },
        {
            "instruction": "Which of the following is true about string immutability in Java?",
            "input": "A. Strings can be modified directly\nB. Strings cannot be changed once created\nC. Strings allow character replacement\nD. Strings support direct element assignment",
            "output": "B"
        },
        {
            "instruction": "What is the purpose of the 'equals()' method in Java?",
            "input": "A. To compare two objects\nB. To check reference equality\nC. To convert a string to lowercase\nD. To replace characters in a string",
            "output": "A"
        },
        {
            "instruction": "What will be the output of this code?\n\nint[] arr = {1, 2, 3, 4};\nSystem.out.println(arr[arr.length - 1]);",
            "input": "A. 1\nB. 2\nC. 3\nD. 4",
            "output": "D"
        },
        {
            "instruction": "Which of the following methods is used to compare two strings lexicographically in Java?",
            "input": "A. compareTo()\nB. equalsIgnoreCase()\nC. isEqual()\nD. compare()",
            "output": "A"
        },
        {
            "instruction": "Which method converts a string to lowercase in Java?",
            "input": "A. toLowerCase()\nB. toUpperCase()\nC. convertLower()\nD. lower()",
            "output": "A"
        },
        {
            "instruction": "What is the primary difference between an array and a string?",
            "input": "A. Arrays can only store numbers, strings store characters\nB. Arrays can store any data type, strings are a sequence of characters\nC. Arrays have dynamic size, strings have fixed size\nD. Arrays are mutable, strings are immutable",
            "output": "D"
        },
        {
            "instruction": "How can you find the number of elements in an array?",
            "input": "A. array.count()\nB. array.size()\nC. array.length\nD. array.length()",
            "output": "C"
        },
        {
            "instruction": "In Java, which keyword is used to create an array?",
            "input": "A. new\nB. array\nC. create\nD. alloc",
            "output": "A"
        },
        {
            "instruction": "Which method replaces characters in a string?",
            "input": "A. replace()\nB. setChar()\nC. change()\nD. replaceChar()",
            "output": "A"
        },
        {
            "instruction": "What is the result of '\"Hello\" + \"World\"' in Java?",
            "input": "A. HelloWorld\nB. Hello World\nC. Error\nD. Null",
            "output": "A"
        },
        {
            "instruction": "Which of the following sorts an array in ascending order?",
            "input": "A. array.sortAsc()\nB. Arrays.sort(array)\nC. Collections.sort(array)\nD. array.sort()",
            "output": "B"
        },
        {
            "instruction": "Which method in Java splits a string based on a specified delimiter?",
            "input": "A. divide()\nB. split()\nC. separate()\nD. splitString()",
            "output": "B"
        },
        {
            "instruction": "Which is true about character arrays vs. strings?",
            "input": "A. Strings are mutable, character arrays are not\nB. Character arrays are mutable, strings are not\nC. Both are mutable\nD. Both are immutable",
            "output": "B"
        },
        {
            "instruction": "What will 'Arrays.binarySearch(arr, 3)' return if 'arr' is an array containing {1, 2, 3, 4}?",
            "input": "A. 2\nB. 3\nC. 1\nD. 4",
            "output": "A"
        },
        {
            "instruction": "What does 'Arrays.equals(array1, array2)' return?",
            "input": "A. True if arrays are identical in reference\nB. True if arrays have same elements in same order\nC. True if arrays have same length\nD. True if arrays are of the same type",
            "output": "B"
        },
        {
            "instruction": "What is an array?",
            "input": "A. A data structure that stores a fixed-size sequential collection of elements of the same type\nB. A data structure that can store multiple types of data\nC. A function that processes a collection of data\nD. A type of loop used in programming",
            "output": "A"
        },
        {
            "instruction": "Which of the following is the correct way to declare an integer array in Java?",
            "input": "A. int array[] = new int[5];\nB. int array[5];\nC. int[] array = new int;\nD. int array = {5};",
            "output": "A"
        },
        {
            "instruction": "What is the index of the first element in an array?",
            "input": "A. 0\nB. 1\nC. -1\nD. Depends on the programming language",
            "output": "A"
        },
        {
            "instruction": "Which method is used to find the length of an array in Java?",
            "input": "A. array.size()\nB. array.length\nC. array.length()\nD. array.getLength()",
            "output": "B"
        },
        {
            "instruction": "What will be the output of the following code snippet?\n\nint[] arr = {1, 2, 3, 4, 5};\nSystem.out.println(arr[2]);",
            "input": "A. 1\nB. 2\nC. 3\nD. 4",
            "output": "C"
        },
        {
            "instruction": "In Java, what is the correct way to create an array of strings?",
            "input": "A. String[] arr = new String[5];\nB. String arr = new String[5];\nC. String arr[5];\nD. String[] arr = String[5];",
            "output": "A"
        },
        {
            "instruction": "What is the result of accessing an array element with an index that is out of bounds?",
            "input": "A. Compilation error\nB. OutOfBoundsException\nC. NullPointerException\nD. ArrayIndexOutOfBoundsException",
            "output": "D"
        },
        {
            "instruction": "What does the method 'Arrays.toString(array)' do in Java?",
            "input": "A. Sorts the array\nB. Converts the array to a string format\nC. Finds the length of the array\nD. Searches for an element in the array",
            "output": "B"
        },
        {
            "instruction": "What is the default value of a string array element in Java?",
            "input": "A. Null\nB. 0\nC. Empty String\nD. Undefined",
            "output": "A"
        },
        {
            "instruction": "Which of the following is true about arrays?",
            "input": "A. Arrays can store elements of different types\nB. The size of an array can be changed after declaration\nC. Arrays are always zero-indexed\nD. Arrays have variable size",
            "output": "C"
        },
        {
            "instruction": "How do you declare a multi-dimensional array in Java?",
            "input": "A. int[][] arr = new int[3][3];\nB. int arr[3][3];\nC. int arr = int[3][3];\nD. new int[3][3] arr;",
            "output": "A"
        },
        {
            "instruction": "What is the time complexity of accessing an element in an array?",
            "input": "A. O(log n)\nB. O(n)\nC. O(1)\nD. O(n^2)",
            "output": "C"
        },
        {
            "instruction": "What is the difference between an array and an ArrayList in Java?",
            "input": "A. Array can grow dynamically, ArrayList cannot\nB. Array is fixed in size, ArrayList can grow dynamically\nC. Array allows only integer elements, ArrayList does not\nD. Array requires wrapper classes, ArrayList does not",
            "output": "B"
        },
        {
            "instruction": "Which of the following methods is used to sort an array in Java?",
            "input": "A. Arrays.sort()\nB. array.sort()\nC. Collections.sort()\nD. List.sort()",
            "output": "A"
        },
        {
            "instruction": "Which operator is used to access an element in an array?",
            "input": "A. . (dot operator)\nB. -> (arrow operator)\nC. [] (bracket operator)\nD. {} (curly braces)",
            "output": "C"
        },
        {
            "instruction": "What will be the output of the following code?\n\nString[] arr = {\"A\", \"B\", \"C\"};\nSystem.out.println(arr.length);",
            "input": "A. 1\nB. 2\nC. 3\nD. 4",
            "output": "C"
        },
        {
            "instruction": "How are elements in an array stored in memory?",
            "input": "A. Randomly\nB. Sequentially\nC. In reverse order\nD. In a stack",
            "output": "B"
        },
        {
            "instruction": "Which of the following will throw an ArrayIndexOutOfBoundsException?",
            "input": "A. Accessing an array element at a negative index\nB. Accessing an element within bounds\nC. Declaring an array of size 10\nD. Initializing an array with default values",
            "output": "A"
        },
        {
            "instruction": "What is the main advantage of using an array over other data structures?",
            "input": "A. Arrays are mutable\nB. Arrays have a fixed size\nC. Arrays provide fast access to elements\nD. Arrays can store different data types",
            "output": "C"
        },
        {
            "instruction": "Which of the following is used to copy elements from one array to another in Java?",
            "input": "A. System.arraycopy()\nB. Arrays.copy()\nC. Collections.copy()\nD. ArrayList.copy()",
            "output": "A"
        }
                        

]